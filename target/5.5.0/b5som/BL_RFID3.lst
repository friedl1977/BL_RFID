
/Users/friedlbasson/Desktop/VSC/BL_RFID3/target/5.5.0/b5som/BL_RFID3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  000b4000  000b4000  00004000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  000b4018  000b4018  00004018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00008118  000b4020  000b4020  00004020  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .note.gnu.build-id 00000024  000bc138  000bc138  0000c138  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000098  2003dde0  000bc15c  0000dde0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000978  2003de78  2003de78  0001de78  2**3
                  ALLOC
  6 .backup       00000004  2003f400  000bc1f4  0000f400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .module_info_product 00000006  000bc1f8  000bc1f8  0001c1f8  2**0
                  ALLOC
  8 .module_info_suffix 00000024  000bc1fe  000bc1fe  0001c1fe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .module_info_crc 00000004  000bc222  000bc222  0001c222  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .debug_info   001766e2  00000000  00000000  0001c226  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 0001826c  00000000  00000000  00192908  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loc    00044c69  00000000  00000000  001aab74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00003238  00000000  00000000  001ef7dd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 0000c240  00000000  00000000  001f2a15  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  000405a8  00000000  00000000  001fec55  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   000504c5  00000000  00000000  0023f1fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0014d9ac  00000000  00000000  0028f6c2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  000091c0  00000000  00000000  003dd070  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

000b4020 <__aeabi_drsub>:
   b4020:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   b4024:	e002      	b.n	b402c <__adddf3>
   b4026:	bf00      	nop

000b4028 <__aeabi_dsub>:
   b4028:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000b402c <__adddf3>:
   b402c:	b530      	push	{r4, r5, lr}
   b402e:	ea4f 0441 	mov.w	r4, r1, lsl #1
   b4032:	ea4f 0543 	mov.w	r5, r3, lsl #1
   b4036:	ea94 0f05 	teq	r4, r5
   b403a:	bf08      	it	eq
   b403c:	ea90 0f02 	teqeq	r0, r2
   b4040:	bf1f      	itttt	ne
   b4042:	ea54 0c00 	orrsne.w	ip, r4, r0
   b4046:	ea55 0c02 	orrsne.w	ip, r5, r2
   b404a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   b404e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   b4052:	f000 80e2 	beq.w	b421a <__adddf3+0x1ee>
   b4056:	ea4f 5454 	mov.w	r4, r4, lsr #21
   b405a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   b405e:	bfb8      	it	lt
   b4060:	426d      	neglt	r5, r5
   b4062:	dd0c      	ble.n	b407e <__adddf3+0x52>
   b4064:	442c      	add	r4, r5
   b4066:	ea80 0202 	eor.w	r2, r0, r2
   b406a:	ea81 0303 	eor.w	r3, r1, r3
   b406e:	ea82 0000 	eor.w	r0, r2, r0
   b4072:	ea83 0101 	eor.w	r1, r3, r1
   b4076:	ea80 0202 	eor.w	r2, r0, r2
   b407a:	ea81 0303 	eor.w	r3, r1, r3
   b407e:	2d36      	cmp	r5, #54	; 0x36
   b4080:	bf88      	it	hi
   b4082:	bd30      	pophi	{r4, r5, pc}
   b4084:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   b4088:	ea4f 3101 	mov.w	r1, r1, lsl #12
   b408c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   b4090:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   b4094:	d002      	beq.n	b409c <__adddf3+0x70>
   b4096:	4240      	negs	r0, r0
   b4098:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   b409c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   b40a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
   b40a4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   b40a8:	d002      	beq.n	b40b0 <__adddf3+0x84>
   b40aa:	4252      	negs	r2, r2
   b40ac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   b40b0:	ea94 0f05 	teq	r4, r5
   b40b4:	f000 80a7 	beq.w	b4206 <__adddf3+0x1da>
   b40b8:	f1a4 0401 	sub.w	r4, r4, #1
   b40bc:	f1d5 0e20 	rsbs	lr, r5, #32
   b40c0:	db0d      	blt.n	b40de <__adddf3+0xb2>
   b40c2:	fa02 fc0e 	lsl.w	ip, r2, lr
   b40c6:	fa22 f205 	lsr.w	r2, r2, r5
   b40ca:	1880      	adds	r0, r0, r2
   b40cc:	f141 0100 	adc.w	r1, r1, #0
   b40d0:	fa03 f20e 	lsl.w	r2, r3, lr
   b40d4:	1880      	adds	r0, r0, r2
   b40d6:	fa43 f305 	asr.w	r3, r3, r5
   b40da:	4159      	adcs	r1, r3
   b40dc:	e00e      	b.n	b40fc <__adddf3+0xd0>
   b40de:	f1a5 0520 	sub.w	r5, r5, #32
   b40e2:	f10e 0e20 	add.w	lr, lr, #32
   b40e6:	2a01      	cmp	r2, #1
   b40e8:	fa03 fc0e 	lsl.w	ip, r3, lr
   b40ec:	bf28      	it	cs
   b40ee:	f04c 0c02 	orrcs.w	ip, ip, #2
   b40f2:	fa43 f305 	asr.w	r3, r3, r5
   b40f6:	18c0      	adds	r0, r0, r3
   b40f8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   b40fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   b4100:	d507      	bpl.n	b4112 <__adddf3+0xe6>
   b4102:	f04f 0e00 	mov.w	lr, #0
   b4106:	f1dc 0c00 	rsbs	ip, ip, #0
   b410a:	eb7e 0000 	sbcs.w	r0, lr, r0
   b410e:	eb6e 0101 	sbc.w	r1, lr, r1
   b4112:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   b4116:	d31b      	bcc.n	b4150 <__adddf3+0x124>
   b4118:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   b411c:	d30c      	bcc.n	b4138 <__adddf3+0x10c>
   b411e:	0849      	lsrs	r1, r1, #1
   b4120:	ea5f 0030 	movs.w	r0, r0, rrx
   b4124:	ea4f 0c3c 	mov.w	ip, ip, rrx
   b4128:	f104 0401 	add.w	r4, r4, #1
   b412c:	ea4f 5244 	mov.w	r2, r4, lsl #21
   b4130:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   b4134:	f080 809a 	bcs.w	b426c <__adddf3+0x240>
   b4138:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   b413c:	bf08      	it	eq
   b413e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   b4142:	f150 0000 	adcs.w	r0, r0, #0
   b4146:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   b414a:	ea41 0105 	orr.w	r1, r1, r5
   b414e:	bd30      	pop	{r4, r5, pc}
   b4150:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   b4154:	4140      	adcs	r0, r0
   b4156:	eb41 0101 	adc.w	r1, r1, r1
   b415a:	3c01      	subs	r4, #1
   b415c:	bf28      	it	cs
   b415e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   b4162:	d2e9      	bcs.n	b4138 <__adddf3+0x10c>
   b4164:	f091 0f00 	teq	r1, #0
   b4168:	bf04      	itt	eq
   b416a:	4601      	moveq	r1, r0
   b416c:	2000      	moveq	r0, #0
   b416e:	fab1 f381 	clz	r3, r1
   b4172:	bf08      	it	eq
   b4174:	3320      	addeq	r3, #32
   b4176:	f1a3 030b 	sub.w	r3, r3, #11
   b417a:	f1b3 0220 	subs.w	r2, r3, #32
   b417e:	da0c      	bge.n	b419a <__adddf3+0x16e>
   b4180:	320c      	adds	r2, #12
   b4182:	dd08      	ble.n	b4196 <__adddf3+0x16a>
   b4184:	f102 0c14 	add.w	ip, r2, #20
   b4188:	f1c2 020c 	rsb	r2, r2, #12
   b418c:	fa01 f00c 	lsl.w	r0, r1, ip
   b4190:	fa21 f102 	lsr.w	r1, r1, r2
   b4194:	e00c      	b.n	b41b0 <__adddf3+0x184>
   b4196:	f102 0214 	add.w	r2, r2, #20
   b419a:	bfd8      	it	le
   b419c:	f1c2 0c20 	rsble	ip, r2, #32
   b41a0:	fa01 f102 	lsl.w	r1, r1, r2
   b41a4:	fa20 fc0c 	lsr.w	ip, r0, ip
   b41a8:	bfdc      	itt	le
   b41aa:	ea41 010c 	orrle.w	r1, r1, ip
   b41ae:	4090      	lslle	r0, r2
   b41b0:	1ae4      	subs	r4, r4, r3
   b41b2:	bfa2      	ittt	ge
   b41b4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   b41b8:	4329      	orrge	r1, r5
   b41ba:	bd30      	popge	{r4, r5, pc}
   b41bc:	ea6f 0404 	mvn.w	r4, r4
   b41c0:	3c1f      	subs	r4, #31
   b41c2:	da1c      	bge.n	b41fe <__adddf3+0x1d2>
   b41c4:	340c      	adds	r4, #12
   b41c6:	dc0e      	bgt.n	b41e6 <__adddf3+0x1ba>
   b41c8:	f104 0414 	add.w	r4, r4, #20
   b41cc:	f1c4 0220 	rsb	r2, r4, #32
   b41d0:	fa20 f004 	lsr.w	r0, r0, r4
   b41d4:	fa01 f302 	lsl.w	r3, r1, r2
   b41d8:	ea40 0003 	orr.w	r0, r0, r3
   b41dc:	fa21 f304 	lsr.w	r3, r1, r4
   b41e0:	ea45 0103 	orr.w	r1, r5, r3
   b41e4:	bd30      	pop	{r4, r5, pc}
   b41e6:	f1c4 040c 	rsb	r4, r4, #12
   b41ea:	f1c4 0220 	rsb	r2, r4, #32
   b41ee:	fa20 f002 	lsr.w	r0, r0, r2
   b41f2:	fa01 f304 	lsl.w	r3, r1, r4
   b41f6:	ea40 0003 	orr.w	r0, r0, r3
   b41fa:	4629      	mov	r1, r5
   b41fc:	bd30      	pop	{r4, r5, pc}
   b41fe:	fa21 f004 	lsr.w	r0, r1, r4
   b4202:	4629      	mov	r1, r5
   b4204:	bd30      	pop	{r4, r5, pc}
   b4206:	f094 0f00 	teq	r4, #0
   b420a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   b420e:	bf06      	itte	eq
   b4210:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   b4214:	3401      	addeq	r4, #1
   b4216:	3d01      	subne	r5, #1
   b4218:	e74e      	b.n	b40b8 <__adddf3+0x8c>
   b421a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   b421e:	bf18      	it	ne
   b4220:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   b4224:	d029      	beq.n	b427a <__adddf3+0x24e>
   b4226:	ea94 0f05 	teq	r4, r5
   b422a:	bf08      	it	eq
   b422c:	ea90 0f02 	teqeq	r0, r2
   b4230:	d005      	beq.n	b423e <__adddf3+0x212>
   b4232:	ea54 0c00 	orrs.w	ip, r4, r0
   b4236:	bf04      	itt	eq
   b4238:	4619      	moveq	r1, r3
   b423a:	4610      	moveq	r0, r2
   b423c:	bd30      	pop	{r4, r5, pc}
   b423e:	ea91 0f03 	teq	r1, r3
   b4242:	bf1e      	ittt	ne
   b4244:	2100      	movne	r1, #0
   b4246:	2000      	movne	r0, #0
   b4248:	bd30      	popne	{r4, r5, pc}
   b424a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   b424e:	d105      	bne.n	b425c <__adddf3+0x230>
   b4250:	0040      	lsls	r0, r0, #1
   b4252:	4149      	adcs	r1, r1
   b4254:	bf28      	it	cs
   b4256:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   b425a:	bd30      	pop	{r4, r5, pc}
   b425c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   b4260:	bf3c      	itt	cc
   b4262:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   b4266:	bd30      	popcc	{r4, r5, pc}
   b4268:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   b426c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   b4270:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   b4274:	f04f 0000 	mov.w	r0, #0
   b4278:	bd30      	pop	{r4, r5, pc}
   b427a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   b427e:	bf1a      	itte	ne
   b4280:	4619      	movne	r1, r3
   b4282:	4610      	movne	r0, r2
   b4284:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   b4288:	bf1c      	itt	ne
   b428a:	460b      	movne	r3, r1
   b428c:	4602      	movne	r2, r0
   b428e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   b4292:	bf06      	itte	eq
   b4294:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   b4298:	ea91 0f03 	teqeq	r1, r3
   b429c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   b42a0:	bd30      	pop	{r4, r5, pc}
   b42a2:	bf00      	nop

000b42a4 <__aeabi_ui2d>:
   b42a4:	f090 0f00 	teq	r0, #0
   b42a8:	bf04      	itt	eq
   b42aa:	2100      	moveq	r1, #0
   b42ac:	4770      	bxeq	lr
   b42ae:	b530      	push	{r4, r5, lr}
   b42b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   b42b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   b42b8:	f04f 0500 	mov.w	r5, #0
   b42bc:	f04f 0100 	mov.w	r1, #0
   b42c0:	e750      	b.n	b4164 <__adddf3+0x138>
   b42c2:	bf00      	nop

000b42c4 <__aeabi_i2d>:
   b42c4:	f090 0f00 	teq	r0, #0
   b42c8:	bf04      	itt	eq
   b42ca:	2100      	moveq	r1, #0
   b42cc:	4770      	bxeq	lr
   b42ce:	b530      	push	{r4, r5, lr}
   b42d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   b42d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   b42d8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   b42dc:	bf48      	it	mi
   b42de:	4240      	negmi	r0, r0
   b42e0:	f04f 0100 	mov.w	r1, #0
   b42e4:	e73e      	b.n	b4164 <__adddf3+0x138>
   b42e6:	bf00      	nop

000b42e8 <__aeabi_f2d>:
   b42e8:	0042      	lsls	r2, r0, #1
   b42ea:	ea4f 01e2 	mov.w	r1, r2, asr #3
   b42ee:	ea4f 0131 	mov.w	r1, r1, rrx
   b42f2:	ea4f 7002 	mov.w	r0, r2, lsl #28
   b42f6:	bf1f      	itttt	ne
   b42f8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   b42fc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   b4300:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   b4304:	4770      	bxne	lr
   b4306:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   b430a:	bf08      	it	eq
   b430c:	4770      	bxeq	lr
   b430e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   b4312:	bf04      	itt	eq
   b4314:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   b4318:	4770      	bxeq	lr
   b431a:	b530      	push	{r4, r5, lr}
   b431c:	f44f 7460 	mov.w	r4, #896	; 0x380
   b4320:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   b4324:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   b4328:	e71c      	b.n	b4164 <__adddf3+0x138>
   b432a:	bf00      	nop

000b432c <__aeabi_ul2d>:
   b432c:	ea50 0201 	orrs.w	r2, r0, r1
   b4330:	bf08      	it	eq
   b4332:	4770      	bxeq	lr
   b4334:	b530      	push	{r4, r5, lr}
   b4336:	f04f 0500 	mov.w	r5, #0
   b433a:	e00a      	b.n	b4352 <__aeabi_l2d+0x16>

000b433c <__aeabi_l2d>:
   b433c:	ea50 0201 	orrs.w	r2, r0, r1
   b4340:	bf08      	it	eq
   b4342:	4770      	bxeq	lr
   b4344:	b530      	push	{r4, r5, lr}
   b4346:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   b434a:	d502      	bpl.n	b4352 <__aeabi_l2d+0x16>
   b434c:	4240      	negs	r0, r0
   b434e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   b4352:	f44f 6480 	mov.w	r4, #1024	; 0x400
   b4356:	f104 0432 	add.w	r4, r4, #50	; 0x32
   b435a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   b435e:	f43f aed8 	beq.w	b4112 <__adddf3+0xe6>
   b4362:	f04f 0203 	mov.w	r2, #3
   b4366:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   b436a:	bf18      	it	ne
   b436c:	3203      	addne	r2, #3
   b436e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   b4372:	bf18      	it	ne
   b4374:	3203      	addne	r2, #3
   b4376:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   b437a:	f1c2 0320 	rsb	r3, r2, #32
   b437e:	fa00 fc03 	lsl.w	ip, r0, r3
   b4382:	fa20 f002 	lsr.w	r0, r0, r2
   b4386:	fa01 fe03 	lsl.w	lr, r1, r3
   b438a:	ea40 000e 	orr.w	r0, r0, lr
   b438e:	fa21 f102 	lsr.w	r1, r1, r2
   b4392:	4414      	add	r4, r2
   b4394:	e6bd      	b.n	b4112 <__adddf3+0xe6>
   b4396:	bf00      	nop

000b4398 <__aeabi_dmul>:
   b4398:	b570      	push	{r4, r5, r6, lr}
   b439a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   b439e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   b43a2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   b43a6:	bf1d      	ittte	ne
   b43a8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   b43ac:	ea94 0f0c 	teqne	r4, ip
   b43b0:	ea95 0f0c 	teqne	r5, ip
   b43b4:	f000 f8de 	bleq	b4574 <__aeabi_dmul+0x1dc>
   b43b8:	442c      	add	r4, r5
   b43ba:	ea81 0603 	eor.w	r6, r1, r3
   b43be:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   b43c2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   b43c6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   b43ca:	bf18      	it	ne
   b43cc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   b43d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   b43d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   b43d8:	d038      	beq.n	b444c <__aeabi_dmul+0xb4>
   b43da:	fba0 ce02 	umull	ip, lr, r0, r2
   b43de:	f04f 0500 	mov.w	r5, #0
   b43e2:	fbe1 e502 	umlal	lr, r5, r1, r2
   b43e6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   b43ea:	fbe0 e503 	umlal	lr, r5, r0, r3
   b43ee:	f04f 0600 	mov.w	r6, #0
   b43f2:	fbe1 5603 	umlal	r5, r6, r1, r3
   b43f6:	f09c 0f00 	teq	ip, #0
   b43fa:	bf18      	it	ne
   b43fc:	f04e 0e01 	orrne.w	lr, lr, #1
   b4400:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   b4404:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   b4408:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   b440c:	d204      	bcs.n	b4418 <__aeabi_dmul+0x80>
   b440e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   b4412:	416d      	adcs	r5, r5
   b4414:	eb46 0606 	adc.w	r6, r6, r6
   b4418:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   b441c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   b4420:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   b4424:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   b4428:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   b442c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   b4430:	bf88      	it	hi
   b4432:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   b4436:	d81e      	bhi.n	b4476 <__aeabi_dmul+0xde>
   b4438:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   b443c:	bf08      	it	eq
   b443e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   b4442:	f150 0000 	adcs.w	r0, r0, #0
   b4446:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   b444a:	bd70      	pop	{r4, r5, r6, pc}
   b444c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   b4450:	ea46 0101 	orr.w	r1, r6, r1
   b4454:	ea40 0002 	orr.w	r0, r0, r2
   b4458:	ea81 0103 	eor.w	r1, r1, r3
   b445c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   b4460:	bfc2      	ittt	gt
   b4462:	ebd4 050c 	rsbsgt	r5, r4, ip
   b4466:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   b446a:	bd70      	popgt	{r4, r5, r6, pc}
   b446c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   b4470:	f04f 0e00 	mov.w	lr, #0
   b4474:	3c01      	subs	r4, #1
   b4476:	f300 80ab 	bgt.w	b45d0 <__aeabi_dmul+0x238>
   b447a:	f114 0f36 	cmn.w	r4, #54	; 0x36
   b447e:	bfde      	ittt	le
   b4480:	2000      	movle	r0, #0
   b4482:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   b4486:	bd70      	pople	{r4, r5, r6, pc}
   b4488:	f1c4 0400 	rsb	r4, r4, #0
   b448c:	3c20      	subs	r4, #32
   b448e:	da35      	bge.n	b44fc <__aeabi_dmul+0x164>
   b4490:	340c      	adds	r4, #12
   b4492:	dc1b      	bgt.n	b44cc <__aeabi_dmul+0x134>
   b4494:	f104 0414 	add.w	r4, r4, #20
   b4498:	f1c4 0520 	rsb	r5, r4, #32
   b449c:	fa00 f305 	lsl.w	r3, r0, r5
   b44a0:	fa20 f004 	lsr.w	r0, r0, r4
   b44a4:	fa01 f205 	lsl.w	r2, r1, r5
   b44a8:	ea40 0002 	orr.w	r0, r0, r2
   b44ac:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   b44b0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   b44b4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   b44b8:	fa21 f604 	lsr.w	r6, r1, r4
   b44bc:	eb42 0106 	adc.w	r1, r2, r6
   b44c0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   b44c4:	bf08      	it	eq
   b44c6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   b44ca:	bd70      	pop	{r4, r5, r6, pc}
   b44cc:	f1c4 040c 	rsb	r4, r4, #12
   b44d0:	f1c4 0520 	rsb	r5, r4, #32
   b44d4:	fa00 f304 	lsl.w	r3, r0, r4
   b44d8:	fa20 f005 	lsr.w	r0, r0, r5
   b44dc:	fa01 f204 	lsl.w	r2, r1, r4
   b44e0:	ea40 0002 	orr.w	r0, r0, r2
   b44e4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   b44e8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   b44ec:	f141 0100 	adc.w	r1, r1, #0
   b44f0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   b44f4:	bf08      	it	eq
   b44f6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   b44fa:	bd70      	pop	{r4, r5, r6, pc}
   b44fc:	f1c4 0520 	rsb	r5, r4, #32
   b4500:	fa00 f205 	lsl.w	r2, r0, r5
   b4504:	ea4e 0e02 	orr.w	lr, lr, r2
   b4508:	fa20 f304 	lsr.w	r3, r0, r4
   b450c:	fa01 f205 	lsl.w	r2, r1, r5
   b4510:	ea43 0302 	orr.w	r3, r3, r2
   b4514:	fa21 f004 	lsr.w	r0, r1, r4
   b4518:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   b451c:	fa21 f204 	lsr.w	r2, r1, r4
   b4520:	ea20 0002 	bic.w	r0, r0, r2
   b4524:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   b4528:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   b452c:	bf08      	it	eq
   b452e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   b4532:	bd70      	pop	{r4, r5, r6, pc}
   b4534:	f094 0f00 	teq	r4, #0
   b4538:	d10f      	bne.n	b455a <__aeabi_dmul+0x1c2>
   b453a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   b453e:	0040      	lsls	r0, r0, #1
   b4540:	eb41 0101 	adc.w	r1, r1, r1
   b4544:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   b4548:	bf08      	it	eq
   b454a:	3c01      	subeq	r4, #1
   b454c:	d0f7      	beq.n	b453e <__aeabi_dmul+0x1a6>
   b454e:	ea41 0106 	orr.w	r1, r1, r6
   b4552:	f095 0f00 	teq	r5, #0
   b4556:	bf18      	it	ne
   b4558:	4770      	bxne	lr
   b455a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   b455e:	0052      	lsls	r2, r2, #1
   b4560:	eb43 0303 	adc.w	r3, r3, r3
   b4564:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   b4568:	bf08      	it	eq
   b456a:	3d01      	subeq	r5, #1
   b456c:	d0f7      	beq.n	b455e <__aeabi_dmul+0x1c6>
   b456e:	ea43 0306 	orr.w	r3, r3, r6
   b4572:	4770      	bx	lr
   b4574:	ea94 0f0c 	teq	r4, ip
   b4578:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   b457c:	bf18      	it	ne
   b457e:	ea95 0f0c 	teqne	r5, ip
   b4582:	d00c      	beq.n	b459e <__aeabi_dmul+0x206>
   b4584:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   b4588:	bf18      	it	ne
   b458a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   b458e:	d1d1      	bne.n	b4534 <__aeabi_dmul+0x19c>
   b4590:	ea81 0103 	eor.w	r1, r1, r3
   b4594:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   b4598:	f04f 0000 	mov.w	r0, #0
   b459c:	bd70      	pop	{r4, r5, r6, pc}
   b459e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   b45a2:	bf06      	itte	eq
   b45a4:	4610      	moveq	r0, r2
   b45a6:	4619      	moveq	r1, r3
   b45a8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   b45ac:	d019      	beq.n	b45e2 <__aeabi_dmul+0x24a>
   b45ae:	ea94 0f0c 	teq	r4, ip
   b45b2:	d102      	bne.n	b45ba <__aeabi_dmul+0x222>
   b45b4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   b45b8:	d113      	bne.n	b45e2 <__aeabi_dmul+0x24a>
   b45ba:	ea95 0f0c 	teq	r5, ip
   b45be:	d105      	bne.n	b45cc <__aeabi_dmul+0x234>
   b45c0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   b45c4:	bf1c      	itt	ne
   b45c6:	4610      	movne	r0, r2
   b45c8:	4619      	movne	r1, r3
   b45ca:	d10a      	bne.n	b45e2 <__aeabi_dmul+0x24a>
   b45cc:	ea81 0103 	eor.w	r1, r1, r3
   b45d0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   b45d4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   b45d8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   b45dc:	f04f 0000 	mov.w	r0, #0
   b45e0:	bd70      	pop	{r4, r5, r6, pc}
   b45e2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   b45e6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   b45ea:	bd70      	pop	{r4, r5, r6, pc}

000b45ec <__aeabi_ddiv>:
   b45ec:	b570      	push	{r4, r5, r6, lr}
   b45ee:	f04f 0cff 	mov.w	ip, #255	; 0xff
   b45f2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   b45f6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   b45fa:	bf1d      	ittte	ne
   b45fc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   b4600:	ea94 0f0c 	teqne	r4, ip
   b4604:	ea95 0f0c 	teqne	r5, ip
   b4608:	f000 f8a7 	bleq	b475a <__aeabi_ddiv+0x16e>
   b460c:	eba4 0405 	sub.w	r4, r4, r5
   b4610:	ea81 0e03 	eor.w	lr, r1, r3
   b4614:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   b4618:	ea4f 3101 	mov.w	r1, r1, lsl #12
   b461c:	f000 8088 	beq.w	b4730 <__aeabi_ddiv+0x144>
   b4620:	ea4f 3303 	mov.w	r3, r3, lsl #12
   b4624:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   b4628:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   b462c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   b4630:	ea4f 2202 	mov.w	r2, r2, lsl #8
   b4634:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   b4638:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   b463c:	ea4f 2600 	mov.w	r6, r0, lsl #8
   b4640:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   b4644:	429d      	cmp	r5, r3
   b4646:	bf08      	it	eq
   b4648:	4296      	cmpeq	r6, r2
   b464a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   b464e:	f504 7440 	add.w	r4, r4, #768	; 0x300
   b4652:	d202      	bcs.n	b465a <__aeabi_ddiv+0x6e>
   b4654:	085b      	lsrs	r3, r3, #1
   b4656:	ea4f 0232 	mov.w	r2, r2, rrx
   b465a:	1ab6      	subs	r6, r6, r2
   b465c:	eb65 0503 	sbc.w	r5, r5, r3
   b4660:	085b      	lsrs	r3, r3, #1
   b4662:	ea4f 0232 	mov.w	r2, r2, rrx
   b4666:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   b466a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   b466e:	ebb6 0e02 	subs.w	lr, r6, r2
   b4672:	eb75 0e03 	sbcs.w	lr, r5, r3
   b4676:	bf22      	ittt	cs
   b4678:	1ab6      	subcs	r6, r6, r2
   b467a:	4675      	movcs	r5, lr
   b467c:	ea40 000c 	orrcs.w	r0, r0, ip
   b4680:	085b      	lsrs	r3, r3, #1
   b4682:	ea4f 0232 	mov.w	r2, r2, rrx
   b4686:	ebb6 0e02 	subs.w	lr, r6, r2
   b468a:	eb75 0e03 	sbcs.w	lr, r5, r3
   b468e:	bf22      	ittt	cs
   b4690:	1ab6      	subcs	r6, r6, r2
   b4692:	4675      	movcs	r5, lr
   b4694:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   b4698:	085b      	lsrs	r3, r3, #1
   b469a:	ea4f 0232 	mov.w	r2, r2, rrx
   b469e:	ebb6 0e02 	subs.w	lr, r6, r2
   b46a2:	eb75 0e03 	sbcs.w	lr, r5, r3
   b46a6:	bf22      	ittt	cs
   b46a8:	1ab6      	subcs	r6, r6, r2
   b46aa:	4675      	movcs	r5, lr
   b46ac:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   b46b0:	085b      	lsrs	r3, r3, #1
   b46b2:	ea4f 0232 	mov.w	r2, r2, rrx
   b46b6:	ebb6 0e02 	subs.w	lr, r6, r2
   b46ba:	eb75 0e03 	sbcs.w	lr, r5, r3
   b46be:	bf22      	ittt	cs
   b46c0:	1ab6      	subcs	r6, r6, r2
   b46c2:	4675      	movcs	r5, lr
   b46c4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   b46c8:	ea55 0e06 	orrs.w	lr, r5, r6
   b46cc:	d018      	beq.n	b4700 <__aeabi_ddiv+0x114>
   b46ce:	ea4f 1505 	mov.w	r5, r5, lsl #4
   b46d2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   b46d6:	ea4f 1606 	mov.w	r6, r6, lsl #4
   b46da:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   b46de:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   b46e2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   b46e6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   b46ea:	d1c0      	bne.n	b466e <__aeabi_ddiv+0x82>
   b46ec:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   b46f0:	d10b      	bne.n	b470a <__aeabi_ddiv+0x11e>
   b46f2:	ea41 0100 	orr.w	r1, r1, r0
   b46f6:	f04f 0000 	mov.w	r0, #0
   b46fa:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   b46fe:	e7b6      	b.n	b466e <__aeabi_ddiv+0x82>
   b4700:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   b4704:	bf04      	itt	eq
   b4706:	4301      	orreq	r1, r0
   b4708:	2000      	moveq	r0, #0
   b470a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   b470e:	bf88      	it	hi
   b4710:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   b4714:	f63f aeaf 	bhi.w	b4476 <__aeabi_dmul+0xde>
   b4718:	ebb5 0c03 	subs.w	ip, r5, r3
   b471c:	bf04      	itt	eq
   b471e:	ebb6 0c02 	subseq.w	ip, r6, r2
   b4722:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   b4726:	f150 0000 	adcs.w	r0, r0, #0
   b472a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   b472e:	bd70      	pop	{r4, r5, r6, pc}
   b4730:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   b4734:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   b4738:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   b473c:	bfc2      	ittt	gt
   b473e:	ebd4 050c 	rsbsgt	r5, r4, ip
   b4742:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   b4746:	bd70      	popgt	{r4, r5, r6, pc}
   b4748:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   b474c:	f04f 0e00 	mov.w	lr, #0
   b4750:	3c01      	subs	r4, #1
   b4752:	e690      	b.n	b4476 <__aeabi_dmul+0xde>
   b4754:	ea45 0e06 	orr.w	lr, r5, r6
   b4758:	e68d      	b.n	b4476 <__aeabi_dmul+0xde>
   b475a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   b475e:	ea94 0f0c 	teq	r4, ip
   b4762:	bf08      	it	eq
   b4764:	ea95 0f0c 	teqeq	r5, ip
   b4768:	f43f af3b 	beq.w	b45e2 <__aeabi_dmul+0x24a>
   b476c:	ea94 0f0c 	teq	r4, ip
   b4770:	d10a      	bne.n	b4788 <__aeabi_ddiv+0x19c>
   b4772:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   b4776:	f47f af34 	bne.w	b45e2 <__aeabi_dmul+0x24a>
   b477a:	ea95 0f0c 	teq	r5, ip
   b477e:	f47f af25 	bne.w	b45cc <__aeabi_dmul+0x234>
   b4782:	4610      	mov	r0, r2
   b4784:	4619      	mov	r1, r3
   b4786:	e72c      	b.n	b45e2 <__aeabi_dmul+0x24a>
   b4788:	ea95 0f0c 	teq	r5, ip
   b478c:	d106      	bne.n	b479c <__aeabi_ddiv+0x1b0>
   b478e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   b4792:	f43f aefd 	beq.w	b4590 <__aeabi_dmul+0x1f8>
   b4796:	4610      	mov	r0, r2
   b4798:	4619      	mov	r1, r3
   b479a:	e722      	b.n	b45e2 <__aeabi_dmul+0x24a>
   b479c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   b47a0:	bf18      	it	ne
   b47a2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   b47a6:	f47f aec5 	bne.w	b4534 <__aeabi_dmul+0x19c>
   b47aa:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   b47ae:	f47f af0d 	bne.w	b45cc <__aeabi_dmul+0x234>
   b47b2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   b47b6:	f47f aeeb 	bne.w	b4590 <__aeabi_dmul+0x1f8>
   b47ba:	e712      	b.n	b45e2 <__aeabi_dmul+0x24a>

000b47bc <__aeabi_d2iz>:
   b47bc:	ea4f 0241 	mov.w	r2, r1, lsl #1
   b47c0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   b47c4:	d215      	bcs.n	b47f2 <__aeabi_d2iz+0x36>
   b47c6:	d511      	bpl.n	b47ec <__aeabi_d2iz+0x30>
   b47c8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   b47cc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   b47d0:	d912      	bls.n	b47f8 <__aeabi_d2iz+0x3c>
   b47d2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   b47d6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   b47da:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   b47de:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   b47e2:	fa23 f002 	lsr.w	r0, r3, r2
   b47e6:	bf18      	it	ne
   b47e8:	4240      	negne	r0, r0
   b47ea:	4770      	bx	lr
   b47ec:	f04f 0000 	mov.w	r0, #0
   b47f0:	4770      	bx	lr
   b47f2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   b47f6:	d105      	bne.n	b4804 <__aeabi_d2iz+0x48>
   b47f8:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   b47fc:	bf08      	it	eq
   b47fe:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   b4802:	4770      	bx	lr
   b4804:	f04f 0000 	mov.w	r0, #0
   b4808:	4770      	bx	lr
   b480a:	bf00      	nop

000b480c <__aeabi_d2uiz>:
   b480c:	004a      	lsls	r2, r1, #1
   b480e:	d211      	bcs.n	b4834 <__aeabi_d2uiz+0x28>
   b4810:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   b4814:	d211      	bcs.n	b483a <__aeabi_d2uiz+0x2e>
   b4816:	d50d      	bpl.n	b4834 <__aeabi_d2uiz+0x28>
   b4818:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   b481c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   b4820:	d40e      	bmi.n	b4840 <__aeabi_d2uiz+0x34>
   b4822:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   b4826:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   b482a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   b482e:	fa23 f002 	lsr.w	r0, r3, r2
   b4832:	4770      	bx	lr
   b4834:	f04f 0000 	mov.w	r0, #0
   b4838:	4770      	bx	lr
   b483a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   b483e:	d102      	bne.n	b4846 <__aeabi_d2uiz+0x3a>
   b4840:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   b4844:	4770      	bx	lr
   b4846:	f04f 0000 	mov.w	r0, #0
   b484a:	4770      	bx	lr

000b484c <__aeabi_f2lz>:
   b484c:	ee07 0a90 	vmov	s15, r0
   b4850:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   b4854:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   b4858:	d401      	bmi.n	b485e <__aeabi_f2lz+0x12>
   b485a:	f000 b80b 	b.w	b4874 <__aeabi_f2ulz>
   b485e:	eef1 7a67 	vneg.f32	s15, s15
   b4862:	b508      	push	{r3, lr}
   b4864:	ee17 0a90 	vmov	r0, s15
   b4868:	f000 f804 	bl	b4874 <__aeabi_f2ulz>
   b486c:	4240      	negs	r0, r0
   b486e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   b4872:	bd08      	pop	{r3, pc}

000b4874 <__aeabi_f2ulz>:
   b4874:	b5d0      	push	{r4, r6, r7, lr}
   b4876:	f7ff fd37 	bl	b42e8 <__aeabi_f2d>
   b487a:	4b0c      	ldr	r3, [pc, #48]	; (b48ac <__aeabi_f2ulz+0x38>)
   b487c:	2200      	movs	r2, #0
   b487e:	4606      	mov	r6, r0
   b4880:	460f      	mov	r7, r1
   b4882:	f7ff fd89 	bl	b4398 <__aeabi_dmul>
   b4886:	f7ff ffc1 	bl	b480c <__aeabi_d2uiz>
   b488a:	4604      	mov	r4, r0
   b488c:	f7ff fd0a 	bl	b42a4 <__aeabi_ui2d>
   b4890:	4b07      	ldr	r3, [pc, #28]	; (b48b0 <__aeabi_f2ulz+0x3c>)
   b4892:	2200      	movs	r2, #0
   b4894:	f7ff fd80 	bl	b4398 <__aeabi_dmul>
   b4898:	4602      	mov	r2, r0
   b489a:	460b      	mov	r3, r1
   b489c:	4630      	mov	r0, r6
   b489e:	4639      	mov	r1, r7
   b48a0:	f7ff fbc2 	bl	b4028 <__aeabi_dsub>
   b48a4:	f7ff ffb2 	bl	b480c <__aeabi_d2uiz>
   b48a8:	4621      	mov	r1, r4
   b48aa:	bdd0      	pop	{r4, r6, r7, pc}
   b48ac:	3df00000 	.word	0x3df00000
   b48b0:	41f00000 	.word	0x41f00000

000b48b4 <strcmp>:
   b48b4:	f810 2b01 	ldrb.w	r2, [r0], #1
   b48b8:	f811 3b01 	ldrb.w	r3, [r1], #1
   b48bc:	2a01      	cmp	r2, #1
   b48be:	bf28      	it	cs
   b48c0:	429a      	cmpcs	r2, r3
   b48c2:	d0f7      	beq.n	b48b4 <strcmp>
   b48c4:	1ad0      	subs	r0, r2, r3
   b48c6:	4770      	bx	lr

000b48c8 <strlen>:
   b48c8:	4603      	mov	r3, r0
   b48ca:	f813 2b01 	ldrb.w	r2, [r3], #1
   b48ce:	2a00      	cmp	r2, #0
   b48d0:	d1fb      	bne.n	b48ca <strlen+0x2>
   b48d2:	1a18      	subs	r0, r3, r0
   b48d4:	3801      	subs	r0, #1
   b48d6:	4770      	bx	lr

000b48d8 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   b48d8:	4809      	ldr	r0, [pc, #36]	; (b4900 <module_user_pre_init+0x28>)
   b48da:	490a      	ldr	r1, [pc, #40]	; (b4904 <module_user_pre_init+0x2c>)
   b48dc:	4288      	cmp	r0, r1
void* module_user_pre_init() {
   b48de:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   b48e0:	d005      	beq.n	b48ee <module_user_pre_init+0x16>
   b48e2:	4a09      	ldr	r2, [pc, #36]	; (b4908 <module_user_pre_init+0x30>)
   b48e4:	4282      	cmp	r2, r0
   b48e6:	d002      	beq.n	b48ee <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
   b48e8:	1a12      	subs	r2, r2, r0
   b48ea:	f003 fc9a 	bl	b8222 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
   b48ee:	4807      	ldr	r0, [pc, #28]	; (b490c <module_user_pre_init+0x34>)
   b48f0:	4a07      	ldr	r2, [pc, #28]	; (b4910 <module_user_pre_init+0x38>)
   b48f2:	2100      	movs	r1, #0
   b48f4:	1a12      	subs	r2, r2, r0
   b48f6:	f003 fca2 	bl	b823e <memset>
    return &link_global_data_start;
}
   b48fa:	4801      	ldr	r0, [pc, #4]	; (b4900 <module_user_pre_init+0x28>)
   b48fc:	bd08      	pop	{r3, pc}
   b48fe:	bf00      	nop
   b4900:	2003dde0 	.word	0x2003dde0
   b4904:	000bc15c 	.word	0x000bc15c
   b4908:	2003de78 	.word	0x2003de78
   b490c:	2003de78 	.word	0x2003de78
   b4910:	2003e7f0 	.word	0x2003e7f0

000b4914 <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
   b4914:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();

    // invoke constructors
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b4916:	4e07      	ldr	r6, [pc, #28]	; (b4934 <module_user_init+0x20>)
   b4918:	4c07      	ldr	r4, [pc, #28]	; (b4938 <module_user_init+0x24>)
    module_user_init_hook();
   b491a:	f003 fb47 	bl	b7fac <module_user_init_hook>
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b491e:	1ba4      	subs	r4, r4, r6
   b4920:	08a4      	lsrs	r4, r4, #2
   b4922:	2500      	movs	r5, #0
   b4924:	42ac      	cmp	r4, r5
   b4926:	d100      	bne.n	b492a <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
   b4928:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
   b492a:	f856 3b04 	ldr.w	r3, [r6], #4
   b492e:	4798      	blx	r3
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b4930:	3501      	adds	r5, #1
   b4932:	e7f7      	b.n	b4924 <module_user_init+0x10>
   b4934:	000bc114 	.word	0x000bc114
   b4938:	000bc138 	.word	0x000bc138

000b493c <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
   b493c:	f000 b858 	b.w	b49f0 <setup>

000b4940 <module_user_loop>:
}

void module_user_loop() {
   b4940:	b508      	push	{r3, lr}
    loop();
   b4942:	f000 fdb3 	bl	b54ac <loop>
    _post_loop();
}
   b4946:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
   b494a:	f003 bae7 	b.w	b7f1c <_post_loop>

000b494e <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
   b494e:	f002 b81b 	b.w	b6988 <malloc>

000b4952 <_Znaj>:
   b4952:	f002 b819 	b.w	b6988 <malloc>

000b4956 <_ZdlPvj>:
	free(p);
}

void operator delete(void *p, size_t size)
{
	free(p);
   b4956:	f002 b81f 	b.w	b6998 <free>

000b495a <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
   b495a:	7800      	ldrb	r0, [r0, #0]
   b495c:	fab0 f080 	clz	r0, r0
   b4960:	0940      	lsrs	r0, r0, #5
   b4962:	4770      	bx	lr

000b4964 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
   b4964:	2301      	movs	r3, #1
   b4966:	7003      	strb	r3, [r0, #0]
   b4968:	4770      	bx	lr
	...

000b496c <_ZN11myStructureC1Ev>:
String Identifier;
String rfid_uid = "";
String hhmmss;
String data_time;

struct myStructure{
   b496c:	b538      	push	{r3, r4, r5, lr}
   b496e:	4d1f      	ldr	r5, [pc, #124]	; (b49ec <_ZN11myStructureC1Ev+0x80>)
   b4970:	4604      	mov	r4, r0
   b4972:	4629      	mov	r1, r5
   b4974:	f002 ff57 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b4978:	4629      	mov	r1, r5
   b497a:	f104 0010 	add.w	r0, r4, #16
   b497e:	f002 ff52 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b4982:	4629      	mov	r1, r5
   b4984:	f104 0020 	add.w	r0, r4, #32
   b4988:	f002 ff4d 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b498c:	4629      	mov	r1, r5
   b498e:	f104 0030 	add.w	r0, r4, #48	; 0x30
   b4992:	f002 ff48 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b4996:	4629      	mov	r1, r5
   b4998:	f104 0040 	add.w	r0, r4, #64	; 0x40
   b499c:	f002 ff43 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49a0:	4629      	mov	r1, r5
   b49a2:	f104 0050 	add.w	r0, r4, #80	; 0x50
   b49a6:	f002 ff3e 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49aa:	4629      	mov	r1, r5
   b49ac:	f104 0060 	add.w	r0, r4, #96	; 0x60
   b49b0:	f002 ff39 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49b4:	4629      	mov	r1, r5
   b49b6:	f104 0070 	add.w	r0, r4, #112	; 0x70
   b49ba:	f002 ff34 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49be:	4629      	mov	r1, r5
   b49c0:	f104 0080 	add.w	r0, r4, #128	; 0x80
   b49c4:	f002 ff2f 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49c8:	4629      	mov	r1, r5
   b49ca:	f104 0090 	add.w	r0, r4, #144	; 0x90
   b49ce:	f002 ff2a 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49d2:	4629      	mov	r1, r5
   b49d4:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   b49d8:	f002 ff25 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49dc:	4629      	mov	r1, r5
   b49de:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
   b49e2:	f002 ff20 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
   b49e6:	4620      	mov	r0, r4
   b49e8:	bd38      	pop	{r3, r4, r5, pc}
   b49ea:	bf00      	nop
   b49ec:	000b8734 	.word	0x000b8734

000b49f0 <setup>:

char data[10] = "data";   //default data

int Handler_STATE = 0;

void setup() {
   b49f0:	b530      	push	{r4, r5, lr}
   b49f2:	b087      	sub	sp, #28

  Serial.begin(115200);
   b49f4:	f003 f9f8 	bl	b7de8 <_Z16_fetch_usbserialv>
    int publishVitals(system_tick_t period_s = particle::NOW);
    inline int publishVitals(std::chrono::seconds s) { return publishVitals(s.count()); }

    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
    {
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
   b49f8:	2500      	movs	r5, #0
   b49fa:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
   b49fe:	f003 f9e7 	bl	b7dd0 <_ZN9USBSerial5beginEl>
   b4a02:	4924      	ldr	r1, [pc, #144]	; (b4a94 <setup+0xa4>)
   b4a04:	4824      	ldr	r0, [pc, #144]	; (b4a98 <setup+0xa8>)
   b4a06:	462b      	mov	r3, r5
   b4a08:	462a      	mov	r2, r5
   b4a0a:	e9cd 5500 	strd	r5, r5, [sp]
   b4a0e:	f001 ff33 	bl	b6878 <spark_subscribe>
inline CloudDisconnectOptions::CloudDisconnectOptions() :
        CloudDisconnectOptions(0, 0, false, false) {
}

inline CloudDisconnectOptions::CloudDisconnectOptions(unsigned flags, system_tick_t timeout, bool graceful,
        bool clearSession) :
   b4a12:	2401      	movs	r4, #1
inline bool CloudDisconnectOptions::isGracefulSet() const {
    return (flags_ & SPARK_CLOUD_DISCONNECT_OPTION_GRACEFUL);
}

inline CloudDisconnectOptions& CloudDisconnectOptions::timeout(system_tick_t timeout) {
    timeout_ = timeout;
   b4a14:	2203      	movs	r2, #3
   b4a16:	f241 3388 	movw	r3, #5000	; 0x1388

  Particle.subscribe("hook-response/get_data", myHandler, MY_DEVICES);
  Particle.setDisconnectOptions(CloudDisconnectOptions().graceful(true).timeout(5s));
   b4a1a:	a803      	add	r0, sp, #12
   b4a1c:	e9cd 2303 	strd	r2, r3, [sp, #12]
        bool clearSession) :
   b4a20:	f8ad 4014 	strh.w	r4, [sp, #20]
   b4a24:	f002 f903 	bl	b6c2e <_ZN10CloudClass20setDisconnectOptionsERK22CloudDisconnectOptions>

  pinMode(BATON, OUTPUT);
   b4a28:	4621      	mov	r1, r4
   b4a2a:	2016      	movs	r0, #22
   b4a2c:	f003 fb2e 	bl	b808c <pinMode>
  digitalWrite(BATON,HIGH);
   b4a30:	4621      	mov	r1, r4
   b4a32:	2016      	movs	r0, #22
   b4a34:	f003 fb3b 	bl	b80ae <digitalWrite>
  pinMode (BUZZER, OUTPUT);
   b4a38:	4621      	mov	r1, r4
   b4a3a:	2009      	movs	r0, #9
   b4a3c:	f003 fb26 	bl	b808c <pinMode>
  digitalWrite (BUZZER, LOW);
   b4a40:	4629      	mov	r1, r5
   b4a42:	2009      	movs	r0, #9
   b4a44:	f003 fb33 	bl	b80ae <digitalWrite>
  pinMode(LDO_EN, OUTPUT);
   b4a48:	4621      	mov	r1, r4
   b4a4a:	2017      	movs	r0, #23
   b4a4c:	f003 fb1e 	bl	b808c <pinMode>
  digitalWrite(LDO_EN, HIGH);
   b4a50:	4621      	mov	r1, r4
   b4a52:	2017      	movs	r0, #23
   b4a54:	f003 fb2b 	bl	b80ae <digitalWrite>

  gauge.reset();                                  // Resets MAX1720x
   b4a58:	4810      	ldr	r0, [pc, #64]	; (b4a9c <setup+0xac>)

// Initialise RFID --- START
  Serial.println();
  Serial.print("Initializing PN532");
  while (!nfc.begin()) {
   b4a5a:	4d11      	ldr	r5, [pc, #68]	; (b4aa0 <setup+0xb0>)
    Serial.print(".");
   b4a5c:	4c11      	ldr	r4, [pc, #68]	; (b4aa4 <setup+0xb4>)
  gauge.reset();                                  // Resets MAX1720x
   b4a5e:	f001 fa57 	bl	b5f10 <_ZN8max1720x5resetEv>
  Serial.println();
   b4a62:	f003 f9c1 	bl	b7de8 <_Z16_fetch_usbserialv>
   b4a66:	f002 fd7a 	bl	b755e <_ZN5Print7printlnEv>
  Serial.print("Initializing PN532");
   b4a6a:	f003 f9bd 	bl	b7de8 <_Z16_fetch_usbserialv>
   b4a6e:	490e      	ldr	r1, [pc, #56]	; (b4aa8 <setup+0xb8>)
   b4a70:	f002 fd6e 	bl	b7550 <_ZN5Print5printEPKc>
  while (!nfc.begin()) {
   b4a74:	4628      	mov	r0, r5
   b4a76:	f001 fcef 	bl	b6458 <_ZN17DFRobot_PN532_IIC5beginEv>
   b4a7a:	b940      	cbnz	r0, b4a8e <setup+0x9e>
    Serial.print(".");
   b4a7c:	f003 f9b4 	bl	b7de8 <_Z16_fetch_usbserialv>
   b4a80:	4621      	mov	r1, r4
   b4a82:	f002 fd65 	bl	b7550 <_ZN5Print5printEPKc>
    delay (100);
   b4a86:	2064      	movs	r0, #100	; 0x64
   b4a88:	f001 ffd6 	bl	b6a38 <delay>
  while (!nfc.begin()) {
   b4a8c:	e7f2      	b.n	b4a74 <setup+0x84>
  // Serial.println("Waiting for a card......");    // DEBUG -- remove later
  // Initialise RFID --- END

//I2C_Scanner();                                  // RUN I2C DIAGNOSTICS

}
   b4a8e:	b007      	add	sp, #28
   b4a90:	bd30      	pop	{r4, r5, pc}
   b4a92:	bf00      	nop
   b4a94:	000b514d 	.word	0x000b514d
   b4a98:	000b85d0 	.word	0x000b85d0
   b4a9c:	2003e0e0 	.word	0x2003e0e0
   b4aa0:	2003e13c 	.word	0x2003e13c
   b4aa4:	000b8702 	.word	0x000b8702
   b4aa8:	000b85e7 	.word	0x000b85e7

000b4aac <_Z3EPDv>:

    Handler_STATE = 1;
    new_end_point_STATE = 2;
}

void EPD() {
   b4aac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   b4ab0:	f5ad 4d43 	sub.w	sp, sp, #49920	; 0xc300
   b4ab4:	b0aa      	sub	sp, #168	; 0xa8

  Epd epd;
   b4ab6:	a810      	add	r0, sp, #64	; 0x40
   b4ab8:	f000 fd76 	bl	b55a8 <_ZN3EpdC1Ev>
  Serial.print("Updating E-Paper Display\r\n ");
   b4abc:	f003 f994 	bl	b7de8 <_Z16_fetch_usbserialv>
   b4ac0:	490a      	ldr	r1, [pc, #40]	; (b4aec <_Z3EPDv+0x40>)
   b4ac2:	f002 fd45 	bl	b7550 <_ZN5Print5printEPKc>

 if (epd.Init() != 0) { 
   b4ac6:	a810      	add	r0, sp, #64	; 0x40
   b4ac8:	f000 fdbc 	bl	b5644 <_ZN3Epd4InitEv>
   b4acc:	4604      	mov	r4, r0
   b4ace:	b188      	cbz	r0, b4af4 <_Z3EPDv+0x48>
   Serial.print("Failed to initialize display");
   b4ad0:	f003 f98a 	bl	b7de8 <_Z16_fetch_usbserialv>
   b4ad4:	4906      	ldr	r1, [pc, #24]	; (b4af0 <_Z3EPDv+0x44>)
   b4ad6:	f002 fd3b 	bl	b7550 <_ZN5Print5printEPKc>
  Epd epd;
   b4ada:	a810      	add	r0, sp, #64	; 0x40
   b4adc:	f000 fd5e 	bl	b559c <_ZN3EpdD1Ev>
  new_end_point_STATE = 0;

  /* This displays an image */
  //epd.DisplayFrame(IMAGE_BLACK, IMAGE_RED);
  //epd.DisplayFrame(QR_BLACK, QR_RED);
}
   b4ae0:	f50d 4d43 	add.w	sp, sp, #49920	; 0xc300
   b4ae4:	b02a      	add	sp, #168	; 0xa8
   b4ae6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   b4aea:	bf00      	nop
   b4aec:	000b85fa 	.word	0x000b85fa
   b4af0:	000b8616 	.word	0x000b8616
  epd.ClearFrame();
   b4af4:	a810      	add	r0, sp, #64	; 0x40
   b4af6:	f000 fe92 	bl	b581e <_ZN3Epd10ClearFrameEv>
  Paint paint(image, 400, 296);    //width should be the multiple of 8
   b4afa:	f44f 7394 	mov.w	r3, #296	; 0x128
   b4afe:	f44f 72c8 	mov.w	r2, #400	; 0x190
   b4b02:	a916      	add	r1, sp, #88	; 0x58
   b4b04:	a804      	add	r0, sp, #16
   b4b06:	f000 ff88 	bl	b5a1a <_ZN5PaintC1EPhii>
  paint.Clear(UNCOLORED);
   b4b0a:	a804      	add	r0, sp, #16
   b4b0c:	2101      	movs	r1, #1
   b4b0e:	f000 ffb5 	bl	b5a7c <_ZN5Paint5ClearEi>
    paint.DrawStringAt(10, 5, "TITLE", &Font24, COLORED);
   b4b12:	f8df 836c 	ldr.w	r8, [pc, #876]	; b4e80 <_Z3EPDv+0x3d4>
    paint.DrawStringAt(10, 145, "Start ", &Font20, COLORED);
   b4b16:	4dc6      	ldr	r5, [pc, #792]	; (b4e30 <_Z3EPDv+0x384>)
  paint.SetRotate(2);
   b4b18:	a804      	add	r0, sp, #16
   b4b1a:	2102      	movs	r1, #2
   b4b1c:	f000 ffc9 	bl	b5ab2 <_ZN5Paint9SetRotateEi>
    paint.DrawStringAt(10, 5, "TITLE", &Font24, COLORED);
   b4b20:	a804      	add	r0, sp, #16
   b4b22:	4bc4      	ldr	r3, [pc, #784]	; (b4e34 <_Z3EPDv+0x388>)
   b4b24:	9401      	str	r4, [sp, #4]
   b4b26:	f8cd 8000 	str.w	r8, [sp]
   b4b2a:	2205      	movs	r2, #5
   b4b2c:	210a      	movs	r1, #10
   b4b2e:	f001 f83f 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(10, 145, "Start ", &Font20, COLORED);
   b4b32:	9500      	str	r5, [sp, #0]
   b4b34:	a804      	add	r0, sp, #16
   b4b36:	4bc0      	ldr	r3, [pc, #768]	; (b4e38 <_Z3EPDv+0x38c>)
   b4b38:	9401      	str	r4, [sp, #4]
   b4b3a:	2291      	movs	r2, #145	; 0x91
   b4b3c:	210a      	movs	r1, #10
   b4b3e:	f001 f837 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(10, 165, "Time", &Font20, COLORED);
   b4b42:	e9cd 5400 	strd	r5, r4, [sp]
   b4b46:	4bbd      	ldr	r3, [pc, #756]	; (b4e3c <_Z3EPDv+0x390>)
   b4b48:	22a5      	movs	r2, #165	; 0xa5
   b4b4a:	a804      	add	r0, sp, #16
   b4b4c:	210a      	movs	r1, #10
   b4b4e:	f001 f82f 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(115, 165, String(ApiData2.startTime), &Font20, COLORED);
   b4b52:	49bb      	ldr	r1, [pc, #748]	; (b4e40 <_Z3EPDv+0x394>)
   b4b54:	a80c      	add	r0, sp, #48	; 0x30
   b4b56:	f002 feb2 	bl	b78be <_ZN6StringC1ERKS_>
   b4b5a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b4b5c:	e9cd 5400 	strd	r5, r4, [sp]
   b4b60:	22a5      	movs	r2, #165	; 0xa5
   b4b62:	2173      	movs	r1, #115	; 0x73
   b4b64:	a804      	add	r0, sp, #16
   b4b66:	f001 f823 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
   b4b6a:	a80c      	add	r0, sp, #48	; 0x30
   b4b6c:	f002 fe10 	bl	b7790 <_ZN6StringD1Ev>
    paint.DrawStringAt(205, 145, "End   ", &Font20, COLORED);
   b4b70:	e9cd 5400 	strd	r5, r4, [sp]
   b4b74:	a804      	add	r0, sp, #16
   b4b76:	4bb3      	ldr	r3, [pc, #716]	; (b4e44 <_Z3EPDv+0x398>)
   b4b78:	2291      	movs	r2, #145	; 0x91
   b4b7a:	21cd      	movs	r1, #205	; 0xcd
   b4b7c:	f001 f818 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(205, 165, "Time", &Font20, COLORED);
   b4b80:	e9cd 5400 	strd	r5, r4, [sp]
   b4b84:	4bad      	ldr	r3, [pc, #692]	; (b4e3c <_Z3EPDv+0x390>)
   b4b86:	22a5      	movs	r2, #165	; 0xa5
   b4b88:	a804      	add	r0, sp, #16
   b4b8a:	21cd      	movs	r1, #205	; 0xcd
   b4b8c:	f001 f810 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(310, 165, String(ApiData2.endTime), &Font20, COLORED);
   b4b90:	49ad      	ldr	r1, [pc, #692]	; (b4e48 <_Z3EPDv+0x39c>)
   b4b92:	a80c      	add	r0, sp, #48	; 0x30
   b4b94:	f002 fe93 	bl	b78be <_ZN6StringC1ERKS_>
   b4b98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b4b9a:	e9cd 5400 	strd	r5, r4, [sp]
   b4b9e:	22a5      	movs	r2, #165	; 0xa5
   b4ba0:	f44f 719b 	mov.w	r1, #310	; 0x136
   b4ba4:	a804      	add	r0, sp, #16
   b4ba6:	f001 f803 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawFilledRectangle(10, 35, 100, 120, COLORED);
   b4baa:	2678      	movs	r6, #120	; 0x78
    paint.DrawStringAt(310, 165, String(ApiData2.endTime), &Font20, COLORED);
   b4bac:	a80c      	add	r0, sp, #48	; 0x30
   b4bae:	f002 fdef 	bl	b7790 <_ZN6StringD1Ev>
    paint.DrawFilledRectangle(10, 35, 100, 120, COLORED);
   b4bb2:	9600      	str	r6, [sp, #0]
   b4bb4:	a804      	add	r0, sp, #16
   b4bb6:	9401      	str	r4, [sp, #4]
   b4bb8:	2364      	movs	r3, #100	; 0x64
   b4bba:	2223      	movs	r2, #35	; 0x23
   b4bbc:	210a      	movs	r1, #10
   b4bbe:	f001 f86b 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(10, 27, 110, 27, COLORED);
   b4bc2:	221b      	movs	r2, #27
   b4bc4:	9200      	str	r2, [sp, #0]
   b4bc6:	a804      	add	r0, sp, #16
   b4bc8:	9401      	str	r4, [sp, #4]
   b4bca:	236e      	movs	r3, #110	; 0x6e
   b4bcc:	210a      	movs	r1, #10
   b4bce:	f001 f863 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(110, 27, 110, 120, COLORED);
   b4bd2:	236e      	movs	r3, #110	; 0x6e
   b4bd4:	e9cd 6400 	strd	r6, r4, [sp]
   b4bd8:	4619      	mov	r1, r3
   b4bda:	a804      	add	r0, sp, #16
   b4bdc:	221b      	movs	r2, #27
   b4bde:	f001 f85b 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(10, 140, 190, 140, COLORED);
   b4be2:	278c      	movs	r7, #140	; 0x8c
    paint.DrawFilledRectangle(110, 120, 395, 120, COLORED);
   b4be4:	e9cd 6400 	strd	r6, r4, [sp]
   b4be8:	4632      	mov	r2, r6
   b4bea:	a804      	add	r0, sp, #16
   b4bec:	f240 138b 	movw	r3, #395	; 0x18b
   b4bf0:	216e      	movs	r1, #110	; 0x6e
   b4bf2:	f001 f851 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(10, 185, 190, 185, COLORED);
   b4bf6:	26b9      	movs	r6, #185	; 0xb9
    paint.DrawFilledRectangle(10, 140, 190, 140, COLORED);
   b4bf8:	9700      	str	r7, [sp, #0]
   b4bfa:	463a      	mov	r2, r7
   b4bfc:	a804      	add	r0, sp, #16
   b4bfe:	9401      	str	r4, [sp, #4]
   b4c00:	23be      	movs	r3, #190	; 0xbe
   b4c02:	210a      	movs	r1, #10
   b4c04:	f001 f848 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(10, 185, 190, 185, COLORED);
   b4c08:	9600      	str	r6, [sp, #0]
   b4c0a:	4632      	mov	r2, r6
   b4c0c:	a804      	add	r0, sp, #16
   b4c0e:	9401      	str	r4, [sp, #4]
   b4c10:	23be      	movs	r3, #190	; 0xbe
   b4c12:	210a      	movs	r1, #10
   b4c14:	f001 f840 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(190, 140, 190, 185, COLORED);
   b4c18:	23be      	movs	r3, #190	; 0xbe
   b4c1a:	e9cd 6400 	strd	r6, r4, [sp]
   b4c1e:	463a      	mov	r2, r7
   b4c20:	4619      	mov	r1, r3
   b4c22:	a804      	add	r0, sp, #16
   b4c24:	f001 f838 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(200, 140, 200, 185, COLORED);
   b4c28:	23c8      	movs	r3, #200	; 0xc8
   b4c2a:	e9cd 6400 	strd	r6, r4, [sp]
   b4c2e:	463a      	mov	r2, r7
   b4c30:	4619      	mov	r1, r3
   b4c32:	a804      	add	r0, sp, #16
   b4c34:	f001 f830 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(200, 185, 390, 185, COLORED);
   b4c38:	e9cd 6400 	strd	r6, r4, [sp]
   b4c3c:	4632      	mov	r2, r6
   b4c3e:	a804      	add	r0, sp, #16
   b4c40:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4c44:	21c8      	movs	r1, #200	; 0xc8
   b4c46:	f001 f827 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(200, 140, 390, 140, COLORED);
   b4c4a:	e9cd 7400 	strd	r7, r4, [sp]
   b4c4e:	463a      	mov	r2, r7
   b4c50:	a804      	add	r0, sp, #16
   b4c52:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4c56:	21c8      	movs	r1, #200	; 0xc8
   b4c58:	f001 f81e 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawFilledRectangle(205, 185, 390, 185, COLORED);
   b4c5c:	e9cd 6400 	strd	r6, r4, [sp]
   b4c60:	4632      	mov	r2, r6
   b4c62:	a804      	add	r0, sp, #16
    paint.DrawRectangle(10, 230, 260, 290, COLORED);
   b4c64:	f44f 7691 	mov.w	r6, #290	; 0x122
    paint.DrawFilledRectangle(205, 185, 390, 185, COLORED);
   b4c68:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4c6c:	21cd      	movs	r1, #205	; 0xcd
   b4c6e:	f001 f813 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawRectangle(10, 230, 260, 290, COLORED);
   b4c72:	9600      	str	r6, [sp, #0]
   b4c74:	a804      	add	r0, sp, #16
   b4c76:	9401      	str	r4, [sp, #4]
   b4c78:	f44f 7382 	mov.w	r3, #260	; 0x104
   b4c7c:	22e6      	movs	r2, #230	; 0xe6
   b4c7e:	210a      	movs	r1, #10
   b4c80:	f000 ffce 	bl	b5c20 <_ZN5Paint13DrawRectangleEiiiii>
    paint.DrawRectangle(280, 200, 390, 290, COLORED);
   b4c84:	e9cd 6400 	strd	r6, r4, [sp]
   b4c88:	a804      	add	r0, sp, #16
   b4c8a:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4c8e:	22c8      	movs	r2, #200	; 0xc8
   b4c90:	f44f 718c 	mov.w	r1, #280	; 0x118
   b4c94:	f000 ffc4 	bl	b5c20 <_ZN5Paint13DrawRectangleEiiiii>
    paint.DrawFilledRectangle(280, 200, 390, 222, COLORED);                                   // battery background
   b4c98:	23de      	movs	r3, #222	; 0xde
    paint.DrawStringAt(285, 205, "BATTERY %", &Font16, UNCOLORED);                            // Battery Title
   b4c9a:	4f6c      	ldr	r7, [pc, #432]	; (b4e4c <_Z3EPDv+0x3a0>)
    paint.DrawFilledRectangle(280, 200, 390, 222, COLORED);                                   // battery background
   b4c9c:	9300      	str	r3, [sp, #0]
    paint.DrawStringAt(285, 205, "BATTERY %", &Font16, UNCOLORED);                            // Battery Title
   b4c9e:	2601      	movs	r6, #1
    paint.DrawFilledRectangle(280, 200, 390, 222, COLORED);                                   // battery background
   b4ca0:	a804      	add	r0, sp, #16
   b4ca2:	9401      	str	r4, [sp, #4]
   b4ca4:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4ca8:	22c8      	movs	r2, #200	; 0xc8
   b4caa:	f44f 718c 	mov.w	r1, #280	; 0x118
   b4cae:	f000 fff3 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawStringAt(285, 205, "BATTERY %", &Font16, UNCOLORED);                            // Battery Title
   b4cb2:	a804      	add	r0, sp, #16
   b4cb4:	4b66      	ldr	r3, [pc, #408]	; (b4e50 <_Z3EPDv+0x3a4>)
   b4cb6:	9601      	str	r6, [sp, #4]
   b4cb8:	9700      	str	r7, [sp, #0]
   b4cba:	22cd      	movs	r2, #205	; 0xcd
   b4cbc:	f240 111d 	movw	r1, #285	; 0x11d
   b4cc0:	f000 ff76 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(320, 227, String(SOC) + "%", &Font16, COLORED);                        // SOC
   b4cc4:	ab08      	add	r3, sp, #32
   b4cc6:	9303      	str	r3, [sp, #12]
   b4cc8:	4b62      	ldr	r3, [pc, #392]	; (b4e54 <_Z3EPDv+0x3a8>)
   b4cca:	9803      	ldr	r0, [sp, #12]
   b4ccc:	6819      	ldr	r1, [r3, #0]
   b4cce:	220a      	movs	r2, #10
   b4cd0:	f002 fe24 	bl	b791c <_ZN6StringC1Eih>
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
   b4cd4:	9903      	ldr	r1, [sp, #12]
   b4cd6:	a80c      	add	r0, sp, #48	; 0x30
   b4cd8:	f002 fdf1 	bl	b78be <_ZN6StringC1ERKS_>
   b4cdc:	495e      	ldr	r1, [pc, #376]	; (b4e58 <_Z3EPDv+0x3ac>)
   b4cde:	a80c      	add	r0, sp, #48	; 0x30
   b4ce0:	f002 fe67 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4ce4:	e9cd 7400 	strd	r7, r4, [sp]
   b4ce8:	22e3      	movs	r2, #227	; 0xe3
   b4cea:	6803      	ldr	r3, [r0, #0]
   b4cec:	f44f 71a0 	mov.w	r1, #320	; 0x140
   b4cf0:	a804      	add	r0, sp, #16
   b4cf2:	f000 ff5d 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
class StringSumHelper : public String
   b4cf6:	a80c      	add	r0, sp, #48	; 0x30
   b4cf8:	f002 fd4a 	bl	b7790 <_ZN6StringD1Ev>
   b4cfc:	9803      	ldr	r0, [sp, #12]
   b4cfe:	f002 fd47 	bl	b7790 <_ZN6StringD1Ev>
    paint.DrawFilledRectangle(280, 244, 390, 266, COLORED);                                   // Time Zone background
   b4d02:	f44f 7385 	mov.w	r3, #266	; 0x10a
   b4d06:	9300      	str	r3, [sp, #0]
   b4d08:	a804      	add	r0, sp, #16
   b4d0a:	9401      	str	r4, [sp, #4]
   b4d0c:	f44f 73c3 	mov.w	r3, #390	; 0x186
   b4d10:	22f4      	movs	r2, #244	; 0xf4
   b4d12:	f44f 718c 	mov.w	r1, #280	; 0x118
   b4d16:	f000 ffbf 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawStringAt(285, 249, "Time Zone", &Font16, UNCOLORED);                            // Time Zone background
   b4d1a:	4b50      	ldr	r3, [pc, #320]	; (b4e5c <_Z3EPDv+0x3b0>)
   b4d1c:	22f9      	movs	r2, #249	; 0xf9
   b4d1e:	a804      	add	r0, sp, #16
   b4d20:	e9cd 7600 	strd	r7, r6, [sp]
   b4d24:	f240 111d 	movw	r1, #285	; 0x11d
   b4d28:	f000 ff42 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(305, 271, String(ApiData1.timezone), &Font16, COLORED);                // GMT
   b4d2c:	494c      	ldr	r1, [pc, #304]	; (b4e60 <_Z3EPDv+0x3b4>)
   b4d2e:	a80c      	add	r0, sp, #48	; 0x30
   b4d30:	f002 fdc5 	bl	b78be <_ZN6StringC1ERKS_>
   b4d34:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b4d36:	f240 120f 	movw	r2, #271	; 0x10f
   b4d3a:	f240 1131 	movw	r1, #305	; 0x131
   b4d3e:	a804      	add	r0, sp, #16
   b4d40:	e9cd 7400 	strd	r7, r4, [sp]
   b4d44:	f000 ff34 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
   b4d48:	a80c      	add	r0, sp, #48	; 0x30
   b4d4a:	f002 fd21 	bl	b7790 <_ZN6StringD1Ev>
    paint.DrawFilledRectangle(10, 230, 260, 200, COLORED);                                    // instructor background
   b4d4e:	23c8      	movs	r3, #200	; 0xc8
   b4d50:	9300      	str	r3, [sp, #0]
   b4d52:	a804      	add	r0, sp, #16
   b4d54:	9401      	str	r4, [sp, #4]
   b4d56:	f44f 7382 	mov.w	r3, #260	; 0x104
   b4d5a:	22e6      	movs	r2, #230	; 0xe6
   b4d5c:	210a      	movs	r1, #10
   b4d5e:	f000 ff9b 	bl	b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>
    paint.DrawStringAt(15, 210, "INSTRUCTOR:", &Font20, UNCOLORED);                           // instructor Title
   b4d62:	e9cd 5600 	strd	r5, r6, [sp]
   b4d66:	4b3f      	ldr	r3, [pc, #252]	; (b4e64 <_Z3EPDv+0x3b8>)
   b4d68:	22d2      	movs	r2, #210	; 0xd2
   b4d6a:	a804      	add	r0, sp, #16
   b4d6c:	210f      	movs	r1, #15
   b4d6e:	f000 ff1f 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(15, 240, String(ApiData1.instructorFirstName), &Font20, COLORED);      // instructor Title
   b4d72:	493d      	ldr	r1, [pc, #244]	; (b4e68 <_Z3EPDv+0x3bc>)
   b4d74:	a80c      	add	r0, sp, #48	; 0x30
   b4d76:	f002 fda2 	bl	b78be <_ZN6StringC1ERKS_>
   b4d7a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b4d7c:	22f0      	movs	r2, #240	; 0xf0
   b4d7e:	e9cd 5400 	strd	r5, r4, [sp]
   b4d82:	210f      	movs	r1, #15
   b4d84:	a804      	add	r0, sp, #16
   b4d86:	f000 ff13 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
   b4d8a:	a80c      	add	r0, sp, #48	; 0x30
   b4d8c:	f002 fd00 	bl	b7790 <_ZN6StringD1Ev>
    paint.DrawStringAt(15, 260, String(ApiData1.instructorLastName), &Font20, COLORED);       // instructor Title
   b4d90:	4936      	ldr	r1, [pc, #216]	; (b4e6c <_Z3EPDv+0x3c0>)
   b4d92:	a80c      	add	r0, sp, #48	; 0x30
   b4d94:	f002 fd93 	bl	b78be <_ZN6StringC1ERKS_>
   b4d98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b4d9a:	f44f 7282 	mov.w	r2, #260	; 0x104
   b4d9e:	210f      	movs	r1, #15
   b4da0:	e9cd 5400 	strd	r5, r4, [sp]
   b4da4:	a804      	add	r0, sp, #16
   b4da6:	f000 ff03 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
   b4daa:	a80c      	add	r0, sp, #48	; 0x30
   b4dac:	f002 fcf0 	bl	b7790 <_ZN6StringD1Ev>
     epd.SetPartialWindowBlack(paint.GetImage(), 0, 0, paint.GetWidth(), paint.GetHeight());
   b4db0:	a804      	add	r0, sp, #16
   b4db2:	f000 fe78 	bl	b5aa6 <_ZN5Paint8GetImageEv>
   b4db6:	9003      	str	r0, [sp, #12]
   b4db8:	a804      	add	r0, sp, #16
   b4dba:	f000 fe76 	bl	b5aaa <_ZN5Paint8GetWidthEv>
   b4dbe:	4605      	mov	r5, r0
   b4dc0:	a804      	add	r0, sp, #16
   b4dc2:	f000 fe74 	bl	b5aae <_ZN5Paint9GetHeightEv>
   b4dc6:	4623      	mov	r3, r4
   b4dc8:	4622      	mov	r2, r4
   b4dca:	e9cd 5000 	strd	r5, r0, [sp]
   b4dce:	9903      	ldr	r1, [sp, #12]
   b4dd0:	a810      	add	r0, sp, #64	; 0x40
   b4dd2:	f000 fc54 	bl	b567e <_ZN3Epd21SetPartialWindowBlackEPKhiiii>
  paint.Clear(UNCOLORED);
   b4dd6:	4631      	mov	r1, r6
   b4dd8:	a804      	add	r0, sp, #16
   b4dda:	f000 fe4f 	bl	b5a7c <_ZN5Paint5ClearEi>
  paint.SetRotate(2);
   b4dde:	a804      	add	r0, sp, #16
   b4de0:	2102      	movs	r1, #2
   b4de2:	f000 fe66 	bl	b5ab2 <_ZN5Paint9SetRotateEi>
    paint.DrawStringAt(130, 5, "Starship IFT3 - ", &Font24, COLORED);
   b4de6:	a804      	add	r0, sp, #16
   b4de8:	e9cd 8400 	strd	r8, r4, [sp]
   b4dec:	4b20      	ldr	r3, [pc, #128]	; (b4e70 <_Z3EPDv+0x3c4>)
   b4dee:	2205      	movs	r2, #5
   b4df0:	2182      	movs	r1, #130	; 0x82
   b4df2:	f000 fedd 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(130, 35, "What to expect ", &Font24, COLORED);
   b4df6:	a804      	add	r0, sp, #16
   b4df8:	e9cd 8400 	strd	r8, r4, [sp]
   b4dfc:	4b1d      	ldr	r3, [pc, #116]	; (b4e74 <_Z3EPDv+0x3c8>)
   b4dfe:	2223      	movs	r2, #35	; 0x23
   b4e00:	2182      	movs	r1, #130	; 0x82
   b4e02:	f000 fed5 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(130, 65, "from the next ", &Font24, COLORED);
   b4e06:	a804      	add	r0, sp, #16
   b4e08:	e9cd 8400 	strd	r8, r4, [sp]
   b4e0c:	4b1a      	ldr	r3, [pc, #104]	; (b4e78 <_Z3EPDv+0x3cc>)
   b4e0e:	2241      	movs	r2, #65	; 0x41
   b4e10:	2182      	movs	r1, #130	; 0x82
   b4e12:	f000 fecd 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    paint.DrawStringAt(130, 95, "flight test", &Font24, COLORED);
   b4e16:	4b19      	ldr	r3, [pc, #100]	; (b4e7c <_Z3EPDv+0x3d0>)
   b4e18:	225f      	movs	r2, #95	; 0x5f
   b4e1a:	2182      	movs	r1, #130	; 0x82
   b4e1c:	a804      	add	r0, sp, #16
   b4e1e:	e9cd 8400 	strd	r8, r4, [sp]
   b4e22:	f000 fec5 	bl	b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>
    epd.SetPartialWindowRed(paint.GetImage(), 0, 0, paint.GetWidth(), paint.GetHeight());
   b4e26:	a804      	add	r0, sp, #16
   b4e28:	f000 fe3d 	bl	b5aa6 <_ZN5Paint8GetImageEv>
   b4e2c:	9003      	str	r0, [sp, #12]
   b4e2e:	e029      	b.n	b4e84 <_Z3EPDv+0x3d8>
   b4e30:	2003ddfc 	.word	0x2003ddfc
   b4e34:	000b8633 	.word	0x000b8633
   b4e38:	000b8639 	.word	0x000b8639
   b4e3c:	000b8640 	.word	0x000b8640
   b4e40:	2003df88 	.word	0x2003df88
   b4e44:	000b8645 	.word	0x000b8645
   b4e48:	2003df98 	.word	0x2003df98
   b4e4c:	2003ddf4 	.word	0x2003ddf4
   b4e50:	000b864c 	.word	0x000b864c
   b4e54:	2003e02c 	.word	0x2003e02c
   b4e58:	000b8654 	.word	0x000b8654
   b4e5c:	000b8656 	.word	0x000b8656
   b4e60:	2003dee8 	.word	0x2003dee8
   b4e64:	000b8660 	.word	0x000b8660
   b4e68:	2003df08 	.word	0x2003df08
   b4e6c:	2003df18 	.word	0x2003df18
   b4e70:	000b866c 	.word	0x000b866c
   b4e74:	000b867d 	.word	0x000b867d
   b4e78:	000b868d 	.word	0x000b868d
   b4e7c:	000b869c 	.word	0x000b869c
   b4e80:	2003de04 	.word	0x2003de04
   b4e84:	a804      	add	r0, sp, #16
   b4e86:	f000 fe10 	bl	b5aaa <_ZN5Paint8GetWidthEv>
   b4e8a:	4605      	mov	r5, r0
   b4e8c:	a804      	add	r0, sp, #16
   b4e8e:	f000 fe0e 	bl	b5aae <_ZN5Paint9GetHeightEv>
   b4e92:	4623      	mov	r3, r4
   b4e94:	9903      	ldr	r1, [sp, #12]
   b4e96:	4622      	mov	r2, r4
   b4e98:	e9cd 5000 	strd	r5, r0, [sp]
   b4e9c:	a810      	add	r0, sp, #64	; 0x40
   b4e9e:	f000 fc56 	bl	b574e <_ZN3Epd19SetPartialWindowRedEPKhiiii>
  epd.DisplayFrame();         // /* This displays the data from the SRAM in e-Paper module */
   b4ea2:	a810      	add	r0, sp, #64	; 0x40
   b4ea4:	f000 fcec 	bl	b5880 <_ZN3Epd12DisplayFrameEv>
  delay(50);
   b4ea8:	2032      	movs	r0, #50	; 0x32
   b4eaa:	f001 fdc5 	bl	b6a38 <delay>
  epd.Sleep();                /* Deep sleep */
   b4eae:	a810      	add	r0, sp, #64	; 0x40
   b4eb0:	f000 fcf3 	bl	b589a <_ZN3Epd5SleepEv>
  new_end_point_STATE = 0;
   b4eb4:	4b02      	ldr	r3, [pc, #8]	; (b4ec0 <_Z3EPDv+0x414>)
  Paint paint(image, 400, 296);    //width should be the multiple of 8
   b4eb6:	a804      	add	r0, sp, #16
  new_end_point_STATE = 0;
   b4eb8:	601c      	str	r4, [r3, #0]
  Paint paint(image, 400, 296);    //width should be the multiple of 8
   b4eba:	f000 fdc1 	bl	b5a40 <_ZN5PaintD1Ev>
   b4ebe:	e60c      	b.n	b4ada <_Z3EPDv+0x2e>
   b4ec0:	2003e138 	.word	0x2003e138

000b4ec4 <_Z8RealTimev>:
//         Serial.println(" PM");
//         Serial.println("\n");
//         Serial.println("\n");
}

void RealTime(void){
   b4ec4:	b500      	push	{lr}
	const char * c_str() const { return buffer; }
   b4ec6:	4b57      	ldr	r3, [pc, #348]	; (b5024 <_Z8RealTimev+0x160>)
   b4ec8:	b09d      	sub	sp, #116	; 0x74

  Time.zone(atoi(ApiData1.timeZoneOffset));
   b4eca:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
   b4ece:	f003 f9a4 	bl	b821a <atoi>
   b4ed2:	ee07 0a90 	vmov	s15, r0
   b4ed6:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   b4eda:	f002 fe55 	bl	b7b88 <_ZN9TimeClass4zoneEf>
   b4ede:	4b52      	ldr	r3, [pc, #328]	; (b5028 <_Z8RealTimev+0x164>)
  Time.zone(atoi(ApiData2.timeZoneOffset));
   b4ee0:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
   b4ee4:	f003 f999 	bl	b821a <atoi>
   b4ee8:	ee07 0a90 	vmov	s15, r0
   b4eec:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   b4ef0:	f002 fe4a 	bl	b7b88 <_ZN9TimeClass4zoneEf>

  String hour = String(Time.hourFormat12(Time.now()));
   b4ef4:	f002 fe85 	bl	b7c02 <_ZN9TimeClass3nowEv>
   b4ef8:	17c1      	asrs	r1, r0, #31
   b4efa:	f002 fe11 	bl	b7b20 <_ZN9TimeClass12hourFormat12Ex>
   b4efe:	220a      	movs	r2, #10
   b4f00:	4601      	mov	r1, r0
   b4f02:	4668      	mov	r0, sp
   b4f04:	f002 fd0a 	bl	b791c <_ZN6StringC1Eih>
  String minute = String::format("%02i",Time.minute(Time.now()));
   b4f08:	f002 fe7b 	bl	b7c02 <_ZN9TimeClass3nowEv>
   b4f0c:	17c1      	asrs	r1, r0, #31
   b4f0e:	f002 fe21 	bl	b7b54 <_ZN9TimeClass6minuteEx>
   b4f12:	4946      	ldr	r1, [pc, #280]	; (b502c <_Z8RealTimev+0x168>)
   b4f14:	4602      	mov	r2, r0
   b4f16:	a804      	add	r0, sp, #16
   b4f18:	f002 fd72 	bl	b7a00 <_ZN6String6formatEPKcz>
  String second = String::format("%02i",Time.second(Time.now()));
   b4f1c:	f002 fe71 	bl	b7c02 <_ZN9TimeClass3nowEv>
   b4f20:	17c1      	asrs	r1, r0, #31
   b4f22:	f002 fe1f 	bl	b7b64 <_ZN9TimeClass6secondEx>
   b4f26:	4941      	ldr	r1, [pc, #260]	; (b502c <_Z8RealTimev+0x168>)
   b4f28:	4602      	mov	r2, r0
   b4f2a:	a808      	add	r0, sp, #32
   b4f2c:	f002 fd68 	bl	b7a00 <_ZN6String6formatEPKcz>
   
  String day = String(Time.day());
   b4f30:	f002 fe80 	bl	b7c34 <_ZN9TimeClass3dayEv>
   b4f34:	220a      	movs	r2, #10
   b4f36:	4601      	mov	r1, r0
   b4f38:	a80c      	add	r0, sp, #48	; 0x30
   b4f3a:	f002 fcef 	bl	b791c <_ZN6StringC1Eih>
  String month = String(Time.month());
   b4f3e:	f002 fe85 	bl	b7c4c <_ZN9TimeClass5monthEv>
   b4f42:	220a      	movs	r2, #10
   b4f44:	4601      	mov	r1, r0
   b4f46:	a810      	add	r0, sp, #64	; 0x40
   b4f48:	f002 fce8 	bl	b791c <_ZN6StringC1Eih>
  String year = String(Time.year());
   b4f4c:	f002 fe86 	bl	b7c5c <_ZN9TimeClass4yearEv>
   b4f50:	220a      	movs	r2, #10
   b4f52:	4601      	mov	r1, r0
   b4f54:	a814      	add	r0, sp, #80	; 0x50
   b4f56:	f002 fce1 	bl	b791c <_ZN6StringC1Eih>

    if(!Time.isPM()){
   b4f5a:	f002 fe62 	bl	b7c22 <_ZN9TimeClass4isPMEv>
	StringSumHelper(const String &s) : String(s) {}
   b4f5e:	4669      	mov	r1, sp
   b4f60:	2800      	cmp	r0, #0
   b4f62:	d14c      	bne.n	b4ffe <_Z8RealTimev+0x13a>
   b4f64:	a818      	add	r0, sp, #96	; 0x60
   b4f66:	f002 fcaa 	bl	b78be <_ZN6StringC1ERKS_>
        hhmmss = hour + ":" + minute + ":" + second +"AM";
   b4f6a:	4931      	ldr	r1, [pc, #196]	; (b5030 <_Z8RealTimev+0x16c>)
   b4f6c:	a818      	add	r0, sp, #96	; 0x60
   b4f6e:	f002 fd20 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4f72:	a904      	add	r1, sp, #16
   b4f74:	f002 fd11 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b4f78:	492d      	ldr	r1, [pc, #180]	; (b5030 <_Z8RealTimev+0x16c>)
   b4f7a:	f002 fd1a 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4f7e:	a908      	add	r1, sp, #32
   b4f80:	f002 fd0b 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b4f84:	492b      	ldr	r1, [pc, #172]	; (b5034 <_Z8RealTimev+0x170>)
          } else {
            hhmmss = hour + ":" + minute + ":" + second +"PM";
   b4f86:	f002 fd14 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4f8a:	4601      	mov	r1, r0
   b4f8c:	482a      	ldr	r0, [pc, #168]	; (b5038 <_Z8RealTimev+0x174>)
   b4f8e:	f002 fc87 	bl	b78a0 <_ZN6StringaSERKS_>
class StringSumHelper : public String
   b4f92:	a818      	add	r0, sp, #96	; 0x60
   b4f94:	f002 fbfc 	bl	b7790 <_ZN6StringD1Ev>
	StringSumHelper(const String &s) : String(s) {}
   b4f98:	a914      	add	r1, sp, #80	; 0x50
   b4f9a:	a818      	add	r0, sp, #96	; 0x60
   b4f9c:	f002 fc8f 	bl	b78be <_ZN6StringC1ERKS_>
          }
            data_time = year + "-" + month + "-" + day + "T" + hhmmss;
   b4fa0:	4926      	ldr	r1, [pc, #152]	; (b503c <_Z8RealTimev+0x178>)
   b4fa2:	a818      	add	r0, sp, #96	; 0x60
   b4fa4:	f002 fd05 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4fa8:	a910      	add	r1, sp, #64	; 0x40
   b4faa:	f002 fcf6 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b4fae:	4923      	ldr	r1, [pc, #140]	; (b503c <_Z8RealTimev+0x178>)
   b4fb0:	f002 fcff 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4fb4:	a90c      	add	r1, sp, #48	; 0x30
   b4fb6:	f002 fcf0 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b4fba:	4921      	ldr	r1, [pc, #132]	; (b5040 <_Z8RealTimev+0x17c>)
   b4fbc:	f002 fcf9 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b4fc0:	491d      	ldr	r1, [pc, #116]	; (b5038 <_Z8RealTimev+0x174>)
   b4fc2:	f002 fcea 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b4fc6:	4601      	mov	r1, r0
   b4fc8:	481e      	ldr	r0, [pc, #120]	; (b5044 <_Z8RealTimev+0x180>)
   b4fca:	f002 fc69 	bl	b78a0 <_ZN6StringaSERKS_>
class StringSumHelper : public String
   b4fce:	a818      	add	r0, sp, #96	; 0x60
   b4fd0:	f002 fbde 	bl	b7790 <_ZN6StringD1Ev>
  String year = String(Time.year());
   b4fd4:	a814      	add	r0, sp, #80	; 0x50
   b4fd6:	f002 fbdb 	bl	b7790 <_ZN6StringD1Ev>
  String month = String(Time.month());
   b4fda:	a810      	add	r0, sp, #64	; 0x40
   b4fdc:	f002 fbd8 	bl	b7790 <_ZN6StringD1Ev>
  String day = String(Time.day());
   b4fe0:	a80c      	add	r0, sp, #48	; 0x30
   b4fe2:	f002 fbd5 	bl	b7790 <_ZN6StringD1Ev>
  String second = String::format("%02i",Time.second(Time.now()));
   b4fe6:	a808      	add	r0, sp, #32
   b4fe8:	f002 fbd2 	bl	b7790 <_ZN6StringD1Ev>
  String minute = String::format("%02i",Time.minute(Time.now()));
   b4fec:	a804      	add	r0, sp, #16
   b4fee:	f002 fbcf 	bl	b7790 <_ZN6StringD1Ev>
  String hour = String(Time.hourFormat12(Time.now()));
   b4ff2:	4668      	mov	r0, sp
   b4ff4:	f002 fbcc 	bl	b7790 <_ZN6StringD1Ev>
 }
   b4ff8:	b01d      	add	sp, #116	; 0x74
   b4ffa:	f85d fb04 	ldr.w	pc, [sp], #4
	StringSumHelper(const String &s) : String(s) {}
   b4ffe:	a818      	add	r0, sp, #96	; 0x60
   b5000:	f002 fc5d 	bl	b78be <_ZN6StringC1ERKS_>
            hhmmss = hour + ":" + minute + ":" + second +"PM";
   b5004:	490a      	ldr	r1, [pc, #40]	; (b5030 <_Z8RealTimev+0x16c>)
   b5006:	a818      	add	r0, sp, #96	; 0x60
   b5008:	f002 fcd3 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b500c:	a904      	add	r1, sp, #16
   b500e:	f002 fcc4 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b5012:	4907      	ldr	r1, [pc, #28]	; (b5030 <_Z8RealTimev+0x16c>)
   b5014:	f002 fccd 	bl	b79b2 <_ZplRK15StringSumHelperPKc>
   b5018:	a908      	add	r1, sp, #32
   b501a:	f002 fcbe 	bl	b799a <_ZplRK15StringSumHelperRK6String>
   b501e:	490a      	ldr	r1, [pc, #40]	; (b5048 <_Z8RealTimev+0x184>)
   b5020:	e7b1      	b.n	b4f86 <_Z8RealTimev+0xc2>
   b5022:	bf00      	nop
   b5024:	2003de78 	.word	0x2003de78
   b5028:	2003df38 	.word	0x2003df38
   b502c:	000b86a8 	.word	0x000b86a8
   b5030:	000b866a 	.word	0x000b866a
   b5034:	000b86ad 	.word	0x000b86ad
   b5038:	2003e0e8 	.word	0x2003e0e8
   b503c:	000b86b3 	.word	0x000b86b3
   b5040:	000b86b5 	.word	0x000b86b5
   b5044:	2003e0d0 	.word	0x2003e0d0
   b5048:	000b86b0 	.word	0x000b86b0

000b504c <_Z16ApiParser_event1v>:

void ApiParser_event1(void){                  //store all sperate data from API into the struct variable
   b504c:	b538      	push	{r3, r4, r5, lr}

//ApiData.id = array[0];
  ApiData1.readerMode = array[1];
   b504e:	4d1d      	ldr	r5, [pc, #116]	; (b50c4 <_Z16ApiParser_event1v+0x78>)
   b5050:	4c1d      	ldr	r4, [pc, #116]	; (b50c8 <_Z16ApiParser_event1v+0x7c>)
   b5052:	6869      	ldr	r1, [r5, #4]
   b5054:	f104 0020 	add.w	r0, r4, #32
   b5058:	f002 fc3c 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.roomName = array[2];
   b505c:	68a9      	ldr	r1, [r5, #8]
   b505e:	f104 0030 	add.w	r0, r4, #48	; 0x30
   b5062:	f002 fc37 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.id = array[3];
   b5066:	68e9      	ldr	r1, [r5, #12]
   b5068:	4620      	mov	r0, r4
   b506a:	f002 fc33 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.title = array[4];
   b506e:	6929      	ldr	r1, [r5, #16]
   b5070:	f104 0040 	add.w	r0, r4, #64	; 0x40
   b5074:	f002 fc2e 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.startTime = array[5];
   b5078:	6969      	ldr	r1, [r5, #20]
   b507a:	f104 0050 	add.w	r0, r4, #80	; 0x50
   b507e:	f002 fc29 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.endTime = array[6];
   b5082:	69a9      	ldr	r1, [r5, #24]
   b5084:	f104 0060 	add.w	r0, r4, #96	; 0x60
   b5088:	f002 fc24 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.timezone = array[7];
   b508c:	69e9      	ldr	r1, [r5, #28]
   b508e:	f104 0070 	add.w	r0, r4, #112	; 0x70
   b5092:	f002 fc1f 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.timeZoneOffset = array[8];
   b5096:	6a29      	ldr	r1, [r5, #32]
   b5098:	f104 0080 	add.w	r0, r4, #128	; 0x80
   b509c:	f002 fc1a 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.instructorFirstName = array[9];
   b50a0:	6a69      	ldr	r1, [r5, #36]	; 0x24
   b50a2:	f104 0090 	add.w	r0, r4, #144	; 0x90
   b50a6:	f002 fc15 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.instructorLastName = array[10];
   b50aa:	6aa9      	ldr	r1, [r5, #40]	; 0x28
   b50ac:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   b50b0:	f002 fc10 	bl	b78d4 <_ZN6StringaSEPKc>
  ApiData1.isHybrid = array[11];
   b50b4:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   b50b6:	f104 00b0 	add.w	r0, r4, #176	; 0xb0

}
   b50ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ApiData1.isHybrid = array[11];
   b50be:	f002 bc09 	b.w	b78d4 <_ZN6StringaSEPKc>
   b50c2:	bf00      	nop
   b50c4:	2003e054 	.word	0x2003e054
   b50c8:	2003de78 	.word	0x2003de78

000b50cc <_Z16ApiParser_event2v>:

void ApiParser_event2(void){                  //store all sperate data from API into the struct variable
   b50cc:	b538      	push	{r3, r4, r5, lr}

    //ApiData.id = array[0];
    ApiData2.readerMode = array[10];
   b50ce:	4d1d      	ldr	r5, [pc, #116]	; (b5144 <_Z16ApiParser_event2v+0x78>)
   b50d0:	4c1d      	ldr	r4, [pc, #116]	; (b5148 <_Z16ApiParser_event2v+0x7c>)
   b50d2:	6aa9      	ldr	r1, [r5, #40]	; 0x28
   b50d4:	f104 0020 	add.w	r0, r4, #32
   b50d8:	f002 fbfc 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.roomName = array[2];
   b50dc:	68a9      	ldr	r1, [r5, #8]
   b50de:	f104 0030 	add.w	r0, r4, #48	; 0x30
   b50e2:	f002 fbf7 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.id = array[12];
   b50e6:	6b29      	ldr	r1, [r5, #48]	; 0x30
   b50e8:	4620      	mov	r0, r4
   b50ea:	f002 fbf3 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.title = array[13];
   b50ee:	6b69      	ldr	r1, [r5, #52]	; 0x34
   b50f0:	f104 0040 	add.w	r0, r4, #64	; 0x40
   b50f4:	f002 fbee 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.startTime = array[14];
   b50f8:	6ba9      	ldr	r1, [r5, #56]	; 0x38
   b50fa:	f104 0050 	add.w	r0, r4, #80	; 0x50
   b50fe:	f002 fbe9 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.endTime = array[15];
   b5102:	6be9      	ldr	r1, [r5, #60]	; 0x3c
   b5104:	f104 0060 	add.w	r0, r4, #96	; 0x60
   b5108:	f002 fbe4 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.timezone = array[16];
   b510c:	6c29      	ldr	r1, [r5, #64]	; 0x40
   b510e:	f104 0070 	add.w	r0, r4, #112	; 0x70
   b5112:	f002 fbdf 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.timeZoneOffset = array[17];
   b5116:	6c69      	ldr	r1, [r5, #68]	; 0x44
   b5118:	f104 0080 	add.w	r0, r4, #128	; 0x80
   b511c:	f002 fbda 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.instructorFirstName = array[18];
   b5120:	6ca9      	ldr	r1, [r5, #72]	; 0x48
   b5122:	f104 0090 	add.w	r0, r4, #144	; 0x90
   b5126:	f002 fbd5 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.instructorLastName = array[19];
   b512a:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
   b512c:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   b5130:	f002 fbd0 	bl	b78d4 <_ZN6StringaSEPKc>
    ApiData2.isHybrid = array[20];
   b5134:	6d29      	ldr	r1, [r5, #80]	; 0x50
   b5136:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
    
}
   b513a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ApiData2.isHybrid = array[20];
   b513e:	f002 bbc9 	b.w	b78d4 <_ZN6StringaSEPKc>
   b5142:	bf00      	nop
   b5144:	2003e054 	.word	0x2003e054
   b5148:	2003df38 	.word	0x2003df38

000b514c <_Z9myHandlerPKcS0_>:
void myHandler(const char *event, const char *data) {
   b514c:	b538      	push	{r3, r4, r5, lr}
    strcpy(testval, (const char *)data);
   b514e:	4815      	ldr	r0, [pc, #84]	; (b51a4 <_Z9myHandlerPKcS0_+0x58>)
   b5150:	4c15      	ldr	r4, [pc, #84]	; (b51a8 <_Z9myHandlerPKcS0_+0x5c>)
            p = strtok (NULL, "|");
   b5152:	4d16      	ldr	r5, [pc, #88]	; (b51ac <_Z9myHandlerPKcS0_+0x60>)
    strcpy(testval, (const char *)data);
   b5154:	f003 f8aa 	bl	b82ac <strcpy>
    char *p = strtok (( char *)testval, "|");
   b5158:	4914      	ldr	r1, [pc, #80]	; (b51ac <_Z9myHandlerPKcS0_+0x60>)
   b515a:	4812      	ldr	r0, [pc, #72]	; (b51a4 <_Z9myHandlerPKcS0_+0x58>)
   b515c:	f003 f8e0 	bl	b8320 <strtok>
    while (p != NULL)
   b5160:	b130      	cbz	r0, b5170 <_Z9myHandlerPKcS0_+0x24>
            array[i++] = p;
   b5162:	f844 0b04 	str.w	r0, [r4], #4
            p = strtok (NULL, "|");
   b5166:	4629      	mov	r1, r5
   b5168:	2000      	movs	r0, #0
   b516a:	f003 f8d9 	bl	b8320 <strtok>
    while (p != NULL)
   b516e:	e7f7      	b.n	b5160 <_Z9myHandlerPKcS0_+0x14>
    ApiParser_event1();
   b5170:	f7ff ff6c 	bl	b504c <_Z16ApiParser_event1v>
    Serial.print("\n"); 
   b5174:	f002 fe38 	bl	b7de8 <_Z16_fetch_usbserialv>
   b5178:	490d      	ldr	r1, [pc, #52]	; (b51b0 <_Z9myHandlerPKcS0_+0x64>)
   b517a:	f002 f9e9 	bl	b7550 <_ZN5Print5printEPKc>
    Serial.print("\n"); 
   b517e:	f002 fe33 	bl	b7de8 <_Z16_fetch_usbserialv>
   b5182:	490b      	ldr	r1, [pc, #44]	; (b51b0 <_Z9myHandlerPKcS0_+0x64>)
   b5184:	f002 f9e4 	bl	b7550 <_ZN5Print5printEPKc>
    ApiParser_event2();
   b5188:	f7ff ffa0 	bl	b50cc <_Z16ApiParser_event2v>
    RealTime();
   b518c:	f7ff fe9a 	bl	b4ec4 <_Z8RealTimev>
    delay(50);
   b5190:	2032      	movs	r0, #50	; 0x32
   b5192:	f001 fc51 	bl	b6a38 <delay>
    Handler_STATE = 1;
   b5196:	4b07      	ldr	r3, [pc, #28]	; (b51b4 <_Z9myHandlerPKcS0_+0x68>)
   b5198:	2201      	movs	r2, #1
   b519a:	601a      	str	r2, [r3, #0]
    new_end_point_STATE = 2;
   b519c:	4b06      	ldr	r3, [pc, #24]	; (b51b8 <_Z9myHandlerPKcS0_+0x6c>)
   b519e:	2202      	movs	r2, #2
   b51a0:	601a      	str	r2, [r3, #0]
}
   b51a2:	bd38      	pop	{r3, r4, r5, pc}
   b51a4:	2003e1a0 	.word	0x2003e1a0
   b51a8:	2003e054 	.word	0x2003e054
   b51ac:	000b86b7 	.word	0x000b86b7
   b51b0:	000b8733 	.word	0x000b8733
   b51b4:	2003e008 	.word	0x2003e008
   b51b8:	2003e138 	.word	0x2003e138

000b51bc <_Z4RFIDv>:

void RFID () {
   b51bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

if (nfc.scan()) {
   b51be:	481d      	ldr	r0, [pc, #116]	; (b5234 <_Z4RFIDv+0x78>)
   b51c0:	f000 ff7f 	bl	b60c2 <_ZN13DFRobot_PN5324scanEv>
   b51c4:	b3a0      	cbz	r0, b5230 <_Z4RFIDv+0x74>
    if (nfc.readData(dataRead, READ_BLOCK_NO) != 1) {
   b51c6:	491c      	ldr	r1, [pc, #112]	; (b5238 <_Z4RFIDv+0x7c>)
   b51c8:	481a      	ldr	r0, [pc, #104]	; (b5234 <_Z4RFIDv+0x78>)
   b51ca:	2202      	movs	r2, #2
   b51cc:	f001 f830 	bl	b6230 <_ZN13DFRobot_PN5328readDataEPhh>
   b51d0:	2801      	cmp	r0, #1
   b51d2:	d00a      	beq.n	b51ea <_Z4RFIDv+0x2e>
      // Serial.print("Block ");                            // DIAGNOSTICS
      // Serial.print(READ_BLOCK_NO);                       // DIAGNOSTICS
      Serial.println("FAILED - PLEASE SCAN AGAIN!");
   b51d4:	f002 fe08 	bl	b7de8 <_Z16_fetch_usbserialv>
   b51d8:	4918      	ldr	r1, [pc, #96]	; (b523c <_Z4RFIDv+0x80>)
   b51da:	f002 f9cc 	bl	b7576 <_ZN5Print7printlnEPKc>
      }
      Serial.println();
    }
    delay(500);
  }
}
   b51de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    delay(500);
   b51e2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   b51e6:	f001 bc27 	b.w	b6a38 <delay>
      Serial.println("ENJOY THE EVENT!");
   b51ea:	f002 fdfd 	bl	b7de8 <_Z16_fetch_usbserialv>
   b51ee:	4914      	ldr	r1, [pc, #80]	; (b5240 <_Z4RFIDv+0x84>)
   b51f0:	4d11      	ldr	r5, [pc, #68]	; (b5238 <_Z4RFIDv+0x7c>)
        Serial.print(" ");
   b51f2:	4f14      	ldr	r7, [pc, #80]	; (b5244 <_Z4RFIDv+0x88>)
      Serial.println("ENJOY THE EVENT!");
   b51f4:	f002 f9bf 	bl	b7576 <_ZN5Print7printlnEPKc>
      Serial.print("UID: ");
   b51f8:	f002 fdf6 	bl	b7de8 <_Z16_fetch_usbserialv>
   b51fc:	4912      	ldr	r1, [pc, #72]	; (b5248 <_Z4RFIDv+0x8c>)
   b51fe:	f002 f9a7 	bl	b7550 <_ZN5Print5printEPKc>
      for (int i = 0; i < BLOCK_SIZE; i++) {
   b5202:	2400      	movs	r4, #0
        dataRead[i] = 0;
   b5204:	4626      	mov	r6, r4
        Serial.print(dataRead[i], HEX);
   b5206:	f002 fdef 	bl	b7de8 <_Z16_fetch_usbserialv>
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
   b520a:	7829      	ldrb	r1, [r5, #0]
   b520c:	2210      	movs	r2, #16
   b520e:	f002 f9bc 	bl	b758a <_ZN5Print11printNumberEmh>
      for (int i = 0; i < BLOCK_SIZE; i++) {
   b5212:	3401      	adds	r4, #1
        Serial.print(" ");
   b5214:	f002 fde8 	bl	b7de8 <_Z16_fetch_usbserialv>
   b5218:	4639      	mov	r1, r7
   b521a:	f002 f999 	bl	b7550 <_ZN5Print5printEPKc>
      for (int i = 0; i < BLOCK_SIZE; i++) {
   b521e:	2c0a      	cmp	r4, #10
        dataRead[i] = 0;
   b5220:	f805 6b01 	strb.w	r6, [r5], #1
      for (int i = 0; i < BLOCK_SIZE; i++) {
   b5224:	d1ef      	bne.n	b5206 <_Z4RFIDv+0x4a>
      Serial.println();
   b5226:	f002 fddf 	bl	b7de8 <_Z16_fetch_usbserialv>
   b522a:	f002 f998 	bl	b755e <_ZN5Print7printlnEv>
   b522e:	e7d6      	b.n	b51de <_Z4RFIDv+0x22>
}
   b5230:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   b5232:	bf00      	nop
   b5234:	2003e13c 	.word	0x2003e13c
   b5238:	2003e0c0 	.word	0x2003e0c0
   b523c:	000b86b9 	.word	0x000b86b9
   b5240:	000b86d5 	.word	0x000b86d5
   b5244:	000b8614 	.word	0x000b8614
   b5248:	000b86e6 	.word	0x000b86e6

000b524c <_Z10Fuel_Gaugev>:

void Fuel_Gauge() {
   b524c:	b510      	push	{r4, lr}
   b524e:	ed2d 8b08 	vpush	{d8-d11}

    SOC = gauge.getSOC();
   b5252:	4c29      	ldr	r4, [pc, #164]	; (b52f8 <_Z10Fuel_Gaugev+0xac>)
void Fuel_Gauge() {
   b5254:	b08a      	sub	sp, #40	; 0x28
    SOC = gauge.getSOC();
   b5256:	4620      	mov	r0, r4
   b5258:	f000 fdb0 	bl	b5dbc <_ZN8max1720x6getSOCEv>
   b525c:	ec51 0b10 	vmov	r0, r1, d0
   b5260:	f7ff faac 	bl	b47bc <__aeabi_d2iz>
   b5264:	4b25      	ldr	r3, [pc, #148]	; (b52fc <_Z10Fuel_Gaugev+0xb0>)
   b5266:	6018      	str	r0, [r3, #0]
    V = gauge.getVoltage();
   b5268:	4620      	mov	r0, r4
   b526a:	f000 fd47 	bl	b5cfc <_ZN8max1720x10getVoltageEv>
   b526e:	ec51 0b10 	vmov	r0, r1, d0
   b5272:	f7ff faa3 	bl	b47bc <__aeabi_d2iz>
   b5276:	4b22      	ldr	r3, [pc, #136]	; (b5300 <_Z10Fuel_Gaugev+0xb4>)
   b5278:	6018      	str	r0, [r3, #0]

    // Construct data package for Paticle.publish // 
    Serial.println("Constructing message...");          //DEBUG
   b527a:	f002 fdb5 	bl	b7de8 <_Z16_fetch_usbserialv>
   b527e:	4921      	ldr	r1, [pc, #132]	; (b5304 <_Z10Fuel_Gaugev+0xb8>)
   b5280:	f002 f979 	bl	b7576 <_ZN5Print7printlnEPKc>

        
        snprintf(msgFG, sizeof(msgFG)
   b5284:	4620      	mov	r0, r4
   b5286:	f000 fd69 	bl	b5d5c <_ZN8max1720x14getTemperatureEv>
   b528a:	4620      	mov	r0, r4
   b528c:	eeb0 8a40 	vmov.f32	s16, s0
   b5290:	eef0 8a60 	vmov.f32	s17, s1
   b5294:	f000 fd32 	bl	b5cfc <_ZN8max1720x10getVoltageEv>
   b5298:	4620      	mov	r0, r4
   b529a:	eeb0 9a40 	vmov.f32	s18, s0
   b529e:	eef0 9a60 	vmov.f32	s19, s1
   b52a2:	f000 fdbd 	bl	b5e20 <_ZN8max1720x10getCurrentEv>
   b52a6:	4620      	mov	r0, r4
   b52a8:	eeb0 aa40 	vmov.f32	s20, s0
   b52ac:	eef0 aa60 	vmov.f32	s21, s1
   b52b0:	f000 fdf2 	bl	b5e98 <_ZN8max1720x11getCapacityEv>
   b52b4:	4620      	mov	r0, r4
   b52b6:	eeb0 ba40 	vmov.f32	s22, s0
   b52ba:	eef0 ba60 	vmov.f32	s23, s1
   b52be:	f000 fd7d 	bl	b5dbc <_ZN8max1720x6getSOCEv>
   b52c2:	4c11      	ldr	r4, [pc, #68]	; (b5308 <_Z10Fuel_Gaugev+0xbc>)
   b52c4:	4a11      	ldr	r2, [pc, #68]	; (b530c <_Z10Fuel_Gaugev+0xc0>)
   b52c6:	ed8d 0b08 	vstr	d0, [sp, #32]
   b52ca:	2140      	movs	r1, #64	; 0x40
   b52cc:	ed8d bb06 	vstr	d11, [sp, #24]
   b52d0:	ed8d ab04 	vstr	d10, [sp, #16]
   b52d4:	ed8d 9b02 	vstr	d9, [sp, #8]
   b52d8:	ed8d 8b00 	vstr	d8, [sp]
   b52dc:	4620      	mov	r0, r4
   b52de:	f001 fb6b 	bl	b69b8 <snprintf>
            , gauge.getCapacity()
            , gauge.getSOC()
            );

    //Particle.publish("Battery Statistics", msgFG);        // Send messages to Particle Cloud
    Serial.print(msgFG);                                    //DEBUG
   b52e2:	f002 fd81 	bl	b7de8 <_Z16_fetch_usbserialv>
   b52e6:	4621      	mov	r1, r4

}
   b52e8:	b00a      	add	sp, #40	; 0x28
   b52ea:	ecbd 8b08 	vpop	{d8-d11}
   b52ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Serial.print(msgFG);                                    //DEBUG
   b52f2:	f002 b92d 	b.w	b7550 <_ZN5Print5printEPKc>
   b52f6:	bf00      	nop
   b52f8:	2003e0e0 	.word	0x2003e0e0
   b52fc:	2003e02c 	.word	0x2003e02c
   b5300:	2003e04c 	.word	0x2003e04c
   b5304:	000b86ec 	.word	0x000b86ec
   b5308:	2003e0f8 	.word	0x2003e0f8
   b530c:	000b8704 	.word	0x000b8704

000b5310 <_GLOBAL__sub_I_SystemMode>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
   b5310:	4b1c      	ldr	r3, [pc, #112]	; (b5384 <_GLOBAL__sub_I_SystemMode+0x74>)
   b5312:	2201      	movs	r2, #1
  if (new_end_point_STATE == 2) {
      EPD();
      }    

  RFID();
}
   b5314:	b510      	push	{r4, lr}
   b5316:	701a      	strb	r2, [r3, #0]

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   b5318:	4b1b      	ldr	r3, [pc, #108]	; (b5388 <_GLOBAL__sub_I_SystemMode+0x78>)
    SleepResult() {}
   b531a:	f1a2 1201 	sub.w	r2, r2, #65537	; 0x10001
              error_(SYSTEM_ERROR_NONE) {
   b531e:	2400      	movs	r4, #0
   b5320:	e9c3 4400 	strd	r4, r4, [r3]
    SleepResult() {}
   b5324:	609a      	str	r2, [r3, #8]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   b5326:	2002      	movs	r0, #2
   b5328:	f001 fa4a 	bl	b67c0 <set_system_mode>
String EvendId;
   b532c:	4917      	ldr	r1, [pc, #92]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b532e:	4818      	ldr	r0, [pc, #96]	; (b5390 <_GLOBAL__sub_I_SystemMode+0x80>)
   b5330:	f002 fa79 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String ReaderMode;
   b5334:	4915      	ldr	r1, [pc, #84]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b5336:	4817      	ldr	r0, [pc, #92]	; (b5394 <_GLOBAL__sub_I_SystemMode+0x84>)
   b5338:	f002 fa75 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String TimeStamp;
   b533c:	4913      	ldr	r1, [pc, #76]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b533e:	4816      	ldr	r0, [pc, #88]	; (b5398 <_GLOBAL__sub_I_SystemMode+0x88>)
   b5340:	f002 fa71 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String Identifier;
   b5344:	4911      	ldr	r1, [pc, #68]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b5346:	4815      	ldr	r0, [pc, #84]	; (b539c <_GLOBAL__sub_I_SystemMode+0x8c>)
   b5348:	f002 fa6d 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String rfid_uid = "";
   b534c:	490f      	ldr	r1, [pc, #60]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b534e:	4814      	ldr	r0, [pc, #80]	; (b53a0 <_GLOBAL__sub_I_SystemMode+0x90>)
   b5350:	f002 fa69 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String hhmmss;
   b5354:	490d      	ldr	r1, [pc, #52]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b5356:	4813      	ldr	r0, [pc, #76]	; (b53a4 <_GLOBAL__sub_I_SystemMode+0x94>)
   b5358:	f002 fa65 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
String data_time;
   b535c:	490b      	ldr	r1, [pc, #44]	; (b538c <_GLOBAL__sub_I_SystemMode+0x7c>)
   b535e:	4812      	ldr	r0, [pc, #72]	; (b53a8 <_GLOBAL__sub_I_SystemMode+0x98>)
   b5360:	f002 fa61 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
}ApiData1, ApiData2;
   b5364:	4811      	ldr	r0, [pc, #68]	; (b53ac <_GLOBAL__sub_I_SystemMode+0x9c>)
   b5366:	f7ff fb01 	bl	b496c <_ZN11myStructureC1Ev>
   b536a:	4811      	ldr	r0, [pc, #68]	; (b53b0 <_GLOBAL__sub_I_SystemMode+0xa0>)
   b536c:	f7ff fafe 	bl	b496c <_ZN11myStructureC1Ev>
DFRobot_PN532_IIC  nfc(PN532_IRQ, POLLING);
   b5370:	4622      	mov	r2, r4
   b5372:	4810      	ldr	r0, [pc, #64]	; (b53b4 <_GLOBAL__sub_I_SystemMode+0xa4>)
   b5374:	2102      	movs	r1, #2
   b5376:	f000 ffab 	bl	b62d0 <_ZN17DFRobot_PN532_IICC1Ehh>
}
   b537a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
max1720x gauge;
   b537e:	480e      	ldr	r0, [pc, #56]	; (b53b8 <_GLOBAL__sub_I_SystemMode+0xa8>)
   b5380:	f000 bcb4 	b.w	b5cec <_ZN8max1720xC1Ev>
   b5384:	2003e050 	.word	0x2003e050
   b5388:	2003e030 	.word	0x2003e030
   b538c:	000b8734 	.word	0x000b8734
   b5390:	2003dff8 	.word	0x2003dff8
   b5394:	2003e01c 	.word	0x2003e01c
   b5398:	2003e03c 	.word	0x2003e03c
   b539c:	2003e00c 	.word	0x2003e00c
   b53a0:	2003e190 	.word	0x2003e190
   b53a4:	2003e0e8 	.word	0x2003e0e8
   b53a8:	2003e0d0 	.word	0x2003e0d0
   b53ac:	2003de78 	.word	0x2003de78
   b53b0:	2003df38 	.word	0x2003df38
   b53b4:	2003e13c 	.word	0x2003e13c
   b53b8:	2003e0e0 	.word	0x2003e0e0

000b53bc <_Z9End_Pointv>:
void End_Point() {
   b53bc:	b530      	push	{r4, r5, lr}
   b53be:	b085      	sub	sp, #20
  Serial.println("Calling End Point function..."); 
   b53c0:	f002 fd12 	bl	b7de8 <_Z16_fetch_usbserialv>
   b53c4:	4931      	ldr	r1, [pc, #196]	; (b548c <_Z9End_Pointv+0xd0>)
   b53c6:	f002 f8d6 	bl	b7576 <_ZN5Print7printlnEPKc>
      uint32_t freemem = System.freeMemory();
   b53ca:	f002 fb41 	bl	b7a50 <_ZN11SystemClass10freeMemoryEv>
   b53ce:	4605      	mov	r5, r0
      Serial.print("free memory: ");
   b53d0:	f002 fd0a 	bl	b7de8 <_Z16_fetch_usbserialv>
   b53d4:	492e      	ldr	r1, [pc, #184]	; (b5490 <_Z9End_Pointv+0xd4>)
   b53d6:	f002 f8bb 	bl	b7550 <_ZN5Print5printEPKc>
      Serial.println(freemem);
   b53da:	f002 fd05 	bl	b7de8 <_Z16_fetch_usbserialv>
   b53de:	220a      	movs	r2, #10
   b53e0:	4604      	mov	r4, r0
   b53e2:	4629      	mov	r1, r5
   b53e4:	f002 f8d1 	bl	b758a <_ZN5Print11printNumberEmh>
        n += println();
   b53e8:	4620      	mov	r0, r4
   b53ea:	f002 f8b8 	bl	b755e <_ZN5Print7printlnEv>
    static bool connected(void) { return spark_cloud_flag_connected(); }
   b53ee:	f001 fa33 	bl	b6858 <spark_cloud_flag_connected>
   if (Particle.connected() == false) {
   b53f2:	4604      	mov	r4, r0
   b53f4:	2800      	cmp	r0, #0
   b53f6:	d146      	bne.n	b5486 <_Z9End_Pointv+0xca>
      Serial.println("IF Statement executing");
   b53f8:	f002 fcf6 	bl	b7de8 <_Z16_fetch_usbserialv>
   b53fc:	4925      	ldr	r1, [pc, #148]	; (b5494 <_Z9End_Pointv+0xd8>)
    virtual void setListenTimeout(uint16_t timeout);
    virtual uint16_t getListenTimeout();
    virtual bool listening();

    operator network_interface_t() const {
        return iface_;
   b53fe:	4d26      	ldr	r5, [pc, #152]	; (b5498 <_Z9End_Pointv+0xdc>)
   b5400:	f002 f8b9 	bl	b7576 <_ZN5Print7printlnEPKc>
      digitalWrite(LDO_EN, HIGH);
   b5404:	2101      	movs	r1, #1
   b5406:	2017      	movs	r0, #23
   b5408:	f002 fe51 	bl	b80ae <digitalWrite>
      delay(1000);
   b540c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   b5410:	f001 fb12 	bl	b6a38 <delay>

    IPAddress localIP() {
        return IPAddress(((CellularConfig*)network_config(*this, 0, NULL))->nw.aucIP);
    }
    void on() {
        network_on(*this, 0, 0, NULL);
   b5414:	6868      	ldr	r0, [r5, #4]
   b5416:	4623      	mov	r3, r4
   b5418:	4622      	mov	r2, r4
   b541a:	4621      	mov	r1, r4
   b541c:	f001 fa74 	bl	b6908 <network_on>
      waitUntil(Cellular.isOn);
   b5420:	4628      	mov	r0, r5
   b5422:	f001 ffdb 	bl	b73dc <_ZN5spark12NetworkClass4isOnEv>

    static uint32_t freeMemory();

    template<typename Condition, typename While>
    static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
   b5426:	b910      	cbnz	r0, b542e <_Z9End_Pointv+0x72>
            spark_process();
   b5428:	f001 fa06 	bl	b6838 <spark_process>
        while (_while() && !_condition()) {
   b542c:	e7f8      	b.n	b5420 <_Z9End_Pointv+0x64>
   b542e:	481a      	ldr	r0, [pc, #104]	; (b5498 <_Z9End_Pointv+0xdc>)
   b5430:	f001 ffd4 	bl	b73dc <_ZN5spark12NetworkClass4isOnEv>
        spark_cloud_flag_connect();
   b5434:	f001 fa08 	bl	b6848 <spark_cloud_flag_connect>
    static bool connected(void) { return spark_cloud_flag_connected(); }
   b5438:	f001 fa0e 	bl	b6858 <spark_cloud_flag_connected>
   b543c:	b910      	cbnz	r0, b5444 <_Z9End_Pointv+0x88>
            spark_process();
   b543e:	f001 f9fb 	bl	b6838 <spark_process>
        while (_while() && !_condition()) {
   b5442:	e7f9      	b.n	b5438 <_Z9End_Pointv+0x7c>
   b5444:	f001 fa08 	bl	b6858 <spark_cloud_flag_connected>
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(ValueT val) :
   b5448:	4b14      	ldr	r3, [pc, #80]	; (b549c <_Z9End_Pointv+0xe0>)
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
   b544a:	4a15      	ldr	r2, [pc, #84]	; (b54a0 <_Z9End_Pointv+0xe4>)
   b544c:	781b      	ldrb	r3, [r3, #0]
   b544e:	f88d 3000 	strb.w	r3, [sp]
   b5452:	4914      	ldr	r1, [pc, #80]	; (b54a4 <_Z9End_Pointv+0xe8>)
   b5454:	233c      	movs	r3, #60	; 0x3c
   b5456:	a802      	add	r0, sp, #8
   b5458:	f001 fcec 	bl	b6e34 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   b545c:	9c03      	ldr	r4, [sp, #12]
   b545e:	b17c      	cbz	r4, b5480 <_Z9End_Pointv+0xc4>
      if (--_M_use_count == 0)
   b5460:	6863      	ldr	r3, [r4, #4]
   b5462:	3b01      	subs	r3, #1
   b5464:	6063      	str	r3, [r4, #4]
   b5466:	b95b      	cbnz	r3, b5480 <_Z9End_Pointv+0xc4>
          _M_dispose();
   b5468:	6823      	ldr	r3, [r4, #0]
   b546a:	4620      	mov	r0, r4
   b546c:	689b      	ldr	r3, [r3, #8]
   b546e:	4798      	blx	r3
          if (--_M_weak_count == 0)
   b5470:	68a3      	ldr	r3, [r4, #8]
   b5472:	3b01      	subs	r3, #1
   b5474:	60a3      	str	r3, [r4, #8]
   b5476:	b91b      	cbnz	r3, b5480 <_Z9End_Pointv+0xc4>
            _M_destroy();
   b5478:	6823      	ldr	r3, [r4, #0]
   b547a:	4620      	mov	r0, r4
   b547c:	68db      	ldr	r3, [r3, #12]
   b547e:	4798      	blx	r3
      new_end_point_STATE = 1;  
   b5480:	4b09      	ldr	r3, [pc, #36]	; (b54a8 <_Z9End_Pointv+0xec>)
   b5482:	2201      	movs	r2, #1
   b5484:	601a      	str	r2, [r3, #0]
}
   b5486:	b005      	add	sp, #20
   b5488:	bd30      	pop	{r4, r5, pc}
   b548a:	bf00      	nop
   b548c:	000b8735 	.word	0x000b8735
   b5490:	000b8753 	.word	0x000b8753
   b5494:	000b8761 	.word	0x000b8761
   b5498:	2003e660 	.word	0x2003e660
   b549c:	2003e050 	.word	0x2003e050
   b54a0:	2003dde4 	.word	0x2003dde4
   b54a4:	000b85de 	.word	0x000b85de
   b54a8:	2003e138 	.word	0x2003e138

000b54ac <loop>:
void loop() {
   b54ac:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   b54ae:	f001 f81f 	bl	b64f0 <HAL_Timer_Get_Milli_Seconds>
currentMillis1 = millis();
   b54b2:	4c30      	ldr	r4, [pc, #192]	; (b5574 <loop+0xc8>)
current_Publish_Millis = millis();
   b54b4:	4d30      	ldr	r5, [pc, #192]	; (b5578 <loop+0xcc>)
currentMillis1 = millis();
   b54b6:	6020      	str	r0, [r4, #0]
   b54b8:	f001 f81a 	bl	b64f0 <HAL_Timer_Get_Milli_Seconds>
currentMillis1 = millis();
   b54bc:	6020      	str	r0, [r4, #0]
   b54be:	f001 f817 	bl	b64f0 <HAL_Timer_Get_Milli_Seconds>
  if ((currentMillis1 - previousMillis1 >= epaper_update_interval) && (new_end_point_STATE == 0)) {
   b54c2:	4a2e      	ldr	r2, [pc, #184]	; (b557c <loop+0xd0>)
current_Publish_Millis = millis();
   b54c4:	6028      	str	r0, [r5, #0]
  if ((currentMillis1 - previousMillis1 >= epaper_update_interval) && (new_end_point_STATE == 0)) {
   b54c6:	482e      	ldr	r0, [pc, #184]	; (b5580 <loop+0xd4>)
   b54c8:	6821      	ldr	r1, [r4, #0]
   b54ca:	6813      	ldr	r3, [r2, #0]
   b54cc:	6800      	ldr	r0, [r0, #0]
   b54ce:	1acb      	subs	r3, r1, r3
   b54d0:	4283      	cmp	r3, r0
   b54d2:	d305      	bcc.n	b54e0 <loop+0x34>
   b54d4:	4b2b      	ldr	r3, [pc, #172]	; (b5584 <loop+0xd8>)
   b54d6:	681b      	ldr	r3, [r3, #0]
   b54d8:	b913      	cbnz	r3, b54e0 <loop+0x34>
      previousMillis1 = currentMillis1;
   b54da:	6011      	str	r1, [r2, #0]
      End_Point();
   b54dc:	f7ff ff6e 	bl	b53bc <_Z9End_Pointv>
  if ((current_Publish_Millis - previous_Publish_Millis >= battery_level_interval)) {
   b54e0:	4a29      	ldr	r2, [pc, #164]	; (b5588 <loop+0xdc>)
   b54e2:	482a      	ldr	r0, [pc, #168]	; (b558c <loop+0xe0>)
   b54e4:	6829      	ldr	r1, [r5, #0]
   b54e6:	6813      	ldr	r3, [r2, #0]
   b54e8:	6800      	ldr	r0, [r0, #0]
   b54ea:	1acb      	subs	r3, r1, r3
   b54ec:	4283      	cmp	r3, r0
   b54ee:	d302      	bcc.n	b54f6 <loop+0x4a>
      previous_Publish_Millis = current_Publish_Millis;
   b54f0:	6011      	str	r1, [r2, #0]
      Fuel_Gauge();
   b54f2:	f7ff feab 	bl	b524c <_Z10Fuel_Gaugev>
  if (Handler_STATE == 1) {    
   b54f6:	4d26      	ldr	r5, [pc, #152]	; (b5590 <loop+0xe4>)
   b54f8:	682b      	ldr	r3, [r5, #0]
   b54fa:	2b01      	cmp	r3, #1
   b54fc:	d12f      	bne.n	b555e <loop+0xb2>
        clearSession_(clearSession) {
   b54fe:	2300      	movs	r3, #0
      Particle.disconnect();                                                 // Use only in SEMI_AUTOMATIC mode
   b5500:	a801      	add	r0, sp, #4
   b5502:	e9cd 3301 	strd	r3, r3, [sp, #4]
        bool clearSession) :
   b5506:	f8ad 300c 	strh.w	r3, [sp, #12]
   b550a:	f001 fb76 	bl	b6bfa <_ZN10CloudClass10disconnectERK22CloudDisconnectOptions>
    static bool connected(void) { return spark_cloud_flag_connected(); }
   b550e:	f001 f9a3 	bl	b6858 <spark_cloud_flag_connected>
   b5512:	4604      	mov	r4, r0
   b5514:	b110      	cbz	r0, b551c <loop+0x70>
            spark_process();
   b5516:	f001 f98f 	bl	b6838 <spark_process>
        while (_while() && !_condition()) {
   b551a:	e7f8      	b.n	b550e <loop+0x62>
   b551c:	4e1d      	ldr	r6, [pc, #116]	; (b5594 <loop+0xe8>)
   b551e:	f001 f99b 	bl	b6858 <spark_cloud_flag_connected>
    }
    void off() {
        network_off(*this, 0, 0, NULL);
   b5522:	6870      	ldr	r0, [r6, #4]
   b5524:	4623      	mov	r3, r4
   b5526:	4622      	mov	r2, r4
   b5528:	4621      	mov	r1, r4
   b552a:	f001 f9f5 	bl	b6918 <network_off>
      waitUntil(Cellular.isOff);
   b552e:	4630      	mov	r0, r6
   b5530:	f001 ff58 	bl	b73e4 <_ZN5spark12NetworkClass5isOffEv>
   b5534:	b910      	cbnz	r0, b553c <loop+0x90>
            spark_process();
   b5536:	f001 f97f 	bl	b6838 <spark_process>
        while (_while() && !_condition()) {
   b553a:	e7f8      	b.n	b552e <loop+0x82>
   b553c:	4815      	ldr	r0, [pc, #84]	; (b5594 <loop+0xe8>)
   b553e:	f001 ff51 	bl	b73e4 <_ZN5spark12NetworkClass5isOffEv>
      delay(10);
   b5542:	200a      	movs	r0, #10
   b5544:	f001 fa78 	bl	b6a38 <delay>
      digitalWrite(LDO_EN, LOW);
   b5548:	2100      	movs	r1, #0
   b554a:	2017      	movs	r0, #23
   b554c:	f002 fdaf 	bl	b80ae <digitalWrite>
      Serial.println("LDO Disconnected");
   b5550:	f002 fc4a 	bl	b7de8 <_Z16_fetch_usbserialv>
   b5554:	4910      	ldr	r1, [pc, #64]	; (b5598 <loop+0xec>)
   b5556:	f002 f80e 	bl	b7576 <_ZN5Print7printlnEPKc>
      Handler_STATE = 0;
   b555a:	2300      	movs	r3, #0
   b555c:	602b      	str	r3, [r5, #0]
  if (new_end_point_STATE == 2) {
   b555e:	4b09      	ldr	r3, [pc, #36]	; (b5584 <loop+0xd8>)
   b5560:	681b      	ldr	r3, [r3, #0]
   b5562:	2b02      	cmp	r3, #2
   b5564:	d101      	bne.n	b556a <loop+0xbe>
      EPD();
   b5566:	f7ff faa1 	bl	b4aac <_Z3EPDv>
}
   b556a:	b004      	add	sp, #16
   b556c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  RFID();
   b5570:	f7ff be24 	b.w	b51bc <_Z4RFIDv>
   b5574:	2003e0b8 	.word	0x2003e0b8
   b5578:	2003e0bc 	.word	0x2003e0bc
   b557c:	2003e188 	.word	0x2003e188
   b5580:	2003ddf0 	.word	0x2003ddf0
   b5584:	2003e138 	.word	0x2003e138
   b5588:	2003e18c 	.word	0x2003e18c
   b558c:	2003dde0 	.word	0x2003dde0
   b5590:	2003e008 	.word	0x2003e008
   b5594:	2003e660 	.word	0x2003e660
   b5598:	000b8778 	.word	0x000b8778

000b559c <_ZN3EpdD1Ev>:

#include <stdlib.h>
//#include "epd4in2b_V2.h"
#include "../lib/EPD4_2/src/epd4in2b_V2.h"

Epd::~Epd() {
   b559c:	b510      	push	{r4, lr}
   b559e:	4604      	mov	r4, r0
   b55a0:	f000 f9d7 	bl	b5952 <_ZN5EpdIfD1Ev>
};
   b55a4:	4620      	mov	r0, r4
   b55a6:	bd10      	pop	{r4, pc}

000b55a8 <_ZN3EpdC1Ev>:

Epd::Epd() {
   b55a8:	b510      	push	{r4, lr}
   b55aa:	4604      	mov	r4, r0
   b55ac:	f000 f9d0 	bl	b5950 <_ZN5EpdIfC1Ev>
    reset_pin = RST_PIN;
    dc_pin = DC_PIN;
   b55b0:	2206      	movs	r2, #6
   b55b2:	2305      	movs	r3, #5
   b55b4:	e9c4 2302 	strd	r2, r3, [r4, #8]
    cs_pin = CS_PIN;
    busy_pin = BUSY_PIN;
   b55b8:	2108      	movs	r1, #8
   b55ba:	2307      	movs	r3, #7
   b55bc:	e9c4 1304 	strd	r1, r3, [r4, #16]
    width = EPD_WIDTH;
    height = EPD_HEIGHT;
   b55c0:	f44f 70c8 	mov.w	r0, #400	; 0x190
   b55c4:	f44f 7396 	mov.w	r3, #300	; 0x12c
   b55c8:	e9c4 0300 	strd	r0, r3, [r4]
};
   b55cc:	4620      	mov	r0, r4
   b55ce:	bd10      	pop	{r4, pc}

000b55d0 <_ZN3Epd11SendCommandEh>:
}

/**
 *  @brief: basic function for sending commands
 */
void Epd::SendCommand(unsigned char command) {
   b55d0:	b510      	push	{r4, lr}
   b55d2:	460c      	mov	r4, r1
    DigitalWrite(dc_pin, LOW);
   b55d4:	68c0      	ldr	r0, [r0, #12]
   b55d6:	2100      	movs	r1, #0
   b55d8:	f000 f9bc 	bl	b5954 <_ZN5EpdIf12DigitalWriteEii>
    SpiTransfer(command);
   b55dc:	4620      	mov	r0, r4
}
   b55de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SpiTransfer(command);
   b55e2:	f000 ba09 	b.w	b59f8 <_ZN5EpdIf11SpiTransferEh>

000b55e6 <_ZN3Epd8SendDataEh>:

/**
 *  @brief: basic function for sending data
 */
void Epd::SendData(unsigned char data) {
   b55e6:	b510      	push	{r4, lr}
   b55e8:	460c      	mov	r4, r1
    DigitalWrite(dc_pin, HIGH);
   b55ea:	68c0      	ldr	r0, [r0, #12]
   b55ec:	2101      	movs	r1, #1
   b55ee:	f000 f9b1 	bl	b5954 <_ZN5EpdIf12DigitalWriteEii>
    SpiTransfer(data);
   b55f2:	4620      	mov	r0, r4
}
   b55f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SpiTransfer(data);
   b55f8:	f000 b9fe 	b.w	b59f8 <_ZN5EpdIf11SpiTransferEh>

000b55fc <_ZN3Epd13WaitUntilIdleEv>:

/**
 *  @brief: Wait until the busy_pin goes HIGH
 */
void Epd::WaitUntilIdle(void) {
   b55fc:	b510      	push	{r4, lr}
   b55fe:	4604      	mov	r4, r0
    while(DigitalRead(busy_pin) == 0) {      //0: busy, 1: idle
   b5600:	6960      	ldr	r0, [r4, #20]
   b5602:	f000 f9ab 	bl	b595c <_ZN5EpdIf11DigitalReadEi>
   b5606:	b918      	cbnz	r0, b5610 <_ZN3Epd13WaitUntilIdleEv+0x14>
        DelayMs(100);
   b5608:	2064      	movs	r0, #100	; 0x64
   b560a:	f000 f9aa 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    while(DigitalRead(busy_pin) == 0) {      //0: busy, 1: idle
   b560e:	e7f7      	b.n	b5600 <_ZN3Epd13WaitUntilIdleEv+0x4>
    }      
}
   b5610:	bd10      	pop	{r4, pc}

000b5612 <_ZN3Epd5ResetEv>:
/**
 *  @brief: module reset. 
 *          often used to awaken the module in deep sleep, 
 *          see Epd::Sleep();
 */
void Epd::Reset(void) {
   b5612:	b510      	push	{r4, lr}
    DigitalWrite(reset_pin, HIGH);
   b5614:	2101      	movs	r1, #1
void Epd::Reset(void) {
   b5616:	4604      	mov	r4, r0
    DigitalWrite(reset_pin, HIGH);
   b5618:	6880      	ldr	r0, [r0, #8]
   b561a:	f000 f99b 	bl	b5954 <_ZN5EpdIf12DigitalWriteEii>
    DelayMs(200);   
   b561e:	20c8      	movs	r0, #200	; 0xc8
   b5620:	f000 f99f 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    DigitalWrite(reset_pin, LOW);
   b5624:	68a0      	ldr	r0, [r4, #8]
   b5626:	2100      	movs	r1, #0
   b5628:	f000 f994 	bl	b5954 <_ZN5EpdIf12DigitalWriteEii>
    DelayMs(2);
   b562c:	2002      	movs	r0, #2
   b562e:	f000 f998 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    DigitalWrite(reset_pin, HIGH);
   b5632:	68a0      	ldr	r0, [r4, #8]
   b5634:	2101      	movs	r1, #1
   b5636:	f000 f98d 	bl	b5954 <_ZN5EpdIf12DigitalWriteEii>
    DelayMs(200);   
}
   b563a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    DelayMs(200);   
   b563e:	20c8      	movs	r0, #200	; 0xc8
   b5640:	f000 b98f 	b.w	b5962 <_ZN5EpdIf7DelayMsEj>

000b5644 <_ZN3Epd4InitEv>:
int Epd::Init(void) {
   b5644:	b538      	push	{r3, r4, r5, lr}
   b5646:	4604      	mov	r4, r0
    if (IfInit() != 0) {
   b5648:	f000 f9aa 	bl	b59a0 <_ZN5EpdIf6IfInitEv>
   b564c:	4605      	mov	r5, r0
   b564e:	b998      	cbnz	r0, b5678 <_ZN3Epd4InitEv+0x34>
    Reset();
   b5650:	4620      	mov	r0, r4
   b5652:	f7ff ffde 	bl	b5612 <_ZN3Epd5ResetEv>
    SendCommand(POWER_ON);
   b5656:	2104      	movs	r1, #4
   b5658:	4620      	mov	r0, r4
   b565a:	f7ff ffb9 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    WaitUntilIdle();
   b565e:	4620      	mov	r0, r4
   b5660:	f7ff ffcc 	bl	b55fc <_ZN3Epd13WaitUntilIdleEv>
    SendCommand(PANEL_SETTING);
   b5664:	4629      	mov	r1, r5
   b5666:	4620      	mov	r0, r4
   b5668:	f7ff ffb2 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendData(0x0F);     // LUT from OTP
   b566c:	210f      	movs	r1, #15
   b566e:	4620      	mov	r0, r4
   b5670:	f7ff ffb9 	bl	b55e6 <_ZN3Epd8SendDataEh>
}
   b5674:	4628      	mov	r0, r5
   b5676:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   b5678:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   b567c:	e7fa      	b.n	b5674 <_ZN3Epd4InitEv+0x30>

000b567e <_ZN3Epd21SetPartialWindowBlackEPKhiiii>:
}

/**
 *  @brief: transmit partial data to the black part of SRAM
 */
void Epd::SetPartialWindowBlack(const unsigned char* buffer_black, int x, int y, int w, int l) {
   b567e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   b5682:	4604      	mov	r4, r0
   b5684:	460f      	mov	r7, r1
    SendCommand(PARTIAL_IN);
   b5686:	2191      	movs	r1, #145	; 0x91
void Epd::SetPartialWindowBlack(const unsigned char* buffer_black, int x, int y, int w, int l) {
   b5688:	4616      	mov	r6, r2
   b568a:	4699      	mov	r9, r3
   b568c:	e9dd 5808 	ldrd	r5, r8, [sp, #32]
    SendCommand(PARTIAL_IN);
   b5690:	f7ff ff9e 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendCommand(PARTIAL_WINDOW);
   b5694:	2190      	movs	r1, #144	; 0x90
   b5696:	4620      	mov	r0, r4
    SendData(x >> 8);
    SendData(x & 0xf8);     // x should be the multiple of 8, the last 3 bit will always be ignored
   b5698:	f006 0af8 	and.w	sl, r6, #248	; 0xf8
    SendCommand(PARTIAL_WINDOW);
   b569c:	f7ff ff98 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendData(x >> 8);
   b56a0:	f3c6 2107 	ubfx	r1, r6, #8, #8
   b56a4:	4620      	mov	r0, r4
   b56a6:	f7ff ff9e 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(x & 0xf8);     // x should be the multiple of 8, the last 3 bit will always be ignored
   b56aa:	4651      	mov	r1, sl
   b56ac:	4620      	mov	r0, r4
   b56ae:	f7ff ff9a 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(((x & 0xf8) + w  - 1) >> 8);
   b56b2:	4651      	mov	r1, sl
   b56b4:	4429      	add	r1, r5
   b56b6:	3901      	subs	r1, #1
   b56b8:	f3c1 2107 	ubfx	r1, r1, #8, #8
   b56bc:	4620      	mov	r0, r4
   b56be:	f7ff ff92 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(((x & 0xf8) + w  - 1) | 0x07);
   b56c2:	1e69      	subs	r1, r5, #1
   b56c4:	4451      	add	r1, sl
   b56c6:	f041 0107 	orr.w	r1, r1, #7
   b56ca:	b2c9      	uxtb	r1, r1
   b56cc:	4620      	mov	r0, r4
   b56ce:	f7ff ff8a 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(y >> 8);        
    SendData(y & 0xff);
   b56d2:	fa5f f689 	uxtb.w	r6, r9
    SendData(y >> 8);        
   b56d6:	f3c9 2107 	ubfx	r1, r9, #8, #8
   b56da:	4620      	mov	r0, r4
   b56dc:	f7ff ff83 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(y & 0xff);
   b56e0:	4631      	mov	r1, r6
   b56e2:	4620      	mov	r0, r4
   b56e4:	f7ff ff7f 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData((y + l - 1) >> 8);        
   b56e8:	eb09 0108 	add.w	r1, r9, r8
   b56ec:	3901      	subs	r1, #1
   b56ee:	f3c1 2107 	ubfx	r1, r1, #8, #8
   b56f2:	4620      	mov	r0, r4
   b56f4:	f7ff ff77 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData((y + l - 1) & 0xff);
   b56f8:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
   b56fc:	4431      	add	r1, r6
   b56fe:	b2c9      	uxtb	r1, r1
   b5700:	4620      	mov	r0, r4
   b5702:	f7ff ff70 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(0x01);         // Gates scan both inside and outside of the partial window. (default) 
   b5706:	2101      	movs	r1, #1
   b5708:	4620      	mov	r0, r4
   b570a:	f7ff ff6c 	bl	b55e6 <_ZN3Epd8SendDataEh>
    DelayMs(2);
   b570e:	2002      	movs	r0, #2
   b5710:	f000 f927 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    SendCommand(DATA_START_TRANSMISSION_1);
   b5714:	2110      	movs	r1, #16
   b5716:	4620      	mov	r0, r4
   b5718:	f7ff ff5a 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    if (buffer_black != NULL) {
   b571c:	b177      	cbz	r7, b573c <_ZN3Epd21SetPartialWindowBlackEPKhiiii+0xbe>
        for(int i = 0; i < w  / 8 * l; i++) {
   b571e:	2d00      	cmp	r5, #0
   b5720:	bfb8      	it	lt
   b5722:	3507      	addlt	r5, #7
   b5724:	10ed      	asrs	r5, r5, #3
   b5726:	fb08 f505 	mul.w	r5, r8, r5
   b572a:	2600      	movs	r6, #0
   b572c:	42b5      	cmp	r5, r6
   b572e:	dd05      	ble.n	b573c <_ZN3Epd21SetPartialWindowBlackEPKhiiii+0xbe>
            SendData(buffer_black[i]);  
   b5730:	5db9      	ldrb	r1, [r7, r6]
   b5732:	4620      	mov	r0, r4
   b5734:	f7ff ff57 	bl	b55e6 <_ZN3Epd8SendDataEh>
        for(int i = 0; i < w  / 8 * l; i++) {
   b5738:	3601      	adds	r6, #1
   b573a:	e7f7      	b.n	b572c <_ZN3Epd21SetPartialWindowBlackEPKhiiii+0xae>
        }  
    }
    DelayMs(2);
   b573c:	2002      	movs	r0, #2
   b573e:	f000 f910 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    SendCommand(PARTIAL_OUT);  
   b5742:	4620      	mov	r0, r4
   b5744:	2192      	movs	r1, #146	; 0x92
}
   b5746:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    SendCommand(PARTIAL_OUT);  
   b574a:	f7ff bf41 	b.w	b55d0 <_ZN3Epd11SendCommandEh>

000b574e <_ZN3Epd19SetPartialWindowRedEPKhiiii>:

/**
 *  @brief: transmit partial data to the red part of SRAM
 */
void Epd::SetPartialWindowRed(const unsigned char* buffer_red, int x, int y, int w, int l) {
   b574e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   b5752:	4604      	mov	r4, r0
   b5754:	460f      	mov	r7, r1
    SendCommand(PARTIAL_IN);
   b5756:	2191      	movs	r1, #145	; 0x91
void Epd::SetPartialWindowRed(const unsigned char* buffer_red, int x, int y, int w, int l) {
   b5758:	4616      	mov	r6, r2
   b575a:	4699      	mov	r9, r3
   b575c:	e9dd 5808 	ldrd	r5, r8, [sp, #32]
    SendCommand(PARTIAL_IN);
   b5760:	f7ff ff36 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendCommand(PARTIAL_WINDOW);
   b5764:	2190      	movs	r1, #144	; 0x90
   b5766:	4620      	mov	r0, r4
    SendData(x >> 8);
    SendData(x & 0xf8);     // x should be the multiple of 8, the last 3 bit will always be ignored
   b5768:	f006 0af8 	and.w	sl, r6, #248	; 0xf8
    SendCommand(PARTIAL_WINDOW);
   b576c:	f7ff ff30 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendData(x >> 8);
   b5770:	f3c6 2107 	ubfx	r1, r6, #8, #8
   b5774:	4620      	mov	r0, r4
   b5776:	f7ff ff36 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(x & 0xf8);     // x should be the multiple of 8, the last 3 bit will always be ignored
   b577a:	4651      	mov	r1, sl
   b577c:	4620      	mov	r0, r4
   b577e:	f7ff ff32 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(((x & 0xf8) + w  - 1) >> 8);
   b5782:	4651      	mov	r1, sl
   b5784:	4429      	add	r1, r5
   b5786:	3901      	subs	r1, #1
   b5788:	f3c1 2107 	ubfx	r1, r1, #8, #8
   b578c:	4620      	mov	r0, r4
   b578e:	f7ff ff2a 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(((x & 0xf8) + w  - 1) | 0x07);
   b5792:	1e69      	subs	r1, r5, #1
   b5794:	4451      	add	r1, sl
   b5796:	f041 0107 	orr.w	r1, r1, #7
   b579a:	b2c9      	uxtb	r1, r1
   b579c:	4620      	mov	r0, r4
   b579e:	f7ff ff22 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(y >> 8);        
    SendData(y & 0xff);
   b57a2:	fa5f f689 	uxtb.w	r6, r9
    SendData(y >> 8);        
   b57a6:	f3c9 2107 	ubfx	r1, r9, #8, #8
   b57aa:	4620      	mov	r0, r4
   b57ac:	f7ff ff1b 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(y & 0xff);
   b57b0:	4631      	mov	r1, r6
   b57b2:	4620      	mov	r0, r4
   b57b4:	f7ff ff17 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData((y + l - 1) >> 8);        
   b57b8:	eb09 0108 	add.w	r1, r9, r8
   b57bc:	3901      	subs	r1, #1
   b57be:	f3c1 2107 	ubfx	r1, r1, #8, #8
   b57c2:	4620      	mov	r0, r4
   b57c4:	f7ff ff0f 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData((y + l - 1) & 0xff);
   b57c8:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
   b57cc:	4431      	add	r1, r6
   b57ce:	b2c9      	uxtb	r1, r1
   b57d0:	4620      	mov	r0, r4
   b57d2:	f7ff ff08 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendData(0x01);         // Gates scan both inside and outside of the partial window. (default) 
   b57d6:	2101      	movs	r1, #1
   b57d8:	4620      	mov	r0, r4
   b57da:	f7ff ff04 	bl	b55e6 <_ZN3Epd8SendDataEh>
    DelayMs(2);
   b57de:	2002      	movs	r0, #2
   b57e0:	f000 f8bf 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    SendCommand(DATA_START_TRANSMISSION_2);
   b57e4:	2113      	movs	r1, #19
   b57e6:	4620      	mov	r0, r4
   b57e8:	f7ff fef2 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    if (buffer_red != NULL) {
   b57ec:	b177      	cbz	r7, b580c <_ZN3Epd19SetPartialWindowRedEPKhiiii+0xbe>
        for(int i = 0; i < w  / 8 * l; i++) {
   b57ee:	2d00      	cmp	r5, #0
   b57f0:	bfb8      	it	lt
   b57f2:	3507      	addlt	r5, #7
   b57f4:	10ed      	asrs	r5, r5, #3
   b57f6:	fb08 f505 	mul.w	r5, r8, r5
   b57fa:	2600      	movs	r6, #0
   b57fc:	42b5      	cmp	r5, r6
   b57fe:	dd05      	ble.n	b580c <_ZN3Epd19SetPartialWindowRedEPKhiiii+0xbe>
            SendData(buffer_red[i]);  
   b5800:	5db9      	ldrb	r1, [r7, r6]
   b5802:	4620      	mov	r0, r4
   b5804:	f7ff feef 	bl	b55e6 <_ZN3Epd8SendDataEh>
        for(int i = 0; i < w  / 8 * l; i++) {
   b5808:	3601      	adds	r6, #1
   b580a:	e7f7      	b.n	b57fc <_ZN3Epd19SetPartialWindowRedEPKhiiii+0xae>
        }  
    }
    DelayMs(2);
   b580c:	2002      	movs	r0, #2
   b580e:	f000 f8a8 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    SendCommand(PARTIAL_OUT);  
   b5812:	4620      	mov	r0, r4
   b5814:	2192      	movs	r1, #146	; 0x92
}
   b5816:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    SendCommand(PARTIAL_OUT);  
   b581a:	f7ff bed9 	b.w	b55d0 <_ZN3Epd11SendCommandEh>

000b581e <_ZN3Epd10ClearFrameEv>:
}

/**
 * @brief: clear the frame data from the SRAM, this won't refresh the display
 */
void Epd::ClearFrame(void) {
   b581e:	b538      	push	{r3, r4, r5, lr}
    SendCommand(DATA_START_TRANSMISSION_1);           
   b5820:	2110      	movs	r1, #16
void Epd::ClearFrame(void) {
   b5822:	4604      	mov	r4, r0
    SendCommand(DATA_START_TRANSMISSION_1);           
   b5824:	f7ff fed4 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    DelayMs(2);
   b5828:	2002      	movs	r0, #2
   b582a:	f000 f89a 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    for(int i = 0; i < width / 8 * height; i++) {
   b582e:	2500      	movs	r5, #0
   b5830:	6823      	ldr	r3, [r4, #0]
   b5832:	6862      	ldr	r2, [r4, #4]
   b5834:	08db      	lsrs	r3, r3, #3
   b5836:	4353      	muls	r3, r2
   b5838:	42ab      	cmp	r3, r5
   b583a:	d905      	bls.n	b5848 <_ZN3Epd10ClearFrameEv+0x2a>
        SendData(0xFF);  
   b583c:	21ff      	movs	r1, #255	; 0xff
   b583e:	4620      	mov	r0, r4
   b5840:	f7ff fed1 	bl	b55e6 <_ZN3Epd8SendDataEh>
    for(int i = 0; i < width / 8 * height; i++) {
   b5844:	3501      	adds	r5, #1
   b5846:	e7f3      	b.n	b5830 <_ZN3Epd10ClearFrameEv+0x12>
    }  
    DelayMs(2);
   b5848:	2002      	movs	r0, #2
   b584a:	f000 f88a 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    SendCommand(DATA_START_TRANSMISSION_2);           
   b584e:	2113      	movs	r1, #19
   b5850:	4620      	mov	r0, r4
   b5852:	f7ff febd 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    DelayMs(2);
   b5856:	2002      	movs	r0, #2
   b5858:	f000 f883 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    for(int i = 0; i < width / 8 * height; i++) {
   b585c:	2500      	movs	r5, #0
   b585e:	6823      	ldr	r3, [r4, #0]
   b5860:	6862      	ldr	r2, [r4, #4]
   b5862:	08db      	lsrs	r3, r3, #3
   b5864:	4353      	muls	r3, r2
   b5866:	42ab      	cmp	r3, r5
   b5868:	d905      	bls.n	b5876 <_ZN3Epd10ClearFrameEv+0x58>
        SendData(0xFF);  
   b586a:	21ff      	movs	r1, #255	; 0xff
   b586c:	4620      	mov	r0, r4
   b586e:	f7ff feba 	bl	b55e6 <_ZN3Epd8SendDataEh>
    for(int i = 0; i < width / 8 * height; i++) {
   b5872:	3501      	adds	r5, #1
   b5874:	e7f3      	b.n	b585e <_ZN3Epd10ClearFrameEv+0x40>
    }  
    DelayMs(2);
}
   b5876:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    DelayMs(2);
   b587a:	2002      	movs	r0, #2
   b587c:	f000 b871 	b.w	b5962 <_ZN5EpdIf7DelayMsEj>

000b5880 <_ZN3Epd12DisplayFrameEv>:

/**
 * @brief: This displays the frame data from SRAM
 */
void Epd::DisplayFrame(void) {
   b5880:	b510      	push	{r4, lr}
    SendCommand(DISPLAY_REFRESH); 
   b5882:	2112      	movs	r1, #18
void Epd::DisplayFrame(void) {
   b5884:	4604      	mov	r4, r0
    SendCommand(DISPLAY_REFRESH); 
   b5886:	f7ff fea3 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    DelayMs(100);
   b588a:	2064      	movs	r0, #100	; 0x64
   b588c:	f000 f869 	bl	b5962 <_ZN5EpdIf7DelayMsEj>
    WaitUntilIdle();
   b5890:	4620      	mov	r0, r4
}
   b5892:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    WaitUntilIdle();
   b5896:	f7ff beb1 	b.w	b55fc <_ZN3Epd13WaitUntilIdleEv>

000b589a <_ZN3Epd5SleepEv>:
 * @brief: After this command is transmitted, the chip would enter the deep-sleep mode to save power. 
 *         The deep sleep mode would return to standby by hardware reset. The only one parameter is a 
 *         check code, the command would be executed if check code = 0xA5. 
 *         You can use Epd::Reset() to awaken and use Epd::Init() to initialize.
 */
void Epd::Sleep() {
   b589a:	b510      	push	{r4, lr}
    SendCommand(VCOM_AND_DATA_INTERVAL_SETTING);
   b589c:	2150      	movs	r1, #80	; 0x50
void Epd::Sleep() {
   b589e:	4604      	mov	r4, r0
    SendCommand(VCOM_AND_DATA_INTERVAL_SETTING);
   b58a0:	f7ff fe96 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendData(0xF7);     // border floating
   b58a4:	4620      	mov	r0, r4
   b58a6:	21f7      	movs	r1, #247	; 0xf7
   b58a8:	f7ff fe9d 	bl	b55e6 <_ZN3Epd8SendDataEh>
    SendCommand(POWER_OFF);
   b58ac:	2102      	movs	r1, #2
   b58ae:	4620      	mov	r0, r4
   b58b0:	f7ff fe8e 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    WaitUntilIdle();
   b58b4:	4620      	mov	r0, r4
   b58b6:	f7ff fea1 	bl	b55fc <_ZN3Epd13WaitUntilIdleEv>
    SendCommand(DEEP_SLEEP);
   b58ba:	4620      	mov	r0, r4
   b58bc:	2107      	movs	r1, #7
   b58be:	f7ff fe87 	bl	b55d0 <_ZN3Epd11SendCommandEh>
    SendData(0xA5);     // check code
   b58c2:	4620      	mov	r0, r4
   b58c4:	21a5      	movs	r1, #165	; 0xa5
}
   b58c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SendData(0xA5);     // check code
   b58ca:	f7ff be8c 	b.w	b55e6 <_ZN3Epd8SendDataEh>

000b58ce <_ZN8particle11SPISettingsD1Ev>:
  SPISettings()
  {
  }

  virtual ~SPISettings() {
  }
   b58ce:	4770      	bx	lr

000b58d0 <_ZN8particle11SPISettingsD0Ev>:
  virtual ~SPISettings() {
   b58d0:	b510      	push	{r4, lr}
  }
   b58d2:	2110      	movs	r1, #16
  virtual ~SPISettings() {
   b58d4:	4604      	mov	r4, r0
  }
   b58d6:	f7ff f83e 	bl	b4956 <_ZdlPvj>
   b58da:	4620      	mov	r0, r4
   b58dc:	bd10      	pop	{r4, pc}

000b58de <_ZN5Print6printfEPKcz>:
    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b58de:	b40e      	push	{r1, r2, r3}
   b58e0:	b503      	push	{r0, r1, lr}
   b58e2:	ab03      	add	r3, sp, #12
        auto r = this->vprintf(false, format, args);
   b58e4:	2100      	movs	r1, #0
    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b58e6:	f853 2b04 	ldr.w	r2, [r3], #4
        va_start(args, format);
   b58ea:	9301      	str	r3, [sp, #4]
        auto r = this->vprintf(false, format, args);
   b58ec:	f001 fe6b 	bl	b75c6 <_ZN5Print7vprintfEbPKcSt9__va_list>
    }
   b58f0:	b002      	add	sp, #8
   b58f2:	f85d eb04 	ldr.w	lr, [sp], #4
   b58f6:	b003      	add	sp, #12
   b58f8:	4770      	bx	lr
	...

000b58fc <_ZNK8particle11SPISettings7printToER5Print>:
  bool operator!=(const SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
   b58fc:	b573      	push	{r0, r1, r4, r5, r6, lr}
   b58fe:	4604      	mov	r4, r0
   b5900:	4608      	mov	r0, r1
  {
    if (default_ && clock_ == 0)
   b5902:	7922      	ldrb	r2, [r4, #4]
   b5904:	68a3      	ldr	r3, [r4, #8]
   b5906:	b132      	cbz	r2, b5916 <_ZNK8particle11SPISettings7printToER5Print+0x1a>
   b5908:	b9a3      	cbnz	r3, b5934 <_ZNK8particle11SPISettings7printToER5Print+0x38>
      return p.print("<SPISettings default>");
   b590a:	490b      	ldr	r1, [pc, #44]	; (b5938 <_ZNK8particle11SPISettings7printToER5Print+0x3c>)
    else
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
          bitOrder_ == MSBFIRST ? "MSB" : "LSB", (unsigned int)dataMode_);
  }
   b590c:	b002      	add	sp, #8
   b590e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return p.print("<SPISettings default>");
   b5912:	f001 be1d 	b.w	b7550 <_ZN5Print5printEPKc>
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
   b5916:	4a09      	ldr	r2, [pc, #36]	; (b593c <_ZNK8particle11SPISettings7printToER5Print+0x40>)
   b5918:	7b26      	ldrb	r6, [r4, #12]
   b591a:	4d09      	ldr	r5, [pc, #36]	; (b5940 <_ZNK8particle11SPISettings7printToER5Print+0x44>)
   b591c:	4909      	ldr	r1, [pc, #36]	; (b5944 <_ZNK8particle11SPISettings7printToER5Print+0x48>)
   b591e:	7b64      	ldrb	r4, [r4, #13]
   b5920:	2e01      	cmp	r6, #1
   b5922:	bf18      	it	ne
   b5924:	4629      	movne	r1, r5
   b5926:	e9cd 1400 	strd	r1, r4, [sp]
   b592a:	4907      	ldr	r1, [pc, #28]	; (b5948 <_ZNK8particle11SPISettings7printToER5Print+0x4c>)
   b592c:	f7ff ffd7 	bl	b58de <_ZN5Print6printfEPKcz>
  }
   b5930:	b002      	add	sp, #8
   b5932:	bd70      	pop	{r4, r5, r6, pc}
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
   b5934:	4a05      	ldr	r2, [pc, #20]	; (b594c <_ZNK8particle11SPISettings7printToER5Print+0x50>)
   b5936:	e7ef      	b.n	b5918 <_ZNK8particle11SPISettings7printToER5Print+0x1c>
   b5938:	000b879a 	.word	0x000b879a
   b593c:	000b8734 	.word	0x000b8734
   b5940:	000b8796 	.word	0x000b8796
   b5944:	000b8792 	.word	0x000b8792
   b5948:	000b87b0 	.word	0x000b87b0
   b594c:	000b8789 	.word	0x000b8789

000b5950 <_ZN5EpdIfC1Ev>:
#include "../lib/EPD4_2/src/epdif.h"

#include <spi.h>

EpdIf::EpdIf() {
};
   b5950:	4770      	bx	lr

000b5952 <_ZN5EpdIfD1Ev>:

EpdIf::~EpdIf() {
};
   b5952:	4770      	bx	lr

000b5954 <_ZN5EpdIf12DigitalWriteEii>:

void EpdIf::DigitalWrite(int pin, int value) {
    digitalWrite(pin, value);
   b5954:	b2c9      	uxtb	r1, r1
   b5956:	b280      	uxth	r0, r0
   b5958:	f002 bba9 	b.w	b80ae <digitalWrite>

000b595c <_ZN5EpdIf11DigitalReadEi>:
}

int EpdIf::DigitalRead(int pin) {
    return digitalRead(pin);
   b595c:	b280      	uxth	r0, r0
   b595e:	f002 bbbf 	b.w	b80e0 <digitalRead>

000b5962 <_ZN5EpdIf7DelayMsEj>:
}

void EpdIf::DelayMs(unsigned int delaytime) {
    delay(delaytime);
   b5962:	f001 b869 	b.w	b6a38 <delay>
	...

000b5968 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>:
namespace particle {

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
   b5968:	b513      	push	{r0, r1, r4, lr}
        static SPIClass instance(Interface);
   b596a:	4c0b      	ldr	r4, [pc, #44]	; (b5998 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x30>)
   b596c:	7821      	ldrb	r1, [r4, #0]
   b596e:	f3bf 8f5b 	dmb	ish
   b5972:	f011 0101 	ands.w	r1, r1, #1
   b5976:	d10b      	bne.n	b5990 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x28>
   b5978:	4620      	mov	r0, r4
   b597a:	9101      	str	r1, [sp, #4]
   b597c:	f7fe ffed 	bl	b495a <__cxa_guard_acquire>
   b5980:	9901      	ldr	r1, [sp, #4]
   b5982:	b128      	cbz	r0, b5990 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x28>
   b5984:	4805      	ldr	r0, [pc, #20]	; (b599c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x34>)
   b5986:	f001 fe5b 	bl	b7640 <_ZN8SPIClassC1E19hal_spi_interface_t>
   b598a:	4620      	mov	r0, r4
   b598c:	f7fe ffea 	bl	b4964 <__cxa_guard_release>
        return instance;
    }
   b5990:	4802      	ldr	r0, [pc, #8]	; (b599c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x34>)
   b5992:	b002      	add	sp, #8
   b5994:	bd10      	pop	{r4, pc}
   b5996:	bf00      	nop
   b5998:	2003e650 	.word	0x2003e650
   b599c:	2003e654 	.word	0x2003e654

000b59a0 <_ZN5EpdIf6IfInitEv>:
    digitalWrite(CS_PIN, LOW);
    SPI.transfer(data);
    digitalWrite(CS_PIN, HIGH);
}

int EpdIf::IfInit(void) {
   b59a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    pinMode(CS_PIN, OUTPUT);
   b59a2:	2101      	movs	r1, #1
   b59a4:	2008      	movs	r0, #8
   b59a6:	f002 fb71 	bl	b808c <pinMode>
    pinMode(RST_PIN, OUTPUT);
   b59aa:	2101      	movs	r1, #1
   b59ac:	2006      	movs	r0, #6
   b59ae:	f002 fb6d 	bl	b808c <pinMode>
    pinMode(DC_PIN, OUTPUT);
   b59b2:	2101      	movs	r1, #1
   b59b4:	2005      	movs	r0, #5
   b59b6:	f002 fb69 	bl	b808c <pinMode>
    pinMode(BUSY_PIN, INPUT); 
   b59ba:	2100      	movs	r1, #0
   b59bc:	2007      	movs	r0, #7
   b59be:	f002 fb65 	bl	b808c <pinMode>

    hal_spi_interface_t interface() {
         return instance().interface();
    }
    void begin() {
        instance().begin();
   b59c2:	f7ff ffd1 	bl	b5968 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
   b59c6:	f001 fe45 	bl	b7654 <_ZN8SPIClass5beginEv>
      dataMode_{dataMode}
   b59ca:	4b09      	ldr	r3, [pc, #36]	; (b59f0 <_ZN5EpdIf6IfInitEv+0x50>)
   b59cc:	9300      	str	r3, [sp, #0]
   b59ce:	4b09      	ldr	r3, [pc, #36]	; (b59f4 <_ZN5EpdIf6IfInitEv+0x54>)
   b59d0:	9302      	str	r3, [sp, #8]
   b59d2:	2400      	movs	r4, #0
   b59d4:	2301      	movs	r3, #1
   b59d6:	f8ad 300c 	strh.w	r3, [sp, #12]
   b59da:	f88d 4004 	strb.w	r4, [sp, #4]
    }
    int32_t beginTransaction() {
        return instance().beginTransaction();
    }
    int32_t beginTransaction(const particle::SPISettings& settings) {
        return instance().beginTransaction(settings);
   b59de:	f7ff ffc3 	bl	b5968 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
   b59e2:	4669      	mov	r1, sp
   b59e4:	f001 fe60 	bl	b76a8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>
    SPI.begin();
    SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
    
    return 0;
}
   b59e8:	4620      	mov	r0, r4
   b59ea:	b004      	add	sp, #16
   b59ec:	bd10      	pop	{r4, pc}
   b59ee:	bf00      	nop
   b59f0:	000b87d8 	.word	0x000b87d8
   b59f4:	001e8480 	.word	0x001e8480

000b59f8 <_ZN5EpdIf11SpiTransferEh>:
void EpdIf::SpiTransfer(unsigned char data) {
   b59f8:	b510      	push	{r4, lr}
    digitalWrite(CS_PIN, LOW);
   b59fa:	2100      	movs	r1, #0
void EpdIf::SpiTransfer(unsigned char data) {
   b59fc:	4604      	mov	r4, r0
    digitalWrite(CS_PIN, LOW);
   b59fe:	2008      	movs	r0, #8
   b5a00:	f002 fb55 	bl	b80ae <digitalWrite>
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
        return instance().transfer(data);
   b5a04:	f7ff ffb0 	bl	b5968 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
   b5a08:	4621      	mov	r1, r4
   b5a0a:	f001 febb 	bl	b7784 <_ZN8SPIClass8transferEh>
}
   b5a0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(CS_PIN, HIGH);
   b5a12:	2101      	movs	r1, #1
   b5a14:	2008      	movs	r0, #8
   b5a16:	f002 bb4a 	b.w	b80ae <digitalWrite>

000b5a1a <_ZN5PaintC1EPhii>:

#include <avr/pgmspace.h>
//#include "epdpaint.h"
#include "../lib/EPD4_2/src/epdpaint.h"

Paint::Paint(unsigned char* image, int width, int height) {
   b5a1a:	b530      	push	{r4, r5, lr}
    this->rotate = ROTATE_0;
   b5a1c:	2400      	movs	r4, #0
   b5a1e:	60c4      	str	r4, [r0, #12]
    this->image = image;
    /* 1 byte = 8 pixels, so the width should be the multiple of 8 */
    this->width = width % 8 ? width + 8 - (width % 8) : width;
   b5a20:	f012 0407 	ands.w	r4, r2, #7
    this->image = image;
   b5a24:	6001      	str	r1, [r0, #0]
    this->width = width % 8 ? width + 8 - (width % 8) : width;
   b5a26:	d008      	beq.n	b5a3a <_ZN5PaintC1EPhii+0x20>
   b5a28:	f102 0508 	add.w	r5, r2, #8
   b5a2c:	4252      	negs	r2, r2
   b5a2e:	f002 0107 	and.w	r1, r2, #7
   b5a32:	4622      	mov	r2, r4
   b5a34:	bf58      	it	pl
   b5a36:	424a      	negpl	r2, r1
   b5a38:	1aaa      	subs	r2, r5, r2
    this->height = height;
   b5a3a:	e9c0 2301 	strd	r2, r3, [r0, #4]
}
   b5a3e:	bd30      	pop	{r4, r5, pc}

000b5a40 <_ZN5PaintD1Ev>:

Paint::~Paint() {
}
   b5a40:	4770      	bx	lr

000b5a42 <_ZN5Paint17DrawAbsolutePixelEiii>:
/**
 *  @brief: this draws a pixel by absolute coordinates.
 *          this function won't be affected by the rotate parameter.
 */
void Paint::DrawAbsolutePixel(int x, int y, int colored) {
    if (x < 0 || x >= this->width || y < 0 || y >= this->height) {
   b5a42:	2900      	cmp	r1, #0
void Paint::DrawAbsolutePixel(int x, int y, int colored) {
   b5a44:	b530      	push	{r4, r5, lr}
    if (x < 0 || x >= this->width || y < 0 || y >= this->height) {
   b5a46:	db15      	blt.n	b5a74 <_ZN5Paint17DrawAbsolutePixelEiii+0x32>
   b5a48:	6844      	ldr	r4, [r0, #4]
   b5a4a:	428c      	cmp	r4, r1
   b5a4c:	dd12      	ble.n	b5a74 <_ZN5Paint17DrawAbsolutePixelEiii+0x32>
   b5a4e:	2a00      	cmp	r2, #0
   b5a50:	db10      	blt.n	b5a74 <_ZN5Paint17DrawAbsolutePixelEiii+0x32>
   b5a52:	6885      	ldr	r5, [r0, #8]
   b5a54:	4295      	cmp	r5, r2
   b5a56:	dd0d      	ble.n	b5a74 <_ZN5Paint17DrawAbsolutePixelEiii+0x32>
        return;
    }
    if (IF_INVERT_COLOR) {
        if (colored) {
            image[(x + y * this->width) / 8] |= 0x80 >> (x % 8);
   b5a58:	fb02 1204 	mla	r2, r2, r4, r1
   b5a5c:	6805      	ldr	r5, [r0, #0]
   b5a5e:	10d2      	asrs	r2, r2, #3
   b5a60:	f001 0107 	and.w	r1, r1, #7
   b5a64:	2480      	movs	r4, #128	; 0x80
   b5a66:	fa44 f101 	asr.w	r1, r4, r1
   b5a6a:	56a8      	ldrsb	r0, [r5, r2]
   b5a6c:	b249      	sxtb	r1, r1
        if (colored) {
   b5a6e:	b113      	cbz	r3, b5a76 <_ZN5Paint17DrawAbsolutePixelEiii+0x34>
            image[(x + y * this->width) / 8] |= 0x80 >> (x % 8);
   b5a70:	4308      	orrs	r0, r1
        } else {
            image[(x + y * this->width) / 8] &= ~(0x80 >> (x % 8));
   b5a72:	54a8      	strb	r0, [r5, r2]
            image[(x + y * this->width) / 8] &= ~(0x80 >> (x % 8));
        } else {
            image[(x + y * this->width) / 8] |= 0x80 >> (x % 8);
        }
    }
}
   b5a74:	bd30      	pop	{r4, r5, pc}
            image[(x + y * this->width) / 8] &= ~(0x80 >> (x % 8));
   b5a76:	ea20 0001 	bic.w	r0, r0, r1
   b5a7a:	e7fa      	b.n	b5a72 <_ZN5Paint17DrawAbsolutePixelEiii+0x30>

000b5a7c <_ZN5Paint5ClearEi>:
void Paint::Clear(int colored) {
   b5a7c:	b570      	push	{r4, r5, r6, lr}
   b5a7e:	460b      	mov	r3, r1
   b5a80:	4604      	mov	r4, r0
    for (int x = 0; x < this->width; x++) {
   b5a82:	2500      	movs	r5, #0
   b5a84:	6862      	ldr	r2, [r4, #4]
   b5a86:	42aa      	cmp	r2, r5
   b5a88:	dd0c      	ble.n	b5aa4 <_ZN5Paint5ClearEi+0x28>
        for (int y = 0; y < this->height; y++) {
   b5a8a:	2600      	movs	r6, #0
   b5a8c:	68a2      	ldr	r2, [r4, #8]
   b5a8e:	42b2      	cmp	r2, r6
   b5a90:	dd06      	ble.n	b5aa0 <_ZN5Paint5ClearEi+0x24>
            DrawAbsolutePixel(x, y, colored);
   b5a92:	4632      	mov	r2, r6
   b5a94:	4629      	mov	r1, r5
   b5a96:	4620      	mov	r0, r4
   b5a98:	f7ff ffd3 	bl	b5a42 <_ZN5Paint17DrawAbsolutePixelEiii>
        for (int y = 0; y < this->height; y++) {
   b5a9c:	3601      	adds	r6, #1
   b5a9e:	e7f5      	b.n	b5a8c <_ZN5Paint5ClearEi+0x10>
    for (int x = 0; x < this->width; x++) {
   b5aa0:	3501      	adds	r5, #1
   b5aa2:	e7ef      	b.n	b5a84 <_ZN5Paint5ClearEi+0x8>
}
   b5aa4:	bd70      	pop	{r4, r5, r6, pc}

000b5aa6 <_ZN5Paint8GetImageEv>:
/**
 *  @brief: Getters and Setters
 */
unsigned char* Paint::GetImage(void) {
    return this->image;
}
   b5aa6:	6800      	ldr	r0, [r0, #0]
   b5aa8:	4770      	bx	lr

000b5aaa <_ZN5Paint8GetWidthEv>:

int Paint::GetWidth(void) {
    return this->width;
}
   b5aaa:	6840      	ldr	r0, [r0, #4]
   b5aac:	4770      	bx	lr

000b5aae <_ZN5Paint9GetHeightEv>:
    this->width = width % 8 ? width + 8 - (width % 8) : width;
}

int Paint::GetHeight(void) {
    return this->height;
}
   b5aae:	6880      	ldr	r0, [r0, #8]
   b5ab0:	4770      	bx	lr

000b5ab2 <_ZN5Paint9SetRotateEi>:
int Paint::GetRotate(void) {
    return this->rotate;
}

void Paint::SetRotate(int rotate){
    this->rotate = rotate;
   b5ab2:	60c1      	str	r1, [r0, #12]
}
   b5ab4:	4770      	bx	lr

000b5ab6 <_ZN5Paint9DrawPixelEiii>:

/**
 *  @brief: this draws a pixel by the coordinates
 */
void Paint::DrawPixel(int x, int y, int colored) {
   b5ab6:	b4f0      	push	{r4, r5, r6, r7}
    int point_temp;
    if (this->rotate == ROTATE_0) {
   b5ab8:	68c7      	ldr	r7, [r0, #12]
void Paint::DrawPixel(int x, int y, int colored) {
   b5aba:	460d      	mov	r5, r1
   b5abc:	4614      	mov	r4, r2
    if (this->rotate == ROTATE_0) {
   b5abe:	b967      	cbnz	r7, b5ada <_ZN5Paint9DrawPixelEiii+0x24>
        if(x < 0 || x >= this->width || y < 0 || y >= this->height) {
   b5ac0:	2900      	cmp	r1, #0
   b5ac2:	db37      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5ac4:	6847      	ldr	r7, [r0, #4]
   b5ac6:	428f      	cmp	r7, r1
   b5ac8:	dd34      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5aca:	2a00      	cmp	r2, #0
   b5acc:	db32      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5ace:	6885      	ldr	r5, [r0, #8]
   b5ad0:	4295      	cmp	r5, r2
   b5ad2:	dd2f      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
        point_temp = x;
        x = y;
        y = this->height - point_temp;
        DrawAbsolutePixel(x, y, colored);
    }
}
   b5ad4:	bcf0      	pop	{r4, r5, r6, r7}
        DrawAbsolutePixel(x, y, colored);
   b5ad6:	f7ff bfb4 	b.w	b5a42 <_ZN5Paint17DrawAbsolutePixelEiii>
    } else if (this->rotate == ROTATE_90) {
   b5ada:	2f01      	cmp	r7, #1
   b5adc:	d10c      	bne.n	b5af8 <_ZN5Paint9DrawPixelEiii+0x42>
        if(x < 0 || x >= this->height || y < 0 || y >= this->width) {
   b5ade:	2900      	cmp	r1, #0
   b5ae0:	db28      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5ae2:	6882      	ldr	r2, [r0, #8]
   b5ae4:	428a      	cmp	r2, r1
   b5ae6:	dd25      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5ae8:	2c00      	cmp	r4, #0
   b5aea:	db23      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5aec:	6841      	ldr	r1, [r0, #4]
   b5aee:	42a1      	cmp	r1, r4
   b5af0:	dd20      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
        DrawAbsolutePixel(x, y, colored);
   b5af2:	462a      	mov	r2, r5
   b5af4:	1b09      	subs	r1, r1, r4
   b5af6:	e7ed      	b.n	b5ad4 <_ZN5Paint9DrawPixelEiii+0x1e>
    } else if (this->rotate == ROTATE_180) {
   b5af8:	2f02      	cmp	r7, #2
   b5afa:	d10c      	bne.n	b5b16 <_ZN5Paint9DrawPixelEiii+0x60>
        if(x < 0 || x >= this->width || y < 0 || y >= this->height) {
   b5afc:	2900      	cmp	r1, #0
   b5afe:	db19      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b00:	6841      	ldr	r1, [r0, #4]
   b5b02:	42a9      	cmp	r1, r5
   b5b04:	dd16      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b06:	2a00      	cmp	r2, #0
   b5b08:	db14      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b0a:	6882      	ldr	r2, [r0, #8]
   b5b0c:	42a2      	cmp	r2, r4
   b5b0e:	dd11      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
        DrawAbsolutePixel(x, y, colored);
   b5b10:	1b12      	subs	r2, r2, r4
   b5b12:	1b49      	subs	r1, r1, r5
   b5b14:	e7de      	b.n	b5ad4 <_ZN5Paint9DrawPixelEiii+0x1e>
    } else if (this->rotate == ROTATE_270) {
   b5b16:	2f03      	cmp	r7, #3
   b5b18:	d10c      	bne.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
        if(x < 0 || x >= this->height || y < 0 || y >= this->width) {
   b5b1a:	2900      	cmp	r1, #0
   b5b1c:	db0a      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b1e:	6882      	ldr	r2, [r0, #8]
   b5b20:	428a      	cmp	r2, r1
   b5b22:	dd07      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b24:	2c00      	cmp	r4, #0
   b5b26:	db05      	blt.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
   b5b28:	6841      	ldr	r1, [r0, #4]
   b5b2a:	42a1      	cmp	r1, r4
   b5b2c:	dd02      	ble.n	b5b34 <_ZN5Paint9DrawPixelEiii+0x7e>
        DrawAbsolutePixel(x, y, colored);
   b5b2e:	1b52      	subs	r2, r2, r5
   b5b30:	4621      	mov	r1, r4
   b5b32:	e7cf      	b.n	b5ad4 <_ZN5Paint9DrawPixelEiii+0x1e>
}
   b5b34:	bcf0      	pop	{r4, r5, r6, r7}
   b5b36:	4770      	bx	lr

000b5b38 <_ZN5Paint10DrawCharAtEiicP5sFONTi>:

/**
 *  @brief: this draws a charactor on the frame buffer but not refresh
 */
void Paint::DrawCharAt(int x, int y, char ascii_char, sFONT* font, int colored) {
   b5b38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b5b3c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    int i, j;
    unsigned int char_offset = (ascii_char - ' ') * font->Height * (font->Width / 8 + (font->Width % 8 ? 1 : 0));
   b5b3e:	88ac      	ldrh	r4, [r5, #4]
void Paint::DrawCharAt(int x, int y, char ascii_char, sFONT* font, int colored) {
   b5b40:	4691      	mov	r9, r2
    unsigned int char_offset = (ascii_char - ' ') * font->Height * (font->Width / 8 + (font->Width % 8 ? 1 : 0));
   b5b42:	f014 0207 	ands.w	r2, r4, #7
   b5b46:	bf18      	it	ne
   b5b48:	2201      	movne	r2, #1
   b5b4a:	eb02 02d4 	add.w	r2, r2, r4, lsr #3
   b5b4e:	88ec      	ldrh	r4, [r5, #6]
   b5b50:	3b20      	subs	r3, #32
   b5b52:	4363      	muls	r3, r4
    const unsigned char* ptr = &font->table[char_offset];
   b5b54:	682c      	ldr	r4, [r5, #0]
void Paint::DrawCharAt(int x, int y, char ascii_char, sFONT* font, int colored) {
   b5b56:	4688      	mov	r8, r1
    const unsigned char* ptr = &font->table[char_offset];
   b5b58:	fb03 4402 	mla	r4, r3, r2, r4

    for (j = 0; j < font->Height; j++) {
   b5b5c:	2700      	movs	r7, #0
        for (i = 0; i < font->Width; i++) {
            if (pgm_read_byte(ptr) & (0x80 >> (i % 8))) {
   b5b5e:	f04f 0b80 	mov.w	fp, #128	; 0x80
    for (j = 0; j < font->Height; j++) {
   b5b62:	88eb      	ldrh	r3, [r5, #6]
   b5b64:	42bb      	cmp	r3, r7
   b5b66:	dd20      	ble.n	b5baa <_ZN5Paint10DrawCharAtEiicP5sFONTi+0x72>
        for (i = 0; i < font->Width; i++) {
   b5b68:	2600      	movs	r6, #0
                DrawPixel(x + i, y + j, colored);
   b5b6a:	eb09 0207 	add.w	r2, r9, r7
        for (i = 0; i < font->Width; i++) {
   b5b6e:	88ab      	ldrh	r3, [r5, #4]
   b5b70:	42b3      	cmp	r3, r6
   b5b72:	dd15      	ble.n	b5ba0 <_ZN5Paint10DrawCharAtEiicP5sFONTi+0x68>
            if (pgm_read_byte(ptr) & (0x80 >> (i % 8))) {
   b5b74:	7821      	ldrb	r1, [r4, #0]
   b5b76:	f006 0a07 	and.w	sl, r6, #7
   b5b7a:	fa4b f30a 	asr.w	r3, fp, sl
   b5b7e:	4219      	tst	r1, r3
   b5b80:	d008      	beq.n	b5b94 <_ZN5Paint10DrawCharAtEiicP5sFONTi+0x5c>
                DrawPixel(x + i, y + j, colored);
   b5b82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   b5b84:	9201      	str	r2, [sp, #4]
   b5b86:	eb06 0108 	add.w	r1, r6, r8
   b5b8a:	9000      	str	r0, [sp, #0]
   b5b8c:	f7ff ff93 	bl	b5ab6 <_ZN5Paint9DrawPixelEiii>
   b5b90:	e9dd 0200 	ldrd	r0, r2, [sp]
            }
            if (i % 8 == 7) {
   b5b94:	f1ba 0f07 	cmp.w	sl, #7
                ptr++;
   b5b98:	bf08      	it	eq
   b5b9a:	3401      	addeq	r4, #1
        for (i = 0; i < font->Width; i++) {
   b5b9c:	3601      	adds	r6, #1
   b5b9e:	e7e6      	b.n	b5b6e <_ZN5Paint10DrawCharAtEiicP5sFONTi+0x36>
            }
        }
        if (font->Width % 8 != 0) {
   b5ba0:	075b      	lsls	r3, r3, #29
            ptr++;
   b5ba2:	bf18      	it	ne
   b5ba4:	3401      	addne	r4, #1
    for (j = 0; j < font->Height; j++) {
   b5ba6:	3701      	adds	r7, #1
   b5ba8:	e7db      	b.n	b5b62 <_ZN5Paint10DrawCharAtEiicP5sFONTi+0x2a>
        }
    }
}
   b5baa:	b003      	add	sp, #12
   b5bac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000b5bb0 <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi>:

/**
*  @brief: this displays a string on the frame buffer but not refresh
*/
void Paint::DrawStringAt(int x, int y, const char* text, sFONT* font, int colored) {
   b5bb0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   b5bb4:	9f08      	ldr	r7, [sp, #32]
   b5bb6:	4606      	mov	r6, r0
   b5bb8:	460c      	mov	r4, r1
   b5bba:	4690      	mov	r8, r2
   b5bbc:	1e5d      	subs	r5, r3, #1
    const char* p_text = text;
    unsigned int counter = 0;
    int refcolumn = x;
    
    /* Send the string character by character on EPD */
    while (*p_text != 0) {
   b5bbe:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   b5bc2:	b153      	cbz	r3, b5bda <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi+0x2a>
        /* Display one character on EPD */
        DrawCharAt(refcolumn, y, *p_text, font, colored);
   b5bc4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   b5bc6:	4621      	mov	r1, r4
   b5bc8:	e9cd 7200 	strd	r7, r2, [sp]
   b5bcc:	4630      	mov	r0, r6
   b5bce:	4642      	mov	r2, r8
   b5bd0:	f7ff ffb2 	bl	b5b38 <_ZN5Paint10DrawCharAtEiicP5sFONTi>
        /* Decrement the column position by 16 */
        refcolumn += font->Width;
   b5bd4:	88bb      	ldrh	r3, [r7, #4]
   b5bd6:	441c      	add	r4, r3
    while (*p_text != 0) {
   b5bd8:	e7f1      	b.n	b5bbe <_ZN5Paint12DrawStringAtEiiPKcP5sFONTi+0xe>
        /* Point on the next character */
        p_text++;
        counter++;
    }
}
   b5bda:	b002      	add	sp, #8
   b5bdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000b5be0 <_ZN5Paint18DrawHorizontalLineEiiii>:
}

/**
*  @brief: this draws a horizontal line on the frame buffer
*/
void Paint::DrawHorizontalLine(int x, int y, int line_width, int colored) {
   b5be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b5be2:	4606      	mov	r6, r0
   b5be4:	4617      	mov	r7, r2
    int i;
    for (i = x; i < x + line_width; i++) {
   b5be6:	460c      	mov	r4, r1
   b5be8:	18cd      	adds	r5, r1, r3
   b5bea:	42a5      	cmp	r5, r4
   b5bec:	dd07      	ble.n	b5bfe <_ZN5Paint18DrawHorizontalLineEiiii+0x1e>
        DrawPixel(i, y, colored);
   b5bee:	4621      	mov	r1, r4
   b5bf0:	9b06      	ldr	r3, [sp, #24]
   b5bf2:	463a      	mov	r2, r7
   b5bf4:	4630      	mov	r0, r6
   b5bf6:	f7ff ff5e 	bl	b5ab6 <_ZN5Paint9DrawPixelEiii>
    for (i = x; i < x + line_width; i++) {
   b5bfa:	3401      	adds	r4, #1
   b5bfc:	e7f5      	b.n	b5bea <_ZN5Paint18DrawHorizontalLineEiiii+0xa>
    }
}
   b5bfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b5c00 <_ZN5Paint16DrawVerticalLineEiiii>:

/**
*  @brief: this draws a vertical line on the frame buffer
*/
void Paint::DrawVerticalLine(int x, int y, int line_height, int colored) {
   b5c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b5c02:	4606      	mov	r6, r0
   b5c04:	460f      	mov	r7, r1
    int i;
    for (i = y; i < y + line_height; i++) {
   b5c06:	4614      	mov	r4, r2
   b5c08:	18d5      	adds	r5, r2, r3
   b5c0a:	42a5      	cmp	r5, r4
   b5c0c:	dd07      	ble.n	b5c1e <_ZN5Paint16DrawVerticalLineEiiii+0x1e>
        DrawPixel(x, i, colored);
   b5c0e:	4622      	mov	r2, r4
   b5c10:	9b06      	ldr	r3, [sp, #24]
   b5c12:	4639      	mov	r1, r7
   b5c14:	4630      	mov	r0, r6
   b5c16:	f7ff ff4e 	bl	b5ab6 <_ZN5Paint9DrawPixelEiii>
    for (i = y; i < y + line_height; i++) {
   b5c1a:	3401      	adds	r4, #1
   b5c1c:	e7f5      	b.n	b5c0a <_ZN5Paint16DrawVerticalLineEiiii+0xa>
    }
}
   b5c1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b5c20 <_ZN5Paint13DrawRectangleEiiiii>:

/**
*  @brief: this draws a rectangle
*/
void Paint::DrawRectangle(int x0, int y0, int x1, int y1, int colored) {
   b5c20:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   b5c24:	460f      	mov	r7, r1
   b5c26:	e9dd 480a 	ldrd	r4, r8, [sp, #40]	; 0x28
   b5c2a:	42bb      	cmp	r3, r7
   b5c2c:	4619      	mov	r1, r3
   b5c2e:	bfa8      	it	ge
   b5c30:	4639      	movge	r1, r7
    int min_x, min_y, max_x, max_y;
    min_x = x1 > x0 ? x0 : x1;
    max_x = x1 > x0 ? x1 : x0;
   b5c32:	42bb      	cmp	r3, r7
   b5c34:	bfb8      	it	lt
   b5c36:	463b      	movlt	r3, r7
   b5c38:	4294      	cmp	r4, r2
   b5c3a:	4627      	mov	r7, r4
   b5c3c:	461d      	mov	r5, r3
    min_y = y1 > y0 ? y0 : y1;
   b5c3e:	bfa8      	it	ge
   b5c40:	4617      	movge	r7, r2
    max_y = y1 > y0 ? y1 : y0;
    
    DrawHorizontalLine(min_x, min_y, max_x - min_x + 1, colored);
   b5c42:	1a5b      	subs	r3, r3, r1
   b5c44:	4294      	cmp	r4, r2
   b5c46:	bfb8      	it	lt
   b5c48:	4614      	movlt	r4, r2
void Paint::DrawRectangle(int x0, int y0, int x1, int y1, int colored) {
   b5c4a:	4606      	mov	r6, r0
    DrawHorizontalLine(min_x, min_y, max_x - min_x + 1, colored);
   b5c4c:	3301      	adds	r3, #1
   b5c4e:	463a      	mov	r2, r7
   b5c50:	f8cd 8000 	str.w	r8, [sp]
   b5c54:	9303      	str	r3, [sp, #12]
   b5c56:	9102      	str	r1, [sp, #8]
   b5c58:	f7ff ffc2 	bl	b5be0 <_ZN5Paint18DrawHorizontalLineEiiii>
    DrawHorizontalLine(min_x, max_y, max_x - min_x + 1, colored);
   b5c5c:	9b03      	ldr	r3, [sp, #12]
   b5c5e:	9902      	ldr	r1, [sp, #8]
   b5c60:	f8cd 8000 	str.w	r8, [sp]
   b5c64:	4622      	mov	r2, r4
   b5c66:	4630      	mov	r0, r6
   b5c68:	9103      	str	r1, [sp, #12]
   b5c6a:	f7ff ffb9 	bl	b5be0 <_ZN5Paint18DrawHorizontalLineEiiii>
    DrawVerticalLine(min_x, min_y, max_y - min_y + 1, colored);
   b5c6e:	1be3      	subs	r3, r4, r7
   b5c70:	9903      	ldr	r1, [sp, #12]
   b5c72:	f8cd 8000 	str.w	r8, [sp]
   b5c76:	3301      	adds	r3, #1
   b5c78:	463a      	mov	r2, r7
   b5c7a:	4630      	mov	r0, r6
   b5c7c:	9302      	str	r3, [sp, #8]
   b5c7e:	f7ff ffbf 	bl	b5c00 <_ZN5Paint16DrawVerticalLineEiiii>
    DrawVerticalLine(max_x, min_y, max_y - min_y + 1, colored);
   b5c82:	9b02      	ldr	r3, [sp, #8]
   b5c84:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
   b5c88:	463a      	mov	r2, r7
   b5c8a:	4629      	mov	r1, r5
   b5c8c:	4630      	mov	r0, r6
}
   b5c8e:	b004      	add	sp, #16
   b5c90:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    DrawVerticalLine(max_x, min_y, max_y - min_y + 1, colored);
   b5c94:	f7ff bfb4 	b.w	b5c00 <_ZN5Paint16DrawVerticalLineEiiii>

000b5c98 <_ZN5Paint19DrawFilledRectangleEiiiii>:

/**
*  @brief: this draws a filled rectangle
*/
void Paint::DrawFilledRectangle(int x0, int y0, int x1, int y1, int colored) {
   b5c98:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   b5c9c:	428b      	cmp	r3, r1
   b5c9e:	4604      	mov	r4, r0
   b5ca0:	9808      	ldr	r0, [sp, #32]
   b5ca2:	461e      	mov	r6, r3
   b5ca4:	bfa8      	it	ge
   b5ca6:	460e      	movge	r6, r1
    int min_x, min_y, max_x, max_y;
    int i;
    min_x = x1 > x0 ? x0 : x1;
    max_x = x1 > x0 ? x1 : x0;
   b5ca8:	428b      	cmp	r3, r1
   b5caa:	bfb8      	it	lt
   b5cac:	460b      	movlt	r3, r1
   b5cae:	4290      	cmp	r0, r2
   b5cb0:	4680      	mov	r8, r0
   b5cb2:	bfa8      	it	ge
   b5cb4:	4690      	movge	r8, r2
    min_y = y1 > y0 ? y0 : y1;
    max_y = y1 > y0 ? y1 : y0;
    
    for (i = min_x; i <= max_x; i++) {
      DrawVerticalLine(i, min_y, max_y - min_y + 1, colored);
   b5cb6:	4290      	cmp	r0, r2
   b5cb8:	bfac      	ite	ge
   b5cba:	ebc8 0700 	rsbge	r7, r8, r0
   b5cbe:	ebc8 0702 	rsblt	r7, r8, r2
   b5cc2:	461d      	mov	r5, r3
   b5cc4:	3701      	adds	r7, #1
    for (i = min_x; i <= max_x; i++) {
   b5cc6:	42ae      	cmp	r6, r5
   b5cc8:	dc09      	bgt.n	b5cde <_ZN5Paint19DrawFilledRectangleEiiiii+0x46>
      DrawVerticalLine(i, min_y, max_y - min_y + 1, colored);
   b5cca:	9b09      	ldr	r3, [sp, #36]	; 0x24
   b5ccc:	9300      	str	r3, [sp, #0]
   b5cce:	4631      	mov	r1, r6
   b5cd0:	463b      	mov	r3, r7
   b5cd2:	4642      	mov	r2, r8
   b5cd4:	4620      	mov	r0, r4
   b5cd6:	f7ff ff93 	bl	b5c00 <_ZN5Paint16DrawVerticalLineEiiii>
    for (i = min_x; i <= max_x; i++) {
   b5cda:	3601      	adds	r6, #1
   b5cdc:	e7f3      	b.n	b5cc6 <_ZN5Paint19DrawFilledRectangleEiiiii+0x2e>
    }
}
   b5cde:	b002      	add	sp, #8
   b5ce0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000b5ce4 <_ZN7TwoWire5writeEi.isra.0>:
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
   b5ce4:	6803      	ldr	r3, [r0, #0]
   b5ce6:	b2c9      	uxtb	r1, r1
   b5ce8:	689b      	ldr	r3, [r3, #8]
   b5cea:	4718      	bx	r3

000b5cec <_ZN8max1720xC1Ev>:
 */

#include "../lib/MAX17201/src/max1720x.h"

// Initializes variables and the Wire library
max1720x::max1720x() { 
   b5cec:	b510      	push	{r4, lr}
   b5cee:	4604      	mov	r4, r0
    Wire.begin(); 
   b5cf0:	f002 fa24 	bl	b813c <_Z19__fetch_global_Wirev>
   b5cf4:	f001 fa92 	bl	b721c <_ZN7TwoWire5beginEv>
}
   b5cf8:	4620      	mov	r0, r4
   b5cfa:	bd10      	pop	{r4, pc}

000b5cfc <_ZN8max1720x10getVoltageEv>:

// Returns a measurement of the voltage of the connected LiIon Polymer battery
double max1720x::getVoltage()
{
   b5cfc:	b510      	push	{r4, lr}
	Wire.beginTransmission(MAX1720X_ADDR);
   b5cfe:	f002 fa1d 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d02:	2136      	movs	r1, #54	; 0x36
   b5d04:	f001 fac0 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_VCELL_ADDR);
   b5d08:	f002 fa18 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d0c:	2109      	movs	r1, #9
   b5d0e:	f7ff ffe9 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false);
   b5d12:	f002 fa13 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d16:	2100      	movs	r1, #0
   b5d18:	f001 fab9 	bl	b728e <_ZN7TwoWire15endTransmissionEh>
	Wire.requestFrom(MAX1720X_ADDR, (int)2,HIGH); //send stop
   b5d1c:	f002 fa0e 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d20:	2202      	movs	r2, #2
   b5d22:	2136      	movs	r1, #54	; 0x36
   b5d24:	2301      	movs	r3, #1
   b5d26:	f001 fa96 	bl	b7256 <_ZN7TwoWire11requestFromEhjh>
    uint16_t combined = Wire.read()|(Wire.read()<<8); // LSB or-ed with MSB
   b5d2a:	f002 fa07 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d2e:	6803      	ldr	r3, [r0, #0]
   b5d30:	695b      	ldr	r3, [r3, #20]
   b5d32:	4798      	blx	r3
   b5d34:	4604      	mov	r4, r0
   b5d36:	f002 fa01 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d3a:	6803      	ldr	r3, [r0, #0]
   b5d3c:	695b      	ldr	r3, [r3, #20]
   b5d3e:	4798      	blx	r3
   b5d40:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
    double voltage = combined; //combine registers
   b5d44:	b280      	uxth	r0, r0
   b5d46:	f7fe faad 	bl	b42a4 <__aeabi_ui2d>
    return voltage*0.078125; // //calculate actual value and return in mV
   b5d4a:	4b03      	ldr	r3, [pc, #12]	; (b5d58 <_ZN8max1720x10getVoltageEv+0x5c>)
   b5d4c:	2200      	movs	r2, #0
   b5d4e:	f7fe fb23 	bl	b4398 <__aeabi_dmul>
}
   b5d52:	ec41 0b10 	vmov	d0, r0, r1
   b5d56:	bd10      	pop	{r4, pc}
   b5d58:	3fb40000 	.word	0x3fb40000

000b5d5c <_ZN8max1720x14getTemperatureEv>:
    return CoulombsQL; // //calculate actual value and return in mA - still TO DO
}


double max1720x::getTemperature()
{
   b5d5c:	b510      	push	{r4, lr}
	Wire.beginTransmission(MAX1720X_ADDR);
   b5d5e:	f002 f9ed 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d62:	2136      	movs	r1, #54	; 0x36
   b5d64:	f001 fa90 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_TEMP_ADDR);
   b5d68:	f002 f9e8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d6c:	2108      	movs	r1, #8
   b5d6e:	f7ff ffb9 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false);
   b5d72:	f002 f9e3 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d76:	2100      	movs	r1, #0
   b5d78:	f001 fa89 	bl	b728e <_ZN7TwoWire15endTransmissionEh>
	Wire.requestFrom(MAX1720X_ADDR, (int)2,HIGH); //send stop
   b5d7c:	f002 f9de 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d80:	2202      	movs	r2, #2
   b5d82:	2136      	movs	r1, #54	; 0x36
   b5d84:	2301      	movs	r3, #1
   b5d86:	f001 fa66 	bl	b7256 <_ZN7TwoWire11requestFromEhjh>
    int16_t combined = Wire.read()|(Wire.read()<<8); // LSB or-ed with MSB
   b5d8a:	f002 f9d7 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d8e:	6803      	ldr	r3, [r0, #0]
   b5d90:	695b      	ldr	r3, [r3, #20]
   b5d92:	4798      	blx	r3
   b5d94:	4604      	mov	r4, r0
   b5d96:	f002 f9d1 	bl	b813c <_Z19__fetch_global_Wirev>
   b5d9a:	6803      	ldr	r3, [r0, #0]
   b5d9c:	695b      	ldr	r3, [r3, #20]
   b5d9e:	4798      	blx	r3
   b5da0:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
    double temperature = (double)combined/256;
   b5da4:	b200      	sxth	r0, r0
   b5da6:	f7fe fa8d 	bl	b42c4 <__aeabi_i2d>
   b5daa:	4b03      	ldr	r3, [pc, #12]	; (b5db8 <_ZN8max1720x14getTemperatureEv+0x5c>)
   b5dac:	2200      	movs	r2, #0
   b5dae:	f7fe faf3 	bl	b4398 <__aeabi_dmul>
    return temperature;
}
   b5db2:	ec41 0b10 	vmov	d0, r0, r1
   b5db6:	bd10      	pop	{r4, pc}
   b5db8:	3f700000 	.word	0x3f700000

000b5dbc <_ZN8max1720x6getSOCEv>:

// Returns the relative state of charge of the connected LiIon Polymer battery
// as a percentage of the full capacity w/ resolution 1/256%
double max1720x::getSOC()
{
   b5dbc:	b510      	push	{r4, lr}
	Wire.beginTransmission(MAX1720X_ADDR);
   b5dbe:	f002 f9bd 	bl	b813c <_Z19__fetch_global_Wirev>
   b5dc2:	2136      	movs	r1, #54	; 0x36
   b5dc4:	f001 fa60 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_REPSOC_ADDR);
   b5dc8:	f002 f9b8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5dcc:	2106      	movs	r1, #6
   b5dce:	f7ff ff89 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false);
   b5dd2:	f002 f9b3 	bl	b813c <_Z19__fetch_global_Wirev>
   b5dd6:	2100      	movs	r1, #0
   b5dd8:	f001 fa59 	bl	b728e <_ZN7TwoWire15endTransmissionEh>
	Wire.requestFrom(MAX1720X_ADDR, (int)2);
   b5ddc:	f002 f9ae 	bl	b813c <_Z19__fetch_global_Wirev>
   b5de0:	2202      	movs	r2, #2
   b5de2:	2136      	movs	r1, #54	; 0x36
   b5de4:	f001 fa49 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    uint16_t combined = Wire.read()|(Wire.read()<<8); // LSB or-ed with MSB
   b5de8:	f002 f9a8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5dec:	6803      	ldr	r3, [r0, #0]
   b5dee:	695b      	ldr	r3, [r3, #20]
   b5df0:	4798      	blx	r3
   b5df2:	4604      	mov	r4, r0
   b5df4:	f002 f9a2 	bl	b813c <_Z19__fetch_global_Wirev>
   b5df8:	6803      	ldr	r3, [r0, #0]
   b5dfa:	695b      	ldr	r3, [r3, #20]
   b5dfc:	4798      	blx	r3
   b5dfe:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
    double soc = combined; //combine registers
   b5e02:	b280      	uxth	r0, r0
   b5e04:	f7fe fa4e 	bl	b42a4 <__aeabi_ui2d>
	return soc/256; //calculate actual value and return in %
   b5e08:	4b03      	ldr	r3, [pc, #12]	; (b5e18 <_ZN8max1720x6getSOCEv+0x5c>)
   b5e0a:	2200      	movs	r2, #0
   b5e0c:	f7fe fac4 	bl	b4398 <__aeabi_dmul>
}
   b5e10:	ec41 0b10 	vmov	d0, r0, r1
   b5e14:	bd10      	pop	{r4, pc}
   b5e16:	bf00      	nop
   b5e18:	3f700000 	.word	0x3f700000
   b5e1c:	00000000 	.word	0x00000000

000b5e20 <_ZN8max1720x10getCurrentEv>:

double max1720x::getCurrent()
{
   b5e20:	b510      	push	{r4, lr}
	Wire.beginTransmission(MAX1720X_ADDR);
   b5e22:	f002 f98b 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e26:	2136      	movs	r1, #54	; 0x36
   b5e28:	f001 fa2e 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_CURENT_ADDR);
   b5e2c:	f002 f986 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e30:	210a      	movs	r1, #10
   b5e32:	f7ff ff57 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false);
   b5e36:	f002 f981 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e3a:	2100      	movs	r1, #0
   b5e3c:	f001 fa27 	bl	b728e <_ZN7TwoWire15endTransmissionEh>
	Wire.requestFrom(MAX1720X_ADDR, (int)2,HIGH); //send stop
   b5e40:	f002 f97c 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e44:	2202      	movs	r2, #2
   b5e46:	2136      	movs	r1, #54	; 0x36
   b5e48:	2301      	movs	r3, #1
   b5e4a:	f001 fa04 	bl	b7256 <_ZN7TwoWire11requestFromEhjh>
    int16_t combined = Wire.read()|(Wire.read()<<8); // LSB or-ed with MSB
   b5e4e:	f002 f975 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e52:	6803      	ldr	r3, [r0, #0]
   b5e54:	695b      	ldr	r3, [r3, #20]
   b5e56:	4798      	blx	r3
   b5e58:	4604      	mov	r4, r0
   b5e5a:	f002 f96f 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e5e:	6803      	ldr	r3, [r0, #0]
   b5e60:	695b      	ldr	r3, [r3, #20]
   b5e62:	4798      	blx	r3
   b5e64:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
    double current = (double)combined*0.0015625/0.01;
   b5e68:	b200      	sxth	r0, r0
   b5e6a:	f7fe fa2b 	bl	b42c4 <__aeabi_i2d>
   b5e6e:	a306      	add	r3, pc, #24	; (adr r3, b5e88 <_ZN8max1720x10getCurrentEv+0x68>)
   b5e70:	e9d3 2300 	ldrd	r2, r3, [r3]
   b5e74:	f7fe fa90 	bl	b4398 <__aeabi_dmul>
   b5e78:	a305      	add	r3, pc, #20	; (adr r3, b5e90 <_ZN8max1720x10getCurrentEv+0x70>)
   b5e7a:	e9d3 2300 	ldrd	r2, r3, [r3]
   b5e7e:	f7fe fbb5 	bl	b45ec <__aeabi_ddiv>
    return current;//calculate actual value as 0.0015625 mV/Ohm
}
   b5e82:	ec41 0b10 	vmov	d0, r0, r1
   b5e86:	bd10      	pop	{r4, pc}
   b5e88:	9999999a 	.word	0x9999999a
   b5e8c:	3f599999 	.word	0x3f599999
   b5e90:	47ae147b 	.word	0x47ae147b
   b5e94:	3f847ae1 	.word	0x3f847ae1

000b5e98 <_ZN8max1720x11getCapacityEv>:

// RepCap or reported capacity is a filtered version of the AvCap register that prevents large jumps in the reported value caused by changes in the application such as abrupt changes in temperature or load current. 
double max1720x::getCapacity()
{
   b5e98:	b510      	push	{r4, lr}
	Wire.beginTransmission(MAX1720X_ADDR);
   b5e9a:	f002 f94f 	bl	b813c <_Z19__fetch_global_Wirev>
   b5e9e:	2136      	movs	r1, #54	; 0x36
   b5ea0:	f001 f9f2 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_REPCAP_ADDR);
   b5ea4:	f002 f94a 	bl	b813c <_Z19__fetch_global_Wirev>
   b5ea8:	2105      	movs	r1, #5
   b5eaa:	f7ff ff1b 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false);
   b5eae:	f002 f945 	bl	b813c <_Z19__fetch_global_Wirev>
   b5eb2:	2100      	movs	r1, #0
   b5eb4:	f001 f9eb 	bl	b728e <_ZN7TwoWire15endTransmissionEh>
	Wire.requestFrom(MAX1720X_ADDR, (int)2);
   b5eb8:	f002 f940 	bl	b813c <_Z19__fetch_global_Wirev>
   b5ebc:	2202      	movs	r2, #2
   b5ebe:	2136      	movs	r1, #54	; 0x36
   b5ec0:	f001 f9db 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    uint16_t combined = Wire.read()|(Wire.read()<<8); // LSB or-ed with MSB
   b5ec4:	f002 f93a 	bl	b813c <_Z19__fetch_global_Wirev>
   b5ec8:	6803      	ldr	r3, [r0, #0]
   b5eca:	695b      	ldr	r3, [r3, #20]
   b5ecc:	4798      	blx	r3
   b5ece:	4604      	mov	r4, r0
   b5ed0:	f002 f934 	bl	b813c <_Z19__fetch_global_Wirev>
   b5ed4:	6803      	ldr	r3, [r0, #0]
   b5ed6:	695b      	ldr	r3, [r3, #20]
   b5ed8:	4798      	blx	r3
   b5eda:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
	double capacity = (double)combined*0.005/0.01;
   b5ede:	b280      	uxth	r0, r0
   b5ee0:	f7fe f9e0 	bl	b42a4 <__aeabi_ui2d>
   b5ee4:	a306      	add	r3, pc, #24	; (adr r3, b5f00 <_ZN8max1720x11getCapacityEv+0x68>)
   b5ee6:	e9d3 2300 	ldrd	r2, r3, [r3]
   b5eea:	f7fe fa55 	bl	b4398 <__aeabi_dmul>
   b5eee:	a306      	add	r3, pc, #24	; (adr r3, b5f08 <_ZN8max1720x11getCapacityEv+0x70>)
   b5ef0:	e9d3 2300 	ldrd	r2, r3, [r3]
   b5ef4:	f7fe fb7a 	bl	b45ec <__aeabi_ddiv>
    return capacity;//calculate actual value as 0.005 mVh/Ohm
}
   b5ef8:	ec41 0b10 	vmov	d0, r0, r1
   b5efc:	bd10      	pop	{r4, pc}
   b5efe:	bf00      	nop
   b5f00:	47ae147b 	.word	0x47ae147b
   b5f04:	3f747ae1 	.word	0x3f747ae1
   b5f08:	47ae147b 	.word	0x47ae147b
   b5f0c:	3f847ae1 	.word	0x3f847ae1

000b5f10 <_ZN8max1720x5resetEv>:
//}


// Reset procedure
uint8_t max1720x::reset()
{
   b5f10:	b508      	push	{r3, lr}
 	Wire.beginTransmission(MAX1720X_ADDR);
   b5f12:	f002 f913 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f16:	2136      	movs	r1, #54	; 0x36
   b5f18:	f001 f9b6 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_COMMAND_ADDR);
   b5f1c:	f002 f90e 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f20:	2160      	movs	r1, #96	; 0x60
   b5f22:	f7ff fedf 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.write(0x0f);
   b5f26:	f002 f909 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f2a:	210f      	movs	r1, #15
   b5f2c:	f7ff feda 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.write(0x00);
   b5f30:	f002 f904 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f34:	2100      	movs	r1, #0
   b5f36:	f7ff fed5 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
    Wire.endTransmission();
   b5f3a:	f002 f8ff 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f3e:	f001 f9aa 	bl	b7296 <_ZN7TwoWire15endTransmissionEv>
    delay(50);
   b5f42:	2032      	movs	r0, #50	; 0x32
   b5f44:	f000 fd78 	bl	b6a38 <delay>
    Wire.beginTransmission(MAX1720X_ADDR);
   b5f48:	f002 f8f8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f4c:	2136      	movs	r1, #54	; 0x36
   b5f4e:	f001 f99b 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(MAX1720X_CONFIG2_ADDR);
   b5f52:	f002 f8f3 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f56:	21bb      	movs	r1, #187	; 0xbb
   b5f58:	f7ff fec4 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.write(0x01);
   b5f5c:	f002 f8ee 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f60:	2101      	movs	r1, #1
   b5f62:	f7ff febf 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	Wire.write(0x00);
   b5f66:	f002 f8e9 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f6a:	2100      	movs	r1, #0
   b5f6c:	f7ff feba 	bl	b5ce4 <_ZN7TwoWire5writeEi.isra.0>
	return Wire.endTransmission();
   b5f70:	f002 f8e4 	bl	b813c <_Z19__fetch_global_Wirev>
}
   b5f74:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return Wire.endTransmission();
   b5f78:	f001 b98d 	b.w	b7296 <_ZN7TwoWire15endTransmissionEv>

000b5f7c <_ZN7TwoWire5writeEi>:
   b5f7c:	6803      	ldr	r3, [r0, #0]
   b5f7e:	b2c9      	uxtb	r1, r1
   b5f80:	689b      	ldr	r3, [r3, #8]
   b5f82:	4718      	bx	r3

000b5f84 <_ZN17DFRobot_PN532_IIC12writeCommandEPhh>:
    return dataSrt;
}
/*
    Send commands to the chip through the iic ports*/

void DFRobot_PN532_IIC::writeCommand(uint8_t* cmd, uint8_t cmdlen) {     
   b5f84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t checksum;
    cmdlen++;
   b5f88:	3201      	adds	r2, #1
    delay(2);     // Delay for random time to wake up NFC module
   b5f8a:	2002      	movs	r0, #2
    cmdlen++;
   b5f8c:	b2d5      	uxtb	r5, r2
void DFRobot_PN532_IIC::writeCommand(uint8_t* cmd, uint8_t cmdlen) {     
   b5f8e:	460f      	mov	r7, r1
    delay(2);     // Delay for random time to wake up NFC module
   b5f90:	f000 fd52 	bl	b6a38 <delay>
    // I2C START
    Wire.beginTransmission(I2C_ADDRESS);
   b5f94:	f002 f8d2 	bl	b813c <_Z19__fetch_global_Wirev>
   b5f98:	2124      	movs	r1, #36	; 0x24
   b5f9a:	f001 f975 	bl	b7288 <_ZN7TwoWire17beginTransmissionEi>
    checksum = PN532_PREAMBLE + PN532_STARTCODE1 + PN532_STARTCODE2;
    Wire.write(PN532_PREAMBLE);
   b5f9e:	f002 f8cd 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fa2:	2100      	movs	r1, #0
   b5fa4:	f7ff ffea 	bl	b5f7c <_ZN7TwoWire5writeEi>
    Wire.write(PN532_STARTCODE1);
   b5fa8:	f002 f8c8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fac:	2100      	movs	r1, #0
   b5fae:	f7ff ffe5 	bl	b5f7c <_ZN7TwoWire5writeEi>
    Wire.write(PN532_STARTCODE2);
   b5fb2:	f002 f8c3 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fb6:	21ff      	movs	r1, #255	; 0xff
   b5fb8:	f7ff ffe0 	bl	b5f7c <_ZN7TwoWire5writeEi>
    Wire.write(cmdlen);
   b5fbc:	f002 f8be 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fc0:	6803      	ldr	r3, [r0, #0]
   b5fc2:	4629      	mov	r1, r5
   b5fc4:	689b      	ldr	r3, [r3, #8]
   b5fc6:	4798      	blx	r3
    Wire.write(~cmdlen + 1);
   b5fc8:	f002 f8b8 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fcc:	4269      	negs	r1, r5
   b5fce:	f7ff ffd5 	bl	b5f7c <_ZN7TwoWire5writeEi>
    Wire.write(HOSTTOPN532);
   b5fd2:	f002 f8b3 	bl	b813c <_Z19__fetch_global_Wirev>
   b5fd6:	21d4      	movs	r1, #212	; 0xd4
   b5fd8:	f7ff ffd0 	bl	b5f7c <_ZN7TwoWire5writeEi>
   b5fdc:	2400      	movs	r4, #0
    checksum += HOSTTOPN532;
   b5fde:	26d3      	movs	r6, #211	; 0xd3
    for (uint8_t i = 0; i < cmdlen - 1; i++) {
   b5fe0:	3d01      	subs	r5, #1
   b5fe2:	f104 0801 	add.w	r8, r4, #1
   b5fe6:	b2e4      	uxtb	r4, r4
   b5fe8:	42ac      	cmp	r4, r5
   b5fea:	da0a      	bge.n	b6002 <_ZN17DFRobot_PN532_IIC12writeCommandEPhh+0x7e>
      Wire.write(cmd[i]);
   b5fec:	f002 f8a6 	bl	b813c <_Z19__fetch_global_Wirev>
   b5ff0:	6803      	ldr	r3, [r0, #0]
   b5ff2:	5d39      	ldrb	r1, [r7, r4]
   b5ff4:	689b      	ldr	r3, [r3, #8]
   b5ff6:	4798      	blx	r3
      checksum += cmd[i];
   b5ff8:	5d39      	ldrb	r1, [r7, r4]
   b5ffa:	440e      	add	r6, r1
   b5ffc:	b2f6      	uxtb	r6, r6
    for (uint8_t i = 0; i < cmdlen - 1; i++) {
   b5ffe:	4644      	mov	r4, r8
   b6000:	e7ef      	b.n	b5fe2 <_ZN17DFRobot_PN532_IIC12writeCommandEPhh+0x5e>
    }
    Wire.write((byte)~checksum);
   b6002:	f002 f89b 	bl	b813c <_Z19__fetch_global_Wirev>
   b6006:	6803      	ldr	r3, [r0, #0]
   b6008:	43f1      	mvns	r1, r6
   b600a:	689b      	ldr	r3, [r3, #8]
   b600c:	b2c9      	uxtb	r1, r1
   b600e:	4798      	blx	r3
    Wire.write((byte)PN532_POSTAMBLE);
   b6010:	f002 f894 	bl	b813c <_Z19__fetch_global_Wirev>
   b6014:	6803      	ldr	r3, [r0, #0]
   b6016:	2100      	movs	r1, #0
   b6018:	689b      	ldr	r3, [r3, #8]
   b601a:	4798      	blx	r3
    Wire.endTransmission();
   b601c:	f002 f88e 	bl	b813c <_Z19__fetch_global_Wirev>
}
   b6020:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    Wire.endTransmission();
   b6024:	f001 b937 	b.w	b7296 <_ZN7TwoWire15endTransmissionEv>

000b6028 <_ZN13DFRobot_PN5328checkDCSEi>:
{
   b6028:	b530      	push	{r4, r5, lr}
   b602a:	4602      	mov	r2, r0
    if(!this->nfcEnable)
   b602c:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
   b6030:	b1a0      	cbz	r0, b605c <_ZN13DFRobot_PN5328checkDCSEi+0x34>
    for(int i = 6;i < x - 2;i++)
   b6032:	f06f 0503 	mvn.w	r5, #3
   b6036:	f102 000a 	add.w	r0, r2, #10
    uint32_t sum = 0;
   b603a:	2300      	movs	r3, #0
    for(int i = 6;i < x - 2;i++)
   b603c:	3902      	subs	r1, #2
   b603e:	1aad      	subs	r5, r5, r2
   b6040:	182c      	adds	r4, r5, r0
   b6042:	42a1      	cmp	r1, r4
   b6044:	dd03      	ble.n	b604e <_ZN13DFRobot_PN5328checkDCSEi+0x26>
        sum += this->receiveACK[i];
   b6046:	f810 4b01 	ldrb.w	r4, [r0], #1
   b604a:	4423      	add	r3, r4
    for(int i = 6;i < x - 2;i++)
   b604c:	e7f8      	b.n	b6040 <_ZN13DFRobot_PN5328checkDCSEi+0x18>
    if(dcs==this->receiveACK[x - 2])
   b604e:	440a      	add	r2, r1
    dcs = 0xff - (sum&0xff);
   b6050:	43db      	mvns	r3, r3
    if(dcs==this->receiveACK[x - 2])
   b6052:	7910      	ldrb	r0, [r2, #4]
    dcs = 0xff - (sum&0xff);
   b6054:	b2db      	uxtb	r3, r3
    if(dcs==this->receiveACK[x - 2])
   b6056:	1a1b      	subs	r3, r3, r0
   b6058:	4258      	negs	r0, r3
   b605a:	4158      	adcs	r0, r3
}
   b605c:	bd30      	pop	{r4, r5, pc}

000b605e <_ZN13DFRobot_PN53213passWordCheckEiPhS0_>:
{   //bool success = false;
   b605e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   b6060:	4604      	mov	r4, r0
    if(!this->nfcEnable)
   b6062:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
   b6066:	b350      	cbz	r0, b60be <_ZN13DFRobot_PN53213passWordCheckEiPhS0_+0x60>
    cmdPassWord[0] = COMMAND_INDATAEXCHANGE;   /* Data Exchange Header */
   b6068:	2040      	movs	r0, #64	; 0x40
   b606a:	f88d 0000 	strb.w	r0, [sp]
    cmdPassWord[1] = 1;                              /* The quantity number of the maxium card that can be detected in every research*/
   b606e:	2001      	movs	r0, #1
   b6070:	f88d 0001 	strb.w	r0, [sp, #1]
    cmdPassWord[2] = 0x60;                          
   b6074:	2060      	movs	r0, #96	; 0x60
   b6076:	f88d 0002 	strb.w	r0, [sp, #2]
    for(int i = 4;i < 10;i++) cmdPassWord[i] = st[i - 4];              // PassWord
   b607a:	6818      	ldr	r0, [r3, #0]
   b607c:	889b      	ldrh	r3, [r3, #4]
   b607e:	f8ad 3008 	strh.w	r3, [sp, #8]
    for(int i = 10;i < 14;i++) cmdPassWord[i] = id[i - 10];           // nfcUid
   b6082:	6813      	ldr	r3, [r2, #0]
   b6084:	f8cd 300a 	str.w	r3, [sp, #10]
    this->writeCommand(cmdPassWord,14);     /*!Send a series of commands to the chip*/ 
   b6088:	6823      	ldr	r3, [r4, #0]
    cmdPassWord[3] = block;
   b608a:	f88d 1003 	strb.w	r1, [sp, #3]
    for(int i = 4;i < 10;i++) cmdPassWord[i] = st[i - 4];              // PassWord
   b608e:	9001      	str	r0, [sp, #4]
    this->writeCommand(cmdPassWord,14);     /*!Send a series of commands to the chip*/ 
   b6090:	681b      	ldr	r3, [r3, #0]
   b6092:	220e      	movs	r2, #14
   b6094:	4669      	mov	r1, sp
   b6096:	4620      	mov	r0, r4
   b6098:	4798      	blx	r3
    if(!this->readAck(16))
   b609a:	6823      	ldr	r3, [r4, #0]
   b609c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   b60a0:	685b      	ldr	r3, [r3, #4]
   b60a2:	2110      	movs	r1, #16
   b60a4:	4620      	mov	r0, r4
   b60a6:	4798      	blx	r3
   b60a8:	b148      	cbz	r0, b60be <_ZN13DFRobot_PN53213passWordCheckEiPhS0_+0x60>
    if(checkDCS(16) == 1 && receiveACK[12] == 0x41 && receiveACK[13] == 0x00)   
   b60aa:	2110      	movs	r1, #16
   b60ac:	4620      	mov	r0, r4
   b60ae:	f7ff ffbb 	bl	b6028 <_ZN13DFRobot_PN5328checkDCSEi>
   b60b2:	b120      	cbz	r0, b60be <_ZN13DFRobot_PN53213passWordCheckEiPhS0_+0x60>
   b60b4:	8a20      	ldrh	r0, [r4, #16]
   b60b6:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   b60ba:	4258      	negs	r0, r3
   b60bc:	4158      	adcs	r0, r3
}
   b60be:	b004      	add	sp, #16
   b60c0:	bd10      	pop	{r4, pc}

000b60c2 <_ZN13DFRobot_PN5324scanEv>:
{   if(!this->nfcEnable)
   b60c2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   b60c4:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   b60c8:	4604      	mov	r4, r0
   b60ca:	b313      	cbz	r3, b6112 <_ZN13DFRobot_PN5324scanEv+0x50>
    cmdnfcUid[0] = COMMAND_INLISTPASSIVETARGET;
   b60cc:	234a      	movs	r3, #74	; 0x4a
   b60ce:	f88d 3004 	strb.w	r3, [sp, #4]
    cmdnfcUid[1] = 1;                              // The quantity number of the maxium card that can be detected in every research
   b60d2:	2301      	movs	r3, #1
   b60d4:	f88d 3005 	strb.w	r3, [sp, #5]
    cmdnfcUid[2] = MIFARE_ISO14443A;
   b60d8:	2300      	movs	r3, #0
   b60da:	f88d 3006 	strb.w	r3, [sp, #6]
    writeCommand(cmdnfcUid,3);
   b60de:	6803      	ldr	r3, [r0, #0]
   b60e0:	2203      	movs	r2, #3
   b60e2:	681b      	ldr	r3, [r3, #0]
   b60e4:	a901      	add	r1, sp, #4
   b60e6:	4798      	blx	r3
    if(!readAck(25))
   b60e8:	6823      	ldr	r3, [r4, #0]
   b60ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   b60ee:	685b      	ldr	r3, [r3, #4]
   b60f0:	2119      	movs	r1, #25
   b60f2:	4620      	mov	r0, r4
   b60f4:	4798      	blx	r3
   b60f6:	4603      	mov	r3, r0
   b60f8:	b158      	cbz	r0, b6112 <_ZN13DFRobot_PN5324scanEv+0x50>
        nfcUid[i] = receiveACK[i + 19];
   b60fa:	7ea3      	ldrb	r3, [r4, #26]
   b60fc:	7de2      	ldrb	r2, [r4, #23]
   b60fe:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    if(receiveACK[13]!=1)
   b6102:	7c63      	ldrb	r3, [r4, #17]
        nfcUid[i] = receiveACK[i + 19];
   b6104:	f884 202d 	strb.w	r2, [r4, #45]	; 0x2d
   b6108:	8b22      	ldrh	r2, [r4, #24]
   b610a:	85e2      	strh	r2, [r4, #46]	; 0x2e
    if(receiveACK[13]!=1)
   b610c:	1e5a      	subs	r2, r3, #1
   b610e:	4253      	negs	r3, r2
   b6110:	4153      	adcs	r3, r2
}
   b6112:	4618      	mov	r0, r3
   b6114:	b004      	add	sp, #16
   b6116:	bd10      	pop	{r4, pc}

000b6118 <_ZN13DFRobot_PN5328readDataEi>:
String DFRobot_PN532::readData(int page) {
   b6118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (page > 255)
   b611c:	2aff      	cmp	r2, #255	; 0xff
String DFRobot_PN532::readData(int page) {
   b611e:	b08a      	sub	sp, #40	; 0x28
   b6120:	4605      	mov	r5, r0
   b6122:	460c      	mov	r4, r1
   b6124:	4616      	mov	r6, r2
    if (page > 255)
   b6126:	dd06      	ble.n	b6136 <_ZN13DFRobot_PN5328readDataEi+0x1e>
        return "flase";
   b6128:	4939      	ldr	r1, [pc, #228]	; (b6210 <_ZN13DFRobot_PN5328readDataEi+0xf8>)
        return "read timeout!";
   b612a:	f001 fb7c 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
}
   b612e:	4628      	mov	r0, r5
   b6130:	b00a      	add	sp, #40	; 0x28
   b6132:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(!this->nfcEnable)
   b6136:	f891 3041 	ldrb.w	r3, [r1, #65]	; 0x41
   b613a:	b90b      	cbnz	r3, b6140 <_ZN13DFRobot_PN5328readDataEi+0x28>
        return "wake up error!";
   b613c:	4935      	ldr	r1, [pc, #212]	; (b6214 <_ZN13DFRobot_PN5328readDataEi+0xfc>)
   b613e:	e7f4      	b.n	b612a <_ZN13DFRobot_PN5328readDataEi+0x12>
    if(!scan())
   b6140:	4608      	mov	r0, r1
   b6142:	f7ff ffbe 	bl	b60c2 <_ZN13DFRobot_PN5324scanEv>
   b6146:	b910      	cbnz	r0, b614e <_ZN13DFRobot_PN5328readDataEi+0x36>
        return "no card!";
   b6148:	4933      	ldr	r1, [pc, #204]	; (b6218 <_ZN13DFRobot_PN5328readDataEi+0x100>)
        return "read timeout!";
   b614a:	4628      	mov	r0, r5
   b614c:	e7ed      	b.n	b612a <_ZN13DFRobot_PN5328readDataEi+0x12>
    if(!passWordCheck(page,nfcUid,nfcPassword))
   b614e:	f104 0327 	add.w	r3, r4, #39	; 0x27
   b6152:	f104 022d 	add.w	r2, r4, #45	; 0x2d
   b6156:	4631      	mov	r1, r6
   b6158:	4620      	mov	r0, r4
   b615a:	f7ff ff80 	bl	b605e <_ZN13DFRobot_PN53213passWordCheckEiPhS0_>
   b615e:	b908      	cbnz	r0, b6164 <_ZN13DFRobot_PN5328readDataEi+0x4c>
        return "read error!";
   b6160:	492e      	ldr	r1, [pc, #184]	; (b621c <_ZN13DFRobot_PN5328readDataEi+0x104>)
   b6162:	e7f2      	b.n	b614a <_ZN13DFRobot_PN5328readDataEi+0x32>
        cmdRead[0] = COMMAND_INDATAEXCHANGE;
   b6164:	2340      	movs	r3, #64	; 0x40
   b6166:	f88d 3004 	strb.w	r3, [sp, #4]
        cmdRead[1] = 1;                   /* Card number */
   b616a:	2301      	movs	r3, #1
   b616c:	f88d 3005 	strb.w	r3, [sp, #5]
        cmdRead[2] = CARD_CMD_READING;     /* Mifare Read command = 0x30 */
   b6170:	2330      	movs	r3, #48	; 0x30
   b6172:	f88d 3006 	strb.w	r3, [sp, #6]
    writeCommand(cmdRead,4);
   b6176:	6823      	ldr	r3, [r4, #0]
        cmdRead[3] = page; 
   b6178:	f88d 6007 	strb.w	r6, [sp, #7]
    writeCommand(cmdRead,4);
   b617c:	2204      	movs	r2, #4
   b617e:	eb0d 0102 	add.w	r1, sp, r2
   b6182:	681b      	ldr	r3, [r3, #0]
   b6184:	4620      	mov	r0, r4
   b6186:	4798      	blx	r3
    if(!readAck(32))
   b6188:	6823      	ldr	r3, [r4, #0]
   b618a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   b618e:	685b      	ldr	r3, [r3, #4]
   b6190:	2120      	movs	r1, #32
   b6192:	4620      	mov	r0, r4
   b6194:	4798      	blx	r3
   b6196:	b908      	cbnz	r0, b619c <_ZN13DFRobot_PN5328readDataEi+0x84>
        return "read timeout!";
   b6198:	4921      	ldr	r1, [pc, #132]	; (b6220 <_ZN13DFRobot_PN5328readDataEi+0x108>)
   b619a:	e7d6      	b.n	b614a <_ZN13DFRobot_PN5328readDataEi+0x32>
    String dataSrt = "";
   b619c:	4921      	ldr	r1, [pc, #132]	; (b6224 <_ZN13DFRobot_PN5328readDataEi+0x10c>)
   b619e:	a802      	add	r0, sp, #8
   b61a0:	f001 fb41 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
    if(checkDCS(32) == 1 && receiveACK[12] == 0x41 && receiveACK[13] == 0x00){
   b61a4:	2120      	movs	r1, #32
   b61a6:	4620      	mov	r0, r4
   b61a8:	f7ff ff3e 	bl	b6028 <_ZN13DFRobot_PN5328checkDCSEi>
   b61ac:	b330      	cbz	r0, b61fc <_ZN13DFRobot_PN5328readDataEi+0xe4>
   b61ae:	8a23      	ldrh	r3, [r4, #16]
   b61b0:	2b41      	cmp	r3, #65	; 0x41
   b61b2:	d123      	bne.n	b61fc <_ZN13DFRobot_PN5328readDataEi+0xe4>
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
   b61b4:	4f1c      	ldr	r7, [pc, #112]	; (b6228 <_ZN13DFRobot_PN5328readDataEi+0x110>)
   b61b6:	f8df 8074 	ldr.w	r8, [pc, #116]	; b622c <_ZN13DFRobot_PN5328readDataEi+0x114>
   b61ba:	3412      	adds	r4, #18
   b61bc:	2600      	movs	r6, #0
            blockData[i] = receiveACK[i + 14];
   b61be:	f814 1b01 	ldrb.w	r1, [r4], #1
   b61c2:	77a1      	strb	r1, [r4, #30]
            if(receiveACK[i+14]<=0x0f){
   b61c4:	290f      	cmp	r1, #15
   b61c6:	d821      	bhi.n	b620c <_ZN13DFRobot_PN5328readDataEi+0xf4>
   b61c8:	4639      	mov	r1, r7
   b61ca:	a802      	add	r0, sp, #8
   b61cc:	f001 fbd4 	bl	b7978 <_ZN6String6concatEPKc>
                dataSrt += String(receiveACK[i + 14],HEX);
   b61d0:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   b61d4:	2210      	movs	r2, #16
                dataSrt += String(receiveACK[i + 14],HEX);
   b61d6:	a806      	add	r0, sp, #24
   b61d8:	f001 fb8e 	bl	b78f8 <_ZN6StringC1Ehh>
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
   b61dc:	a906      	add	r1, sp, #24
   b61de:	a802      	add	r0, sp, #8
   b61e0:	f001 fbc6 	bl	b7970 <_ZN6String6concatERKS_>
   b61e4:	a806      	add	r0, sp, #24
   b61e6:	f001 fad3 	bl	b7790 <_ZN6StringD1Ev>
            if(i<15) dataSrt += " ";
   b61ea:	2e0f      	cmp	r6, #15
   b61ec:	d003      	beq.n	b61f6 <_ZN13DFRobot_PN5328readDataEi+0xde>
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
   b61ee:	4641      	mov	r1, r8
   b61f0:	a802      	add	r0, sp, #8
   b61f2:	f001 fbc1 	bl	b7978 <_ZN6String6concatEPKc>
        for(int i = 0; i<16; i++)
   b61f6:	3601      	adds	r6, #1
   b61f8:	2e10      	cmp	r6, #16
   b61fa:	d1e0      	bne.n	b61be <_ZN13DFRobot_PN5328readDataEi+0xa6>
    return dataSrt;
   b61fc:	a902      	add	r1, sp, #8
   b61fe:	4628      	mov	r0, r5
   b6200:	f001 fb43 	bl	b788a <_ZN6StringC1EOS_>
    String dataSrt = "";
   b6204:	a802      	add	r0, sp, #8
   b6206:	f001 fac3 	bl	b7790 <_ZN6StringD1Ev>
   b620a:	e790      	b.n	b612e <_ZN13DFRobot_PN5328readDataEi+0x16>
                dataSrt += String(receiveACK[i + 14],HEX);
   b620c:	2210      	movs	r2, #16
   b620e:	e7e2      	b.n	b61d6 <_ZN13DFRobot_PN5328readDataEi+0xbe>
   b6210:	000bbd6e 	.word	0x000bbd6e
   b6214:	000bbd56 	.word	0x000bbd56
   b6218:	000bbd65 	.word	0x000bbd65
   b621c:	000bbd74 	.word	0x000bbd74
   b6220:	000bbd80 	.word	0x000bbd80
   b6224:	000b8734 	.word	0x000b8734
   b6228:	000bbd54 	.word	0x000bbd54
   b622c:	000b8614 	.word	0x000b8614

000b6230 <_ZN13DFRobot_PN5328readDataEPhh>:
uint8_t DFRobot_PN532::readData(uint8_t *buffer,uint8_t block){
   b6230:	b530      	push	{r4, r5, lr}
    if(!this->nfcEnable)
   b6232:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
uint8_t DFRobot_PN532::readData(uint8_t *buffer,uint8_t block){
   b6236:	b085      	sub	sp, #20
   b6238:	4604      	mov	r4, r0
   b623a:	460d      	mov	r5, r1
    if(!this->nfcEnable)
   b623c:	2b00      	cmp	r3, #0
   b623e:	d039      	beq.n	b62b4 <_ZN13DFRobot_PN5328readDataEPhh+0x84>
    String error = this->readData(block);
   b6240:	4601      	mov	r1, r0
   b6242:	4668      	mov	r0, sp
   b6244:	f7ff ff68 	bl	b6118 <_ZN13DFRobot_PN5328readDataEi>
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
   b6248:	491b      	ldr	r1, [pc, #108]	; (b62b8 <_ZN13DFRobot_PN5328readDataEPhh+0x88>)
   b624a:	4668      	mov	r0, sp
   b624c:	f001 fbc6 	bl	b79dc <_ZNK6String6equalsEPKc>
                        || error == "read timeout!" || error == "wake up error!" ||error =="flase")
   b6250:	b130      	cbz	r0, b6260 <_ZN13DFRobot_PN5328readDataEPhh+0x30>
        return -1;
   b6252:	24ff      	movs	r4, #255	; 0xff
    String error = this->readData(block);
   b6254:	4668      	mov	r0, sp
   b6256:	f001 fa9b 	bl	b7790 <_ZN6StringD1Ev>
}
   b625a:	4620      	mov	r0, r4
   b625c:	b005      	add	sp, #20
   b625e:	bd30      	pop	{r4, r5, pc}
   b6260:	4916      	ldr	r1, [pc, #88]	; (b62bc <_ZN13DFRobot_PN5328readDataEPhh+0x8c>)
   b6262:	4668      	mov	r0, sp
   b6264:	f001 fbba 	bl	b79dc <_ZNK6String6equalsEPKc>
    if(error == "no card!" || error == "read error!" || error =="unknown error!"
   b6268:	2800      	cmp	r0, #0
   b626a:	d1f2      	bne.n	b6252 <_ZN13DFRobot_PN5328readDataEPhh+0x22>
   b626c:	4914      	ldr	r1, [pc, #80]	; (b62c0 <_ZN13DFRobot_PN5328readDataEPhh+0x90>)
   b626e:	4668      	mov	r0, sp
   b6270:	f001 fbb4 	bl	b79dc <_ZNK6String6equalsEPKc>
   b6274:	2800      	cmp	r0, #0
   b6276:	d1ec      	bne.n	b6252 <_ZN13DFRobot_PN5328readDataEPhh+0x22>
   b6278:	4912      	ldr	r1, [pc, #72]	; (b62c4 <_ZN13DFRobot_PN5328readDataEPhh+0x94>)
   b627a:	4668      	mov	r0, sp
   b627c:	f001 fbae 	bl	b79dc <_ZNK6String6equalsEPKc>
                        || error == "read timeout!" || error == "wake up error!" ||error =="flase")
   b6280:	2800      	cmp	r0, #0
   b6282:	d1e6      	bne.n	b6252 <_ZN13DFRobot_PN5328readDataEPhh+0x22>
   b6284:	4910      	ldr	r1, [pc, #64]	; (b62c8 <_ZN13DFRobot_PN5328readDataEPhh+0x98>)
   b6286:	4668      	mov	r0, sp
   b6288:	f001 fba8 	bl	b79dc <_ZNK6String6equalsEPKc>
   b628c:	2800      	cmp	r0, #0
   b628e:	d1e0      	bne.n	b6252 <_ZN13DFRobot_PN5328readDataEPhh+0x22>
   b6290:	490e      	ldr	r1, [pc, #56]	; (b62cc <_ZN13DFRobot_PN5328readDataEPhh+0x9c>)
   b6292:	4668      	mov	r0, sp
   b6294:	f001 fba2 	bl	b79dc <_ZNK6String6equalsEPKc>
   b6298:	2800      	cmp	r0, #0
   b629a:	d1da      	bne.n	b6252 <_ZN13DFRobot_PN5328readDataEPhh+0x22>
    memcpy(buffer,blockData,16);
   b629c:	f104 0331 	add.w	r3, r4, #49	; 0x31
   b62a0:	4629      	mov	r1, r5
   b62a2:	3441      	adds	r4, #65	; 0x41
   b62a4:	f853 2b04 	ldr.w	r2, [r3], #4
   b62a8:	f841 2b04 	str.w	r2, [r1], #4
   b62ac:	42a3      	cmp	r3, r4
   b62ae:	d1f9      	bne.n	b62a4 <_ZN13DFRobot_PN5328readDataEPhh+0x74>
    return  1;
   b62b0:	2401      	movs	r4, #1
   b62b2:	e7cf      	b.n	b6254 <_ZN13DFRobot_PN5328readDataEPhh+0x24>
        return -1;
   b62b4:	24ff      	movs	r4, #255	; 0xff
   b62b6:	e7d0      	b.n	b625a <_ZN13DFRobot_PN5328readDataEPhh+0x2a>
   b62b8:	000bbd65 	.word	0x000bbd65
   b62bc:	000bbd74 	.word	0x000bbd74
   b62c0:	000bbd8e 	.word	0x000bbd8e
   b62c4:	000bbd80 	.word	0x000bbd80
   b62c8:	000bbd56 	.word	0x000bbd56
   b62cc:	000bbd6e 	.word	0x000bbd6e

000b62d0 <_ZN17DFRobot_PN532_IICC1Ehh>:
    if(strncmp((char *)pn532ack,(char *)receiveACK, 6)!=0){
        return false ;
    }
    return true;
}
DFRobot_PN532_IIC::DFRobot_PN532_IIC(uint8_t irq,uint8_t mode){
   b62d0:	b538      	push	{r3, r4, r5, lr}
   b62d2:	4604      	mov	r4, r0
   b62d4:	4b06      	ldr	r3, [pc, #24]	; (b62f0 <_ZN17DFRobot_PN532_IICC1Ehh+0x20>)
    
    _irq = irq;
   b62d6:	f884 1048 	strb.w	r1, [r4, #72]	; 0x48
DFRobot_PN532_IIC::DFRobot_PN532_IIC(uint8_t irq,uint8_t mode){
   b62da:	4608      	mov	r0, r1
   b62dc:	4615      	mov	r5, r2
   b62de:	6023      	str	r3, [r4, #0]
    pinMode(_irq, INPUT);
   b62e0:	2100      	movs	r1, #0
   b62e2:	f001 fed3 	bl	b808c <pinMode>
    _mode = mode;
   b62e6:	f884 5049 	strb.w	r5, [r4, #73]	; 0x49
}
   b62ea:	4620      	mov	r0, r4
   b62ec:	bd38      	pop	{r3, r4, r5, pc}
   b62ee:	bf00      	nop
   b62f0:	000bbda8 	.word	0x000bbda8

000b62f4 <_ZN17DFRobot_PN532_IIC10waitRemindEv>:
bool DFRobot_PN532_IIC::waitRemind(){
   b62f4:	b538      	push	{r3, r4, r5, lr}
   b62f6:	4605      	mov	r5, r0
   b62f8:	2465      	movs	r4, #101	; 0x65
    uint16_t timer = 0;
     //digitalRead(_irq)
    //return ret == 0;
    //bool b = digitalRead(_irq);
    //Serial.println(b);
    while(digitalRead(_irq)!=0){
   b62fa:	f895 0048 	ldrb.w	r0, [r5, #72]	; 0x48
   b62fe:	f001 feef 	bl	b80e0 <digitalRead>
   b6302:	b130      	cbz	r0, b6312 <_ZN17DFRobot_PN532_IIC10waitRemindEv+0x1e>
        //Serial.print(digitalRead(_irq));
    if (timeout != 0) {
      timer += 10;
      if (timer > timeout) {
   b6304:	3c01      	subs	r4, #1
   b6306:	b2a4      	uxth	r4, r4
   b6308:	b12c      	cbz	r4, b6316 <_ZN17DFRobot_PN532_IIC10waitRemindEv+0x22>
        return false;
      }
    }
    delay(10);
   b630a:	200a      	movs	r0, #10
   b630c:	f000 fb94 	bl	b6a38 <delay>
    while(digitalRead(_irq)!=0){
   b6310:	e7f3      	b.n	b62fa <_ZN17DFRobot_PN532_IIC10waitRemindEv+0x6>
    }
    //Serial.print(digitalRead(_irq));
    return true;
   b6312:	2001      	movs	r0, #1
}
   b6314:	bd38      	pop	{r3, r4, r5, pc}
        return false;
   b6316:	4620      	mov	r0, r4
   b6318:	e7fc      	b.n	b6314 <_ZN17DFRobot_PN532_IIC10waitRemindEv+0x20>

000b631a <_ZN17DFRobot_PN532_IIC7readAckEil>:
bool DFRobot_PN532_IIC::readAck(int x,long timeout ) {
   b631a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    pn532ack[0] = 0x00;
   b631c:	2300      	movs	r3, #0
   b631e:	f88d 3000 	strb.w	r3, [sp]
    pn532ack[1] = 0x00;
   b6322:	f88d 3001 	strb.w	r3, [sp, #1]
    pn532ack[3] = 0x00;
   b6326:	f88d 3003 	strb.w	r3, [sp, #3]
    pn532ack[5] = 0x00;
   b632a:	f88d 3005 	strb.w	r3, [sp, #5]
    if(_mode == 1){
   b632e:	f890 3049 	ldrb.w	r3, [r0, #73]	; 0x49
    pn532ack[2] = 0xFF;
   b6332:	22ff      	movs	r2, #255	; 0xff
    if(_mode == 1){
   b6334:	2b01      	cmp	r3, #1
bool DFRobot_PN532_IIC::readAck(int x,long timeout ) {
   b6336:	4604      	mov	r4, r0
   b6338:	460d      	mov	r5, r1
    pn532ack[2] = 0xFF;
   b633a:	f88d 2002 	strb.w	r2, [sp, #2]
    pn532ack[4] = 0xFF;
   b633e:	f88d 2004 	strb.w	r2, [sp, #4]
    if(_mode == 1){
   b6342:	d141      	bne.n	b63c8 <_ZN17DFRobot_PN532_IIC7readAckEil+0xae>
    if(!waitRemind())
   b6344:	f7ff ffd6 	bl	b62f4 <_ZN17DFRobot_PN532_IIC10waitRemindEv>
   b6348:	b910      	cbnz	r0, b6350 <_ZN17DFRobot_PN532_IIC7readAckEil+0x36>
        return false;
   b634a:	2000      	movs	r0, #0
}
   b634c:	b003      	add	sp, #12
   b634e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    Wire.requestFrom(I2C_ADDRESS,8);
   b6350:	f001 fef4 	bl	b813c <_Z19__fetch_global_Wirev>
   b6354:	2208      	movs	r2, #8
   b6356:	2124      	movs	r1, #36	; 0x24
   b6358:	f000 ff8f 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    Wire.read();
   b635c:	f001 feee 	bl	b813c <_Z19__fetch_global_Wirev>
   b6360:	6803      	ldr	r3, [r0, #0]
   b6362:	695b      	ldr	r3, [r3, #20]
   b6364:	4798      	blx	r3
    for(int i = 0; i < 6; i++){
   b6366:	1d26      	adds	r6, r4, #4
   b6368:	f104 070a 	add.w	r7, r4, #10
        delay(1);
   b636c:	2001      	movs	r0, #1
   b636e:	f000 fb63 	bl	b6a38 <delay>
        receiveACK[i]= Wire.read();
   b6372:	f001 fee3 	bl	b813c <_Z19__fetch_global_Wirev>
   b6376:	6803      	ldr	r3, [r0, #0]
   b6378:	695b      	ldr	r3, [r3, #20]
   b637a:	4798      	blx	r3
   b637c:	f806 0b01 	strb.w	r0, [r6], #1
    for(int i = 0; i < 6; i++){
   b6380:	42be      	cmp	r6, r7
   b6382:	d1f3      	bne.n	b636c <_ZN17DFRobot_PN532_IIC7readAckEil+0x52>
    if(!waitRemind() ) return false;
   b6384:	4620      	mov	r0, r4
   b6386:	f7ff ffb5 	bl	b62f4 <_ZN17DFRobot_PN532_IIC10waitRemindEv>
   b638a:	2800      	cmp	r0, #0
   b638c:	d0dd      	beq.n	b634a <_ZN17DFRobot_PN532_IIC7readAckEil+0x30>
    Wire.requestFrom(I2C_ADDRESS,x-4);
   b638e:	f001 fed5 	bl	b813c <_Z19__fetch_global_Wirev>
   b6392:	1f2a      	subs	r2, r5, #4
   b6394:	2124      	movs	r1, #36	; 0x24
   b6396:	f000 ff70 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    Wire.read();
   b639a:	f001 fecf 	bl	b813c <_Z19__fetch_global_Wirev>
   b639e:	6803      	ldr	r3, [r0, #0]
   b63a0:	695b      	ldr	r3, [r3, #20]
   b63a2:	4798      	blx	r3
    for(int i = 0; i < x - 6; i++){
   b63a4:	f06f 0709 	mvn.w	r7, #9
   b63a8:	3d06      	subs	r5, #6
   b63aa:	1b3f      	subs	r7, r7, r4
   b63ac:	19bb      	adds	r3, r7, r6
   b63ae:	429d      	cmp	r5, r3
   b63b0:	dd49      	ble.n	b6446 <_ZN17DFRobot_PN532_IIC7readAckEil+0x12c>
        delay(1);
   b63b2:	2001      	movs	r0, #1
   b63b4:	f000 fb40 	bl	b6a38 <delay>
        receiveACK[6 + i] = Wire.read();
   b63b8:	f001 fec0 	bl	b813c <_Z19__fetch_global_Wirev>
   b63bc:	6803      	ldr	r3, [r0, #0]
   b63be:	695b      	ldr	r3, [r3, #20]
   b63c0:	4798      	blx	r3
   b63c2:	f806 0b01 	strb.w	r0, [r6], #1
    for(int i = 0; i < x - 6; i++){
   b63c6:	e7f1      	b.n	b63ac <_ZN17DFRobot_PN532_IIC7readAckEil+0x92>
    else if(_mode == 0){
   b63c8:	2b00      	cmp	r3, #0
   b63ca:	d13c      	bne.n	b6446 <_ZN17DFRobot_PN532_IIC7readAckEil+0x12c>
    delay(30);
   b63cc:	201e      	movs	r0, #30
   b63ce:	f000 fb33 	bl	b6a38 <delay>
    Wire.requestFrom(I2C_ADDRESS,8);
   b63d2:	f001 feb3 	bl	b813c <_Z19__fetch_global_Wirev>
   b63d6:	2208      	movs	r2, #8
   b63d8:	2124      	movs	r1, #36	; 0x24
   b63da:	f000 ff4e 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    Wire.read();
   b63de:	f001 fead 	bl	b813c <_Z19__fetch_global_Wirev>
   b63e2:	6803      	ldr	r3, [r0, #0]
   b63e4:	695b      	ldr	r3, [r3, #20]
   b63e6:	4798      	blx	r3
    for(int i = 0; i < 6; i++){
   b63e8:	1d26      	adds	r6, r4, #4
   b63ea:	f104 070a 	add.w	r7, r4, #10
        delay(1);
   b63ee:	2001      	movs	r0, #1
   b63f0:	f000 fb22 	bl	b6a38 <delay>
        receiveACK[i]= Wire.read();
   b63f4:	f001 fea2 	bl	b813c <_Z19__fetch_global_Wirev>
   b63f8:	6803      	ldr	r3, [r0, #0]
   b63fa:	695b      	ldr	r3, [r3, #20]
   b63fc:	4798      	blx	r3
   b63fe:	f806 0b01 	strb.w	r0, [r6], #1
    for(int i = 0; i < 6; i++){
   b6402:	42be      	cmp	r6, r7
   b6404:	d1f3      	bne.n	b63ee <_ZN17DFRobot_PN532_IIC7readAckEil+0xd4>
    delay(30);
   b6406:	201e      	movs	r0, #30
   b6408:	f000 fb16 	bl	b6a38 <delay>
    Wire.requestFrom(I2C_ADDRESS,x-4);
   b640c:	f001 fe96 	bl	b813c <_Z19__fetch_global_Wirev>
   b6410:	1f2a      	subs	r2, r5, #4
   b6412:	2124      	movs	r1, #36	; 0x24
   b6414:	f000 ff31 	bl	b727a <_ZN7TwoWire11requestFromEhj>
    Wire.read();
   b6418:	f001 fe90 	bl	b813c <_Z19__fetch_global_Wirev>
   b641c:	6803      	ldr	r3, [r0, #0]
   b641e:	695b      	ldr	r3, [r3, #20]
   b6420:	4798      	blx	r3
    for(int i = 0; i < x - 6; i++){
   b6422:	f06f 0709 	mvn.w	r7, #9
   b6426:	3d06      	subs	r5, #6
   b6428:	1b3f      	subs	r7, r7, r4
   b642a:	19bb      	adds	r3, r7, r6
   b642c:	429d      	cmp	r5, r3
   b642e:	dd0a      	ble.n	b6446 <_ZN17DFRobot_PN532_IIC7readAckEil+0x12c>
        delay(1);
   b6430:	2001      	movs	r0, #1
   b6432:	f000 fb01 	bl	b6a38 <delay>
        receiveACK[6 + i] = Wire.read();
   b6436:	f001 fe81 	bl	b813c <_Z19__fetch_global_Wirev>
   b643a:	6803      	ldr	r3, [r0, #0]
   b643c:	695b      	ldr	r3, [r3, #20]
   b643e:	4798      	blx	r3
   b6440:	f806 0b01 	strb.w	r0, [r6], #1
    for(int i = 0; i < x - 6; i++){
   b6444:	e7f1      	b.n	b642a <_ZN17DFRobot_PN532_IIC7readAckEil+0x110>
    if(strncmp((char *)pn532ack,(char *)receiveACK, 6)!=0){
   b6446:	2206      	movs	r2, #6
   b6448:	1d21      	adds	r1, r4, #4
   b644a:	4668      	mov	r0, sp
   b644c:	f001 ff53 	bl	b82f6 <strncmp>
   b6450:	fab0 f080 	clz	r0, r0
   b6454:	0940      	lsrs	r0, r0, #5
   b6456:	e779      	b.n	b634c <_ZN17DFRobot_PN532_IIC7readAckEil+0x32>

000b6458 <_ZN17DFRobot_PN532_IIC5beginEv>:
bool DFRobot_PN532_IIC::begin(void) {   //nfc Module initialization  
   b6458:	b537      	push	{r0, r1, r2, r4, r5, lr}
    this->nfcPassword[0] = 0xff;
   b645a:	23ff      	movs	r3, #255	; 0xff
   b645c:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
    this->nfcPassword[1] = 0xff;
   b6460:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
bool DFRobot_PN532_IIC::begin(void) {   //nfc Module initialization  
   b6464:	4604      	mov	r4, r0
    this->nfcPassword[3] = 0xff;
    this->nfcPassword[4] = 0xff;
    this->nfcPassword[5] = 0xff;
    unsigned char cmdWrite[4];
    cmdWrite[0] = COMMAND_SAMCONFIGURATION;
    cmdWrite[1] = 0x01; // normal mode;
   b6466:	2501      	movs	r5, #1
    this->nfcPassword[1] = 0xff;
   b6468:	6283      	str	r3, [r0, #40]	; 0x28
    this->nfcPassword[5] = 0xff;
   b646a:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
    cmdWrite[0] = COMMAND_SAMCONFIGURATION;
   b646e:	2314      	movs	r3, #20
   b6470:	f88d 3004 	strb.w	r3, [sp, #4]
    cmdWrite[2] = 0x14; // timeout 50ms * 20 = 1 second
   b6474:	f88d 3006 	strb.w	r3, [sp, #6]
    cmdWrite[1] = 0x01; // normal mode;
   b6478:	f88d 5005 	strb.w	r5, [sp, #5]
    cmdWrite[3] = 0x01; // use IRQ pin!
   b647c:	f88d 5007 	strb.w	r5, [sp, #7]
    Wire.begin();
   b6480:	f001 fe5c 	bl	b813c <_Z19__fetch_global_Wirev>
   b6484:	f000 feca 	bl	b721c <_ZN7TwoWire5beginEv>
    nfcEnable = true;
    writeCommand(cmdWrite,4);
   b6488:	6823      	ldr	r3, [r4, #0]
    nfcEnable = true;
   b648a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    writeCommand(cmdWrite,4);
   b648e:	2204      	movs	r2, #4
   b6490:	eb0d 0102 	add.w	r1, sp, r2
   b6494:	681b      	ldr	r3, [r3, #0]
   b6496:	4620      	mov	r0, r4
   b6498:	4798      	blx	r3
    delay(10);
   b649a:	200a      	movs	r0, #10
   b649c:	f000 facc 	bl	b6a38 <delay>
    
    if(readAck(14)!= 1){
   b64a0:	6823      	ldr	r3, [r4, #0]
   b64a2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   b64a6:	685b      	ldr	r3, [r3, #4]
   b64a8:	210e      	movs	r1, #14
   b64aa:	4620      	mov	r0, r4
   b64ac:	4798      	blx	r3
   b64ae:	b120      	cbz	r0, b64ba <_ZN17DFRobot_PN532_IIC5beginEv+0x62>
        
        return false;
    }
    return  ( receiveACK[12] == 0x15);
   b64b0:	7c20      	ldrb	r0, [r4, #16]
   b64b2:	f1a0 0315 	sub.w	r3, r0, #21
   b64b6:	4258      	negs	r0, r3
   b64b8:	4158      	adcs	r0, r3
}
   b64ba:	b003      	add	sp, #12
   b64bc:	bd30      	pop	{r4, r5, pc}
	...

000b64c0 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
   b64c0:	b508      	push	{r3, lr}
   b64c2:	4b02      	ldr	r3, [pc, #8]	; (b64cc <os_mutex_recursive_create+0xc>)
   b64c4:	681b      	ldr	r3, [r3, #0]
   b64c6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b64c8:	9301      	str	r3, [sp, #4]
   b64ca:	bd08      	pop	{r3, pc}
   b64cc:	00030248 	.word	0x00030248

000b64d0 <HAL_Core_Runtime_Info>:
DYNALIB_FN(16, hal_core, hal_watchdog_reset_flagged_deprecated, bool(void))
DYNALIB_FN(17, hal_core, hal_watchdog_refresh_deprecated, void(void))
DYNALIB_FN(18, hal_core, HAL_Bootloader_Get_Flag, uint16_t(BootloaderFlag))
DYNALIB_FN(19, hal_core, HAL_Bootloader_Lock, void(bool))
DYNALIB_FN(20, hal_core, HAL_Core_System_Reset_FlagSet, bool(RESET_TypeDef))
DYNALIB_FN(21, hal_core, HAL_Core_Runtime_Info, uint32_t(runtime_info_t*, void*))
   b64d0:	b508      	push	{r3, lr}
   b64d2:	4b02      	ldr	r3, [pc, #8]	; (b64dc <HAL_Core_Runtime_Info+0xc>)
   b64d4:	681b      	ldr	r3, [r3, #0]
   b64d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   b64d8:	9301      	str	r3, [sp, #4]
   b64da:	bd08      	pop	{r3, pc}
   b64dc:	00030234 	.word	0x00030234

000b64e0 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > PLATFORM_GCC
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
   b64e0:	b508      	push	{r3, lr}
   b64e2:	4b02      	ldr	r3, [pc, #8]	; (b64ec <HAL_RNG_GetRandomNumber+0xc>)
   b64e4:	681b      	ldr	r3, [r3, #0]
   b64e6:	685b      	ldr	r3, [r3, #4]
   b64e8:	9301      	str	r3, [sp, #4]
   b64ea:	bd08      	pop	{r3, pc}
   b64ec:	00030218 	.word	0x00030218

000b64f0 <HAL_Timer_Get_Milli_Seconds>:
#endif // PLATFORM_ID > PLATFORM_GCC

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
   b64f0:	b508      	push	{r3, lr}
   b64f2:	4b02      	ldr	r3, [pc, #8]	; (b64fc <HAL_Timer_Get_Milli_Seconds+0xc>)
   b64f4:	681b      	ldr	r3, [r3, #0]
   b64f6:	695b      	ldr	r3, [r3, #20]
   b64f8:	9301      	str	r3, [sp, #4]
   b64fa:	bd08      	pop	{r3, pc}
   b64fc:	00030218 	.word	0x00030218

000b6500 <hal_rtc_time_is_valid>:
DYNALIB_FN(BASE_IDX + 15, hal, HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal, HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal, HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal, HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal, HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, hal_rtc_time_is_valid, bool(void*))
   b6500:	b508      	push	{r3, lr}
   b6502:	4b02      	ldr	r3, [pc, #8]	; (b650c <hal_rtc_time_is_valid+0xc>)
   b6504:	681b      	ldr	r3, [r3, #0]
   b6506:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   b6508:	9301      	str	r3, [sp, #4]
   b650a:	bd08      	pop	{r3, pc}
   b650c:	00030218 	.word	0x00030218

000b6510 <hal_rtc_get_time>:

DYNALIB_FN(BASE_IDX + 21, hal, hal_timer_millis, uint64_t(void*))
DYNALIB_FN(BASE_IDX + 22, hal, hal_timer_micros, uint64_t(void*))

DYNALIB_FN(BASE_IDX + 23, hal, hal_rtc_get_time, int(struct timeval*, void*))
   b6510:	b508      	push	{r3, lr}
   b6512:	4b02      	ldr	r3, [pc, #8]	; (b651c <hal_rtc_get_time+0xc>)
   b6514:	681b      	ldr	r3, [r3, #0]
   b6516:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   b6518:	9301      	str	r3, [sp, #4]
   b651a:	bd08      	pop	{r3, pc}
   b651c:	00030218 	.word	0x00030218

000b6520 <hal_gpio_mode>:

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, hal_pin_map, hal_pin_info_t*(void))
DYNALIB_FN(1, hal_gpio, hal_pin_validate_function, PinFunction(hal_pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, hal_gpio_mode, void(hal_pin_t, PinMode))
   b6520:	b508      	push	{r3, lr}
   b6522:	4b02      	ldr	r3, [pc, #8]	; (b652c <hal_gpio_mode+0xc>)
   b6524:	681b      	ldr	r3, [r3, #0]
   b6526:	689b      	ldr	r3, [r3, #8]
   b6528:	9301      	str	r3, [sp, #4]
   b652a:	bd08      	pop	{r3, pc}
   b652c:	0003022c 	.word	0x0003022c

000b6530 <hal_gpio_get_mode>:
DYNALIB_FN(3, hal_gpio, hal_gpio_get_mode, PinMode(hal_pin_t))
   b6530:	b508      	push	{r3, lr}
   b6532:	4b02      	ldr	r3, [pc, #8]	; (b653c <hal_gpio_get_mode+0xc>)
   b6534:	681b      	ldr	r3, [r3, #0]
   b6536:	68db      	ldr	r3, [r3, #12]
   b6538:	9301      	str	r3, [sp, #4]
   b653a:	bd08      	pop	{r3, pc}
   b653c:	0003022c 	.word	0x0003022c

000b6540 <hal_gpio_write>:
DYNALIB_FN(4, hal_gpio, hal_gpio_write, void(hal_pin_t, uint8_t))
   b6540:	b508      	push	{r3, lr}
   b6542:	4b02      	ldr	r3, [pc, #8]	; (b654c <hal_gpio_write+0xc>)
   b6544:	681b      	ldr	r3, [r3, #0]
   b6546:	691b      	ldr	r3, [r3, #16]
   b6548:	9301      	str	r3, [sp, #4]
   b654a:	bd08      	pop	{r3, pc}
   b654c:	0003022c 	.word	0x0003022c

000b6550 <hal_gpio_read>:
DYNALIB_FN(5, hal_gpio, hal_gpio_read, int32_t(hal_pin_t))
   b6550:	b508      	push	{r3, lr}
   b6552:	4b02      	ldr	r3, [pc, #8]	; (b655c <hal_gpio_read+0xc>)
   b6554:	681b      	ldr	r3, [r3, #0]
   b6556:	695b      	ldr	r3, [r3, #20]
   b6558:	9301      	str	r3, [sp, #4]
   b655a:	bd08      	pop	{r3, pc}
   b655c:	0003022c 	.word	0x0003022c

000b6560 <hal_i2c_begin>:
DYNALIB_BEGIN(hal_i2c)

DYNALIB_FN(0, hal_i2c, hal_i2c_set_speed, void(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(1, hal_i2c, hal_i2c_enable_dma_mode, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(2, hal_i2c, hal_i2c_stretch_clock, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
   b6560:	b508      	push	{r3, lr}
   b6562:	4b02      	ldr	r3, [pc, #8]	; (b656c <hal_i2c_begin+0xc>)
   b6564:	681b      	ldr	r3, [r3, #0]
   b6566:	68db      	ldr	r3, [r3, #12]
   b6568:	9301      	str	r3, [sp, #4]
   b656a:	bd08      	pop	{r3, pc}
   b656c:	00030228 	.word	0x00030228

000b6570 <hal_i2c_begin_transmission>:
DYNALIB_FN(4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
   b6570:	b508      	push	{r3, lr}
   b6572:	4b02      	ldr	r3, [pc, #8]	; (b657c <hal_i2c_begin_transmission+0xc>)
   b6574:	681b      	ldr	r3, [r3, #0]
   b6576:	699b      	ldr	r3, [r3, #24]
   b6578:	9301      	str	r3, [sp, #4]
   b657a:	bd08      	pop	{r3, pc}
   b657c:	00030228 	.word	0x00030228

000b6580 <hal_i2c_end_transmission>:
DYNALIB_FN(7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
   b6580:	b508      	push	{r3, lr}
   b6582:	4b02      	ldr	r3, [pc, #8]	; (b658c <hal_i2c_end_transmission+0xc>)
   b6584:	681b      	ldr	r3, [r3, #0]
   b6586:	69db      	ldr	r3, [r3, #28]
   b6588:	9301      	str	r3, [sp, #4]
   b658a:	bd08      	pop	{r3, pc}
   b658c:	00030228 	.word	0x00030228

000b6590 <hal_i2c_write>:
DYNALIB_FN(8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
   b6590:	b508      	push	{r3, lr}
   b6592:	4b02      	ldr	r3, [pc, #8]	; (b659c <hal_i2c_write+0xc>)
   b6594:	681b      	ldr	r3, [r3, #0]
   b6596:	6a1b      	ldr	r3, [r3, #32]
   b6598:	9301      	str	r3, [sp, #4]
   b659a:	bd08      	pop	{r3, pc}
   b659c:	00030228 	.word	0x00030228

000b65a0 <hal_i2c_available>:
DYNALIB_FN(9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
   b65a0:	b508      	push	{r3, lr}
   b65a2:	4b02      	ldr	r3, [pc, #8]	; (b65ac <hal_i2c_available+0xc>)
   b65a4:	681b      	ldr	r3, [r3, #0]
   b65a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   b65a8:	9301      	str	r3, [sp, #4]
   b65aa:	bd08      	pop	{r3, pc}
   b65ac:	00030228 	.word	0x00030228

000b65b0 <hal_i2c_read>:
DYNALIB_FN(10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
   b65b0:	b508      	push	{r3, lr}
   b65b2:	4b02      	ldr	r3, [pc, #8]	; (b65bc <hal_i2c_read+0xc>)
   b65b4:	681b      	ldr	r3, [r3, #0]
   b65b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   b65b8:	9301      	str	r3, [sp, #4]
   b65ba:	bd08      	pop	{r3, pc}
   b65bc:	00030228 	.word	0x00030228

000b65c0 <hal_i2c_peek>:
DYNALIB_FN(11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
   b65c0:	b508      	push	{r3, lr}
   b65c2:	4b02      	ldr	r3, [pc, #8]	; (b65cc <hal_i2c_peek+0xc>)
   b65c4:	681b      	ldr	r3, [r3, #0]
   b65c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b65c8:	9301      	str	r3, [sp, #4]
   b65ca:	bd08      	pop	{r3, pc}
   b65cc:	00030228 	.word	0x00030228

000b65d0 <hal_i2c_flush>:
DYNALIB_FN(12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
   b65d0:	b508      	push	{r3, lr}
   b65d2:	4b02      	ldr	r3, [pc, #8]	; (b65dc <hal_i2c_flush+0xc>)
   b65d4:	681b      	ldr	r3, [r3, #0]
   b65d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b65d8:	9301      	str	r3, [sp, #4]
   b65da:	bd08      	pop	{r3, pc}
   b65dc:	00030228 	.word	0x00030228

000b65e0 <hal_i2c_is_enabled>:
DYNALIB_FN(13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
   b65e0:	b508      	push	{r3, lr}
   b65e2:	4b02      	ldr	r3, [pc, #8]	; (b65ec <hal_i2c_is_enabled+0xc>)
   b65e4:	681b      	ldr	r3, [r3, #0]
   b65e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   b65e8:	9301      	str	r3, [sp, #4]
   b65ea:	bd08      	pop	{r3, pc}
   b65ec:	00030228 	.word	0x00030228

000b65f0 <hal_i2c_init>:
DYNALIB_FN(14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
   b65f0:	b508      	push	{r3, lr}
   b65f2:	4b02      	ldr	r3, [pc, #8]	; (b65fc <hal_i2c_init+0xc>)
   b65f4:	681b      	ldr	r3, [r3, #0]
   b65f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b65f8:	9301      	str	r3, [sp, #4]
   b65fa:	bd08      	pop	{r3, pc}
   b65fc:	00030228 	.word	0x00030228

000b6600 <hal_i2c_request_ex>:
DYNALIB_FN(17, hal_i2c, hal_i2c_reset, int(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(18, hal_i2c, hal_i2c_lock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(19, hal_i2c, hal_i2c_unlock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(20, hal_i2c, hal_i2c_request_ex, int32_t(hal_i2c_interface_t, const hal_i2c_transmission_config_t*, void*))
   b6600:	b508      	push	{r3, lr}
   b6602:	4b02      	ldr	r3, [pc, #8]	; (b660c <hal_i2c_request_ex+0xc>)
   b6604:	681b      	ldr	r3, [r3, #0]
   b6606:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   b6608:	9301      	str	r3, [sp, #4]
   b660a:	bd08      	pop	{r3, pc}
   b660c:	00030228 	.word	0x00030228

000b6610 <inet_inet_ntop>:
DYNALIB_FN(0, hal_inet, inet_inet_addr, in_addr_t(const char*))
DYNALIB_FN(1, hal_inet, inet_inet_aton, int(const char*, struct in_addr*))
DYNALIB_FN(2, hal_inet, inet_inet_network, in_addr_t(const char*))
DYNALIB_FN(3, hal_inet, inet_inet_ntoa, char*(struct in_addr))
DYNALIB_FN(4, hal_inet, inet_inet_ntoa_r, char*(struct in_addr, char*, socklen_t))
DYNALIB_FN(5, hal_inet, inet_inet_ntop, const char*(int, const void*, char*, socklen_t))
   b6610:	b508      	push	{r3, lr}
   b6612:	4b02      	ldr	r3, [pc, #8]	; (b661c <inet_inet_ntop+0xc>)
   b6614:	681b      	ldr	r3, [r3, #0]
   b6616:	695b      	ldr	r3, [r3, #20]
   b6618:	9301      	str	r3, [sp, #4]
   b661a:	bd08      	pop	{r3, pc}
   b661c:	00030264 	.word	0x00030264

000b6620 <netdb_freeaddrinfo>:

DYNALIB_BEGIN(hal_netdb)

DYNALIB_FN(0, hal_netdb, netdb_gethostbyname, struct hostent*(const char*))
DYNALIB_FN(1, hal_netdb, netdb_gethostbyname_r, int(const char*, struct hostent*, char*, size_t, struct hostent**, int*))
DYNALIB_FN(2, hal_netdb, netdb_freeaddrinfo, void(struct addrinfo*))
   b6620:	b508      	push	{r3, lr}
   b6622:	4b02      	ldr	r3, [pc, #8]	; (b662c <netdb_freeaddrinfo+0xc>)
   b6624:	681b      	ldr	r3, [r3, #0]
   b6626:	689b      	ldr	r3, [r3, #8]
   b6628:	9301      	str	r3, [sp, #4]
   b662a:	bd08      	pop	{r3, pc}
   b662c:	00030268 	.word	0x00030268

000b6630 <netdb_getaddrinfo>:
DYNALIB_FN(3, hal_netdb, netdb_getaddrinfo, int(const char*, const char*, const struct addrinfo*, struct addrinfo**))
   b6630:	b508      	push	{r3, lr}
   b6632:	4b02      	ldr	r3, [pc, #8]	; (b663c <netdb_getaddrinfo+0xc>)
   b6634:	681b      	ldr	r3, [r3, #0]
   b6636:	68db      	ldr	r3, [r3, #12]
   b6638:	9301      	str	r3, [sp, #4]
   b663a:	bd08      	pop	{r3, pc}
   b663c:	00030268 	.word	0x00030268

000b6640 <hal_spi_begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, hal_spi_begin, void(hal_spi_interface_t, uint16_t))
   b6640:	b508      	push	{r3, lr}
   b6642:	4b02      	ldr	r3, [pc, #8]	; (b664c <hal_spi_begin+0xc>)
   b6644:	681b      	ldr	r3, [r3, #0]
   b6646:	681b      	ldr	r3, [r3, #0]
   b6648:	9301      	str	r3, [sp, #4]
   b664a:	bd08      	pop	{r3, pc}
   b664c:	00030230 	.word	0x00030230

000b6650 <hal_spi_transfer>:
DYNALIB_FN(1, hal_spi, hal_spi_end, void(hal_spi_interface_t))
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
   b6650:	b508      	push	{r3, lr}
   b6652:	4b02      	ldr	r3, [pc, #8]	; (b665c <hal_spi_transfer+0xc>)
   b6654:	681b      	ldr	r3, [r3, #0]
   b6656:	695b      	ldr	r3, [r3, #20]
   b6658:	9301      	str	r3, [sp, #4]
   b665a:	bd08      	pop	{r3, pc}
   b665c:	00030230 	.word	0x00030230

000b6660 <hal_spi_init>:
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
   b6660:	b508      	push	{r3, lr}
   b6662:	4b02      	ldr	r3, [pc, #8]	; (b666c <hal_spi_init+0xc>)
   b6664:	681b      	ldr	r3, [r3, #0]
   b6666:	69db      	ldr	r3, [r3, #28]
   b6668:	9301      	str	r3, [sp, #4]
   b666a:	bd08      	pop	{r3, pc}
   b666c:	00030230 	.word	0x00030230

000b6670 <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
   b6670:	b508      	push	{r3, lr}
   b6672:	4b02      	ldr	r3, [pc, #8]	; (b667c <hal_spi_is_enabled+0xc>)
   b6674:	681b      	ldr	r3, [r3, #0]
   b6676:	6a1b      	ldr	r3, [r3, #32]
   b6678:	9301      	str	r3, [sp, #4]
   b667a:	bd08      	pop	{r3, pc}
   b667c:	00030230 	.word	0x00030230

000b6680 <hal_spi_info>:
DYNALIB_FN(9, hal_spi, hal_spi_info, void(hal_spi_interface_t, hal_spi_info_t*, void*))
   b6680:	b508      	push	{r3, lr}
   b6682:	4b02      	ldr	r3, [pc, #8]	; (b668c <hal_spi_info+0xc>)
   b6684:	681b      	ldr	r3, [r3, #0]
   b6686:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   b6688:	9301      	str	r3, [sp, #4]
   b668a:	bd08      	pop	{r3, pc}
   b668c:	00030230 	.word	0x00030230

000b6690 <hal_spi_set_settings>:
DYNALIB_FN(10, hal_spi, hal_spi_transfer_dma, void(hal_spi_interface_t, const void*, void*, uint32_t, hal_spi_dma_user_callback))
DYNALIB_FN(11, hal_spi, hal_spi_begin_ext, void(hal_spi_interface_t, hal_spi_mode_t, uint16_t, const hal_spi_config_t*))
DYNALIB_FN(12, hal_spi, hal_spi_set_callback_on_selected, void(hal_spi_interface_t, hal_spi_select_user_callback, void*))
DYNALIB_FN(13, hal_spi, hal_spi_transfer_dma_cancel, void(hal_spi_interface_t))
DYNALIB_FN(14, hal_spi, hal_spi_transfer_dma_status, int32_t(hal_spi_interface_t, hal_spi_transfer_status_t*))
DYNALIB_FN(15, hal_spi, hal_spi_set_settings, int32_t(hal_spi_interface_t, uint8_t, uint8_t, uint8_t, uint8_t, void*))
   b6690:	b508      	push	{r3, lr}
   b6692:	4b02      	ldr	r3, [pc, #8]	; (b669c <hal_spi_set_settings+0xc>)
   b6694:	681b      	ldr	r3, [r3, #0]
   b6696:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   b6698:	9301      	str	r3, [sp, #4]
   b669a:	bd08      	pop	{r3, pc}
   b669c:	00030230 	.word	0x00030230

000b66a0 <hal_spi_acquire>:
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
DYNALIB_FN(16, hal_spi, hal_spi_acquire, int32_t(hal_spi_interface_t, const hal_spi_acquire_config_t*))
   b66a0:	b508      	push	{r3, lr}
   b66a2:	4b02      	ldr	r3, [pc, #8]	; (b66ac <hal_spi_acquire+0xc>)
   b66a4:	681b      	ldr	r3, [r3, #0]
   b66a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b66a8:	9301      	str	r3, [sp, #4]
   b66aa:	bd08      	pop	{r3, pc}
   b66ac:	00030230 	.word	0x00030230

000b66b0 <hal_spi_release>:
DYNALIB_FN(17, hal_spi, hal_spi_release, int32_t(hal_spi_interface_t, void*))
   b66b0:	b508      	push	{r3, lr}
   b66b2:	4b02      	ldr	r3, [pc, #8]	; (b66bc <hal_spi_release+0xc>)
   b66b4:	681b      	ldr	r3, [r3, #0]
   b66b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b66b8:	9301      	str	r3, [sp, #4]
   b66ba:	bd08      	pop	{r3, pc}
   b66bc:	00030230 	.word	0x00030230

000b66c0 <hal_usart_write>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
   b66c0:	b508      	push	{r3, lr}
   b66c2:	4b02      	ldr	r3, [pc, #8]	; (b66cc <hal_usart_write+0xc>)
   b66c4:	681b      	ldr	r3, [r3, #0]
   b66c6:	68db      	ldr	r3, [r3, #12]
   b66c8:	9301      	str	r3, [sp, #4]
   b66ca:	bd08      	pop	{r3, pc}
   b66cc:	0003023c 	.word	0x0003023c

000b66d0 <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
   b66d0:	b508      	push	{r3, lr}
   b66d2:	4b02      	ldr	r3, [pc, #8]	; (b66dc <hal_usart_available+0xc>)
   b66d4:	681b      	ldr	r3, [r3, #0]
   b66d6:	691b      	ldr	r3, [r3, #16]
   b66d8:	9301      	str	r3, [sp, #4]
   b66da:	bd08      	pop	{r3, pc}
   b66dc:	0003023c 	.word	0x0003023c

000b66e0 <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
   b66e0:	b508      	push	{r3, lr}
   b66e2:	4b02      	ldr	r3, [pc, #8]	; (b66ec <hal_usart_read+0xc>)
   b66e4:	681b      	ldr	r3, [r3, #0]
   b66e6:	695b      	ldr	r3, [r3, #20]
   b66e8:	9301      	str	r3, [sp, #4]
   b66ea:	bd08      	pop	{r3, pc}
   b66ec:	0003023c 	.word	0x0003023c

000b66f0 <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
   b66f0:	b508      	push	{r3, lr}
   b66f2:	4b02      	ldr	r3, [pc, #8]	; (b66fc <hal_usart_peek+0xc>)
   b66f4:	681b      	ldr	r3, [r3, #0]
   b66f6:	699b      	ldr	r3, [r3, #24]
   b66f8:	9301      	str	r3, [sp, #4]
   b66fa:	bd08      	pop	{r3, pc}
   b66fc:	0003023c 	.word	0x0003023c

000b6700 <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
   b6700:	b508      	push	{r3, lr}
   b6702:	4b02      	ldr	r3, [pc, #8]	; (b670c <hal_usart_flush+0xc>)
   b6704:	681b      	ldr	r3, [r3, #0]
   b6706:	69db      	ldr	r3, [r3, #28]
   b6708:	9301      	str	r3, [sp, #4]
   b670a:	bd08      	pop	{r3, pc}
   b670c:	0003023c 	.word	0x0003023c

000b6710 <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
   b6710:	b508      	push	{r3, lr}
   b6712:	4b02      	ldr	r3, [pc, #8]	; (b671c <hal_usart_is_enabled+0xc>)
   b6714:	681b      	ldr	r3, [r3, #0]
   b6716:	6a1b      	ldr	r3, [r3, #32]
   b6718:	9301      	str	r3, [sp, #4]
   b671a:	bd08      	pop	{r3, pc}
   b671c:	0003023c 	.word	0x0003023c

000b6720 <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
   b6720:	b508      	push	{r3, lr}
   b6722:	4b02      	ldr	r3, [pc, #8]	; (b672c <hal_usart_available_data_for_write+0xc>)
   b6724:	681b      	ldr	r3, [r3, #0]
   b6726:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   b6728:	9301      	str	r3, [sp, #4]
   b672a:	bd08      	pop	{r3, pc}
   b672c:	0003023c 	.word	0x0003023c

000b6730 <hal_usart_init_ex>:
DYNALIB_FN(BASE_IDX2 + 0, hal_usart, hal_usart_begin_config, void(hal_usart_interface_t serial, uint32_t baud, uint32_t config, void *ptr))
DYNALIB_FN(BASE_IDX2 + 1, hal_usart, hal_usart_write_nine_bits, uint32_t(hal_usart_interface_t serial, uint16_t data))
DYNALIB_FN(BASE_IDX2 + 2, hal_usart, hal_usart_send_break, void(hal_usart_interface_t, void*))
DYNALIB_FN(BASE_IDX2 + 3, hal_usart, hal_usart_break_detected, uint8_t(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX2 + 4, hal_usart, hal_usart_sleep, int(hal_usart_interface_t serial, bool, void*))
DYNALIB_FN(BASE_IDX2 + 5, hal_usart, hal_usart_init_ex, int(hal_usart_interface_t, const hal_usart_buffer_config_t*, void*))
   b6730:	b508      	push	{r3, lr}
   b6732:	4b02      	ldr	r3, [pc, #8]	; (b673c <hal_usart_init_ex+0xc>)
   b6734:	681b      	ldr	r3, [r3, #0]
   b6736:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b6738:	9301      	str	r3, [sp, #4]
   b673a:	bd08      	pop	{r3, pc}
   b673c:	0003023c 	.word	0x0003023c

000b6740 <HAL_USB_USART_Init>:
// GNINRAW

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
   b6740:	b508      	push	{r3, lr}
   b6742:	4b02      	ldr	r3, [pc, #8]	; (b674c <HAL_USB_USART_Init+0xc>)
   b6744:	681b      	ldr	r3, [r3, #0]
   b6746:	681b      	ldr	r3, [r3, #0]
   b6748:	9301      	str	r3, [sp, #4]
   b674a:	bd08      	pop	{r3, pc}
   b674c:	0003024c 	.word	0x0003024c

000b6750 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
   b6750:	b508      	push	{r3, lr}
   b6752:	4b02      	ldr	r3, [pc, #8]	; (b675c <HAL_USB_USART_Begin+0xc>)
   b6754:	681b      	ldr	r3, [r3, #0]
   b6756:	685b      	ldr	r3, [r3, #4]
   b6758:	9301      	str	r3, [sp, #4]
   b675a:	bd08      	pop	{r3, pc}
   b675c:	0003024c 	.word	0x0003024c

000b6760 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
   b6760:	b508      	push	{r3, lr}
   b6762:	4b02      	ldr	r3, [pc, #8]	; (b676c <HAL_USB_USART_Available_Data+0xc>)
   b6764:	681b      	ldr	r3, [r3, #0]
   b6766:	691b      	ldr	r3, [r3, #16]
   b6768:	9301      	str	r3, [sp, #4]
   b676a:	bd08      	pop	{r3, pc}
   b676c:	0003024c 	.word	0x0003024c

000b6770 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
   b6770:	b508      	push	{r3, lr}
   b6772:	4b02      	ldr	r3, [pc, #8]	; (b677c <HAL_USB_USART_Available_Data_For_Write+0xc>)
   b6774:	681b      	ldr	r3, [r3, #0]
   b6776:	695b      	ldr	r3, [r3, #20]
   b6778:	9301      	str	r3, [sp, #4]
   b677a:	bd08      	pop	{r3, pc}
   b677c:	0003024c 	.word	0x0003024c

000b6780 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   b6780:	b508      	push	{r3, lr}
   b6782:	4b02      	ldr	r3, [pc, #8]	; (b678c <HAL_USB_USART_Receive_Data+0xc>)
   b6784:	681b      	ldr	r3, [r3, #0]
   b6786:	699b      	ldr	r3, [r3, #24]
   b6788:	9301      	str	r3, [sp, #4]
   b678a:	bd08      	pop	{r3, pc}
   b678c:	0003024c 	.word	0x0003024c

000b6790 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   b6790:	b508      	push	{r3, lr}
   b6792:	4b02      	ldr	r3, [pc, #8]	; (b679c <HAL_USB_USART_Send_Data+0xc>)
   b6794:	681b      	ldr	r3, [r3, #0]
   b6796:	69db      	ldr	r3, [r3, #28]
   b6798:	9301      	str	r3, [sp, #4]
   b679a:	bd08      	pop	{r3, pc}
   b679c:	0003024c 	.word	0x0003024c

000b67a0 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
   b67a0:	b508      	push	{r3, lr}
   b67a2:	4b02      	ldr	r3, [pc, #8]	; (b67ac <HAL_USB_USART_Flush_Data+0xc>)
   b67a4:	681b      	ldr	r3, [r3, #0]
   b67a6:	6a1b      	ldr	r3, [r3, #32]
   b67a8:	9301      	str	r3, [sp, #4]
   b67aa:	bd08      	pop	{r3, pc}
   b67ac:	0003024c 	.word	0x0003024c

000b67b0 <system_mode>:
#include "system_ble_prov.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
   b67b0:	b508      	push	{r3, lr}
   b67b2:	4b02      	ldr	r3, [pc, #8]	; (b67bc <system_mode+0xc>)
   b67b4:	681b      	ldr	r3, [r3, #0]
   b67b6:	681b      	ldr	r3, [r3, #0]
   b67b8:	9301      	str	r3, [sp, #4]
   b67ba:	bd08      	pop	{r3, pc}
   b67bc:	00030220 	.word	0x00030220

000b67c0 <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
   b67c0:	b508      	push	{r3, lr}
   b67c2:	4b02      	ldr	r3, [pc, #8]	; (b67cc <set_system_mode+0xc>)
   b67c4:	681b      	ldr	r3, [r3, #0]
   b67c6:	685b      	ldr	r3, [r3, #4]
   b67c8:	9301      	str	r3, [sp, #4]
   b67ca:	bd08      	pop	{r3, pc}
   b67cc:	00030220 	.word	0x00030220

000b67d0 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
   b67d0:	b508      	push	{r3, lr}
   b67d2:	4b02      	ldr	r3, [pc, #8]	; (b67dc <system_delay_ms+0xc>)
   b67d4:	681b      	ldr	r3, [r3, #0]
   b67d6:	695b      	ldr	r3, [r3, #20]
   b67d8:	9301      	str	r3, [sp, #4]
   b67da:	bd08      	pop	{r3, pc}
   b67dc:	00030220 	.word	0x00030220

000b67e0 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
   b67e0:	b508      	push	{r3, lr}
   b67e2:	4b02      	ldr	r3, [pc, #8]	; (b67ec <application_thread_current+0xc>)
   b67e4:	681b      	ldr	r3, [r3, #0]
   b67e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   b67e8:	9301      	str	r3, [sp, #4]
   b67ea:	bd08      	pop	{r3, pc}
   b67ec:	00030220 	.word	0x00030220

000b67f0 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
   b67f0:	b508      	push	{r3, lr}
   b67f2:	4b02      	ldr	r3, [pc, #8]	; (b67fc <application_thread_invoke+0xc>)
   b67f4:	681b      	ldr	r3, [r3, #0]
   b67f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   b67f8:	9301      	str	r3, [sp, #4]
   b67fa:	bd08      	pop	{r3, pc}
   b67fc:	00030220 	.word	0x00030220

000b6800 <system_thread_get_state>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
   b6800:	b508      	push	{r3, lr}
   b6802:	4b02      	ldr	r3, [pc, #8]	; (b680c <system_thread_get_state+0xc>)
   b6804:	681b      	ldr	r3, [r3, #0]
   b6806:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   b6808:	9301      	str	r3, [sp, #4]
   b680a:	bd08      	pop	{r3, pc}
   b680c:	00030220 	.word	0x00030220

000b6810 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
   b6810:	b508      	push	{r3, lr}
   b6812:	4b03      	ldr	r3, [pc, #12]	; (b6820 <system_ctrl_set_app_request_handler+0x10>)
   b6814:	681b      	ldr	r3, [r3, #0]
   b6816:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   b681a:	9301      	str	r3, [sp, #4]
   b681c:	bd08      	pop	{r3, pc}
   b681e:	0000      	.short	0x0000
   b6820:	00030220 	.word	0x00030220

000b6824 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
   b6824:	b508      	push	{r3, lr}
   b6826:	4b03      	ldr	r3, [pc, #12]	; (b6834 <system_ctrl_set_result+0x10>)
   b6828:	681b      	ldr	r3, [r3, #0]
   b682a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   b682e:	9301      	str	r3, [sp, #4]
   b6830:	bd08      	pop	{r3, pc}
   b6832:	0000      	.short	0x0000
   b6834:	00030220 	.word	0x00030220

000b6838 <spark_process>:

DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
DYNALIB_FN(2, system_cloud, spark_process, bool(void))
   b6838:	b508      	push	{r3, lr}
   b683a:	4b02      	ldr	r3, [pc, #8]	; (b6844 <spark_process+0xc>)
   b683c:	681b      	ldr	r3, [r3, #0]
   b683e:	689b      	ldr	r3, [r3, #8]
   b6840:	9301      	str	r3, [sp, #4]
   b6842:	bd08      	pop	{r3, pc}
   b6844:	00030244 	.word	0x00030244

000b6848 <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
   b6848:	b508      	push	{r3, lr}
   b684a:	4b02      	ldr	r3, [pc, #8]	; (b6854 <spark_cloud_flag_connect+0xc>)
   b684c:	681b      	ldr	r3, [r3, #0]
   b684e:	68db      	ldr	r3, [r3, #12]
   b6850:	9301      	str	r3, [sp, #4]
   b6852:	bd08      	pop	{r3, pc}
   b6854:	00030244 	.word	0x00030244

000b6858 <spark_cloud_flag_connected>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
   b6858:	b508      	push	{r3, lr}
   b685a:	4b02      	ldr	r3, [pc, #8]	; (b6864 <spark_cloud_flag_connected+0xc>)
   b685c:	681b      	ldr	r3, [r3, #0]
   b685e:	695b      	ldr	r3, [r3, #20]
   b6860:	9301      	str	r3, [sp, #4]
   b6862:	bd08      	pop	{r3, pc}
   b6864:	00030244 	.word	0x00030244

000b6868 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
   b6868:	b508      	push	{r3, lr}
   b686a:	4b02      	ldr	r3, [pc, #8]	; (b6874 <spark_send_event+0xc>)
   b686c:	681b      	ldr	r3, [r3, #0]
   b686e:	6a1b      	ldr	r3, [r3, #32]
   b6870:	9301      	str	r3, [sp, #4]
   b6872:	bd08      	pop	{r3, pc}
   b6874:	00030244 	.word	0x00030244

000b6878 <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
   b6878:	b508      	push	{r3, lr}
   b687a:	4b02      	ldr	r3, [pc, #8]	; (b6884 <spark_subscribe+0xc>)
   b687c:	681b      	ldr	r3, [r3, #0]
   b687e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   b6880:	9301      	str	r3, [sp, #4]
   b6882:	bd08      	pop	{r3, pc}
   b6884:	00030244 	.word	0x00030244

000b6888 <spark_sync_time_pending>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
   b6888:	b508      	push	{r3, lr}
   b688a:	4b02      	ldr	r3, [pc, #8]	; (b6894 <spark_sync_time_pending+0xc>)
   b688c:	681b      	ldr	r3, [r3, #0]
   b688e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b6890:	9301      	str	r3, [sp, #4]
   b6892:	bd08      	pop	{r3, pc}
   b6894:	00030244 	.word	0x00030244

000b6898 <spark_set_connection_property>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
   b6898:	b508      	push	{r3, lr}
   b689a:	4b02      	ldr	r3, [pc, #8]	; (b68a4 <spark_set_connection_property+0xc>)
   b689c:	681b      	ldr	r3, [r3, #0]
   b689e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   b68a0:	9301      	str	r3, [sp, #4]
   b68a2:	bd08      	pop	{r3, pc}
   b68a4:	00030244 	.word	0x00030244

000b68a8 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
   b68a8:	b508      	push	{r3, lr}
   b68aa:	4b02      	ldr	r3, [pc, #8]	; (b68b4 <spark_set_random_seed_from_cloud_handler+0xc>)
   b68ac:	681b      	ldr	r3, [r3, #0]
   b68ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   b68b0:	9301      	str	r3, [sp, #4]
   b68b2:	bd08      	pop	{r3, pc}
   b68b4:	00030244 	.word	0x00030244

000b68b8 <spark_cloud_disconnect>:
DYNALIB_FN(16, system_cloud, spark_publish_vitals, int(system_tick_t, void*))
DYNALIB_FN(17, system_cloud, spark_cloud_disconnect, int(const spark_cloud_disconnect_options*, void*))
   b68b8:	b508      	push	{r3, lr}
   b68ba:	4b02      	ldr	r3, [pc, #8]	; (b68c4 <spark_cloud_disconnect+0xc>)
   b68bc:	681b      	ldr	r3, [r3, #0]
   b68be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b68c0:	9301      	str	r3, [sp, #4]
   b68c2:	bd08      	pop	{r3, pc}
   b68c4:	00030244 	.word	0x00030244

000b68c8 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
   b68c8:	b508      	push	{r3, lr}
   b68ca:	4b02      	ldr	r3, [pc, #8]	; (b68d4 <network_connect+0xc>)
   b68cc:	681b      	ldr	r3, [r3, #0]
   b68ce:	685b      	ldr	r3, [r3, #4]
   b68d0:	9301      	str	r3, [sp, #4]
   b68d2:	bd08      	pop	{r3, pc}
   b68d4:	00030240 	.word	0x00030240

000b68d8 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
   b68d8:	b508      	push	{r3, lr}
   b68da:	4b02      	ldr	r3, [pc, #8]	; (b68e4 <network_connecting+0xc>)
   b68dc:	681b      	ldr	r3, [r3, #0]
   b68de:	689b      	ldr	r3, [r3, #8]
   b68e0:	9301      	str	r3, [sp, #4]
   b68e2:	bd08      	pop	{r3, pc}
   b68e4:	00030240 	.word	0x00030240

000b68e8 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
   b68e8:	b508      	push	{r3, lr}
   b68ea:	4b02      	ldr	r3, [pc, #8]	; (b68f4 <network_disconnect+0xc>)
   b68ec:	681b      	ldr	r3, [r3, #0]
   b68ee:	68db      	ldr	r3, [r3, #12]
   b68f0:	9301      	str	r3, [sp, #4]
   b68f2:	bd08      	pop	{r3, pc}
   b68f4:	00030240 	.word	0x00030240

000b68f8 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
   b68f8:	b508      	push	{r3, lr}
   b68fa:	4b02      	ldr	r3, [pc, #8]	; (b6904 <network_ready+0xc>)
   b68fc:	681b      	ldr	r3, [r3, #0]
   b68fe:	691b      	ldr	r3, [r3, #16]
   b6900:	9301      	str	r3, [sp, #4]
   b6902:	bd08      	pop	{r3, pc}
   b6904:	00030240 	.word	0x00030240

000b6908 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
   b6908:	b508      	push	{r3, lr}
   b690a:	4b02      	ldr	r3, [pc, #8]	; (b6914 <network_on+0xc>)
   b690c:	681b      	ldr	r3, [r3, #0]
   b690e:	695b      	ldr	r3, [r3, #20]
   b6910:	9301      	str	r3, [sp, #4]
   b6912:	bd08      	pop	{r3, pc}
   b6914:	00030240 	.word	0x00030240

000b6918 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
   b6918:	b508      	push	{r3, lr}
   b691a:	4b02      	ldr	r3, [pc, #8]	; (b6924 <network_off+0xc>)
   b691c:	681b      	ldr	r3, [r3, #0]
   b691e:	699b      	ldr	r3, [r3, #24]
   b6920:	9301      	str	r3, [sp, #4]
   b6922:	bd08      	pop	{r3, pc}
   b6924:	00030240 	.word	0x00030240

000b6928 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
   b6928:	b508      	push	{r3, lr}
   b692a:	4b02      	ldr	r3, [pc, #8]	; (b6934 <network_listen+0xc>)
   b692c:	681b      	ldr	r3, [r3, #0]
   b692e:	69db      	ldr	r3, [r3, #28]
   b6930:	9301      	str	r3, [sp, #4]
   b6932:	bd08      	pop	{r3, pc}
   b6934:	00030240 	.word	0x00030240

000b6938 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
   b6938:	b508      	push	{r3, lr}
   b693a:	4b02      	ldr	r3, [pc, #8]	; (b6944 <network_listening+0xc>)
   b693c:	681b      	ldr	r3, [r3, #0]
   b693e:	6a1b      	ldr	r3, [r3, #32]
   b6940:	9301      	str	r3, [sp, #4]
   b6942:	bd08      	pop	{r3, pc}
   b6944:	00030240 	.word	0x00030240

000b6948 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
   b6948:	b508      	push	{r3, lr}
   b694a:	4b02      	ldr	r3, [pc, #8]	; (b6954 <network_set_listen_timeout+0xc>)
   b694c:	681b      	ldr	r3, [r3, #0]
   b694e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b6950:	9301      	str	r3, [sp, #4]
   b6952:	bd08      	pop	{r3, pc}
   b6954:	00030240 	.word	0x00030240

000b6958 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
   b6958:	b508      	push	{r3, lr}
   b695a:	4b02      	ldr	r3, [pc, #8]	; (b6964 <network_get_listen_timeout+0xc>)
   b695c:	681b      	ldr	r3, [r3, #0]
   b695e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   b6960:	9301      	str	r3, [sp, #4]
   b6962:	bd08      	pop	{r3, pc}
   b6964:	00030240 	.word	0x00030240

000b6968 <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
   b6968:	b508      	push	{r3, lr}
   b696a:	4b02      	ldr	r3, [pc, #8]	; (b6974 <network_is_on+0xc>)
   b696c:	681b      	ldr	r3, [r3, #0]
   b696e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b6970:	9301      	str	r3, [sp, #4]
   b6972:	bd08      	pop	{r3, pc}
   b6974:	00030240 	.word	0x00030240

000b6978 <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
   b6978:	b508      	push	{r3, lr}
   b697a:	4b02      	ldr	r3, [pc, #8]	; (b6984 <network_is_off+0xc>)
   b697c:	681b      	ldr	r3, [r3, #0]
   b697e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b6980:	9301      	str	r3, [sp, #4]
   b6982:	bd08      	pop	{r3, pc}
   b6984:	00030240 	.word	0x00030240

000b6988 <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
   b6988:	b508      	push	{r3, lr}
   b698a:	4b02      	ldr	r3, [pc, #8]	; (b6994 <malloc+0xc>)
   b698c:	681b      	ldr	r3, [r3, #0]
   b698e:	681b      	ldr	r3, [r3, #0]
   b6990:	9301      	str	r3, [sp, #4]
   b6992:	bd08      	pop	{r3, pc}
   b6994:	0003021c 	.word	0x0003021c

000b6998 <free>:
DYNALIB_FN(1, rt, free, void(void*))
   b6998:	b508      	push	{r3, lr}
   b699a:	4b02      	ldr	r3, [pc, #8]	; (b69a4 <free+0xc>)
   b699c:	681b      	ldr	r3, [r3, #0]
   b699e:	685b      	ldr	r3, [r3, #4]
   b69a0:	9301      	str	r3, [sp, #4]
   b69a2:	bd08      	pop	{r3, pc}
   b69a4:	0003021c 	.word	0x0003021c

000b69a8 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
   b69a8:	b508      	push	{r3, lr}
   b69aa:	4b02      	ldr	r3, [pc, #8]	; (b69b4 <realloc+0xc>)
   b69ac:	681b      	ldr	r3, [r3, #0]
   b69ae:	689b      	ldr	r3, [r3, #8]
   b69b0:	9301      	str	r3, [sp, #4]
   b69b2:	bd08      	pop	{r3, pc}
   b69b4:	0003021c 	.word	0x0003021c

000b69b8 <snprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
   b69b8:	b508      	push	{r3, lr}
   b69ba:	4b02      	ldr	r3, [pc, #8]	; (b69c4 <snprintf+0xc>)
   b69bc:	681b      	ldr	r3, [r3, #0]
   b69be:	69db      	ldr	r3, [r3, #28]
   b69c0:	9301      	str	r3, [sp, #4]
   b69c2:	bd08      	pop	{r3, pc}
   b69c4:	0003021c 	.word	0x0003021c

000b69c8 <vsnprintf>:
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
   b69c8:	b508      	push	{r3, lr}
   b69ca:	4b02      	ldr	r3, [pc, #8]	; (b69d4 <vsnprintf+0xc>)
   b69cc:	681b      	ldr	r3, [r3, #0]
   b69ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   b69d0:	9301      	str	r3, [sp, #4]
   b69d2:	bd08      	pop	{r3, pc}
   b69d4:	0003021c 	.word	0x0003021c

000b69d8 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
   b69d8:	b508      	push	{r3, lr}
   b69da:	4b02      	ldr	r3, [pc, #8]	; (b69e4 <abort+0xc>)
   b69dc:	681b      	ldr	r3, [r3, #0]
   b69de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b69e0:	9301      	str	r3, [sp, #4]
   b69e2:	bd08      	pop	{r3, pc}
   b69e4:	0003021c 	.word	0x0003021c

000b69e8 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
   b69e8:	b508      	push	{r3, lr}
   b69ea:	4b02      	ldr	r3, [pc, #8]	; (b69f4 <_malloc_r+0xc>)
   b69ec:	681b      	ldr	r3, [r3, #0]
   b69ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b69f0:	9301      	str	r3, [sp, #4]
   b69f2:	bd08      	pop	{r3, pc}
   b69f4:	0003021c 	.word	0x0003021c

000b69f8 <__errno>:
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
   b69f8:	b508      	push	{r3, lr}
   b69fa:	4b02      	ldr	r3, [pc, #8]	; (b6a04 <__errno+0xc>)
   b69fc:	681b      	ldr	r3, [r3, #0]
   b69fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   b6a00:	9301      	str	r3, [sp, #4]
   b6a02:	bd08      	pop	{r3, pc}
   b6a04:	0003021c 	.word	0x0003021c

000b6a08 <__assert_func>:

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
   b6a08:	b508      	push	{r3, lr}
   b6a0a:	4b02      	ldr	r3, [pc, #8]	; (b6a14 <__assert_func+0xc>)
   b6a0c:	681b      	ldr	r3, [r3, #0]
   b6a0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b6a10:	9301      	str	r3, [sp, #4]
   b6a12:	bd08      	pop	{r3, pc}
   b6a14:	0003021c 	.word	0x0003021c

000b6a18 <newlib_impure_ptr_callback>:
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
   b6a18:	b508      	push	{r3, lr}
   b6a1a:	4b02      	ldr	r3, [pc, #8]	; (b6a24 <newlib_impure_ptr_callback+0xc>)
   b6a1c:	681b      	ldr	r3, [r3, #0]
   b6a1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b6a20:	9301      	str	r3, [sp, #4]
   b6a22:	bd08      	pop	{r3, pc}
   b6a24:	0003021c 	.word	0x0003021c

000b6a28 <localtime_r>:

#if HAL_PLATFORM_EXPORT_STDLIB_RT_DYNALIB
DYNALIB_FN(18, rt, strftime, size_t(char* __restrict, size_t, const char* __restrict, const struct tm* __restrict))
DYNALIB_FN(19, rt, localtime_r, struct tm*(const time_t* __restrict, struct tm* __restrict))
   b6a28:	b508      	push	{r3, lr}
   b6a2a:	4b02      	ldr	r3, [pc, #8]	; (b6a34 <localtime_r+0xc>)
   b6a2c:	681b      	ldr	r3, [r3, #0]
   b6a2e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   b6a30:	9301      	str	r3, [sp, #4]
   b6a32:	bd08      	pop	{r3, pc}
   b6a34:	0003021c 	.word	0x0003021c

000b6a38 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
   b6a38:	2100      	movs	r1, #0
   b6a3a:	f7ff bec9 	b.w	b67d0 <system_delay_ms>

000b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~__shared_count() noexcept
   b6a3e:	b538      	push	{r3, r4, r5, lr}
	if (_M_pi != nullptr)
   b6a40:	6804      	ldr	r4, [r0, #0]
      ~__shared_count() noexcept
   b6a42:	4605      	mov	r5, r0
	if (_M_pi != nullptr)
   b6a44:	b17c      	cbz	r4, b6a66 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
      if (--_M_use_count == 0)
   b6a46:	6863      	ldr	r3, [r4, #4]
   b6a48:	3b01      	subs	r3, #1
   b6a4a:	6063      	str	r3, [r4, #4]
   b6a4c:	b95b      	cbnz	r3, b6a66 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
          _M_dispose();
   b6a4e:	6823      	ldr	r3, [r4, #0]
   b6a50:	4620      	mov	r0, r4
   b6a52:	689b      	ldr	r3, [r3, #8]
   b6a54:	4798      	blx	r3
          if (--_M_weak_count == 0)
   b6a56:	68a3      	ldr	r3, [r4, #8]
   b6a58:	3b01      	subs	r3, #1
   b6a5a:	60a3      	str	r3, [r4, #8]
   b6a5c:	b91b      	cbnz	r3, b6a66 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
   b6a5e:	6823      	ldr	r3, [r4, #0]
   b6a60:	4620      	mov	r0, r4
   b6a62:	68db      	ldr	r3, [r3, #12]
   b6a64:	4798      	blx	r3
	  _M_pi->_M_release();
      }
   b6a66:	4628      	mov	r0, r5
   b6a68:	bd38      	pop	{r3, r4, r5, pc}

000b6a6a <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
   b6a6a:	b510      	push	{r4, lr}
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   b6a6c:	6883      	ldr	r3, [r0, #8]
   b6a6e:	4604      	mov	r4, r0
   b6a70:	b90b      	cbnz	r3, b6a76 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
   b6a72:	f001 fbc9 	bl	b8208 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   b6a76:	68c3      	ldr	r3, [r0, #12]
   b6a78:	4798      	blx	r3
      if (_M_manager)
   b6a7a:	68a3      	ldr	r3, [r4, #8]
   b6a7c:	b11b      	cbz	r3, b6a86 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   b6a7e:	2203      	movs	r2, #3
   b6a80:	4621      	mov	r1, r4
   b6a82:	4620      	mov	r0, r4
   b6a84:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
   b6a86:	4620      	mov	r0, r4
   b6a88:	2110      	movs	r1, #16
}
   b6a8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delete callbackPtr;
   b6a8e:	f7fd bf62 	b.w	b4956 <_ZdlPvj>

000b6a92 <_ZNSt14_Function_baseD1Ev>:
    ~_Function_base()
   b6a92:	b510      	push	{r4, lr}
      if (_M_manager)
   b6a94:	6883      	ldr	r3, [r0, #8]
    ~_Function_base()
   b6a96:	4604      	mov	r4, r0
      if (_M_manager)
   b6a98:	b113      	cbz	r3, b6aa0 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   b6a9a:	2203      	movs	r2, #3
   b6a9c:	4601      	mov	r1, r0
   b6a9e:	4798      	blx	r3
    }
   b6aa0:	4620      	mov	r0, r4
   b6aa2:	bd10      	pop	{r4, pc}

000b6aa4 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
			      is_move_constructible<_Tp>,
			      is_move_assignable<_Tp>>::value>::type
#else
    void
#endif
    swap(_Tp& __a, _Tp& __b)
   b6aa4:	b513      	push	{r0, r1, r4, lr}
   b6aa6:	460b      	mov	r3, r1
   b6aa8:	4602      	mov	r2, r0
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b6aaa:	e9d0 0100 	ldrd	r0, r1, [r0]
   b6aae:	466c      	mov	r4, sp
   b6ab0:	e884 0003 	stmia.w	r4, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
   b6ab4:	e893 0003 	ldmia.w	r3, {r0, r1}
   b6ab8:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
   b6abc:	e894 0003 	ldmia.w	r4, {r0, r1}
   b6ac0:	e883 0003 	stmia.w	r3, {r0, r1}
    }
   b6ac4:	b002      	add	sp, #8
   b6ac6:	bd10      	pop	{r4, pc}

000b6ac8 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E>:
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   b6ac8:	4802      	ldr	r0, [pc, #8]	; (b6ad4 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0xc>)
   b6aca:	2300      	movs	r3, #0
   b6acc:	6003      	str	r3, [r0, #0]
    {
        os_mutex_recursive_create(&handle_);
   b6ace:	f7ff bcf7 	b.w	b64c0 <os_mutex_recursive_create>
   b6ad2:	bf00      	nop
   b6ad4:	2003e65c 	.word	0x2003e65c

000b6ad8 <_ZN5spark13CellularClass5readyEv>:
        return network_listening(*this, 0, NULL);
    }

    bool ready()
    {
        return network_ready(*this, 0,  NULL);
   b6ad8:	2200      	movs	r2, #0
   b6ada:	6840      	ldr	r0, [r0, #4]
   b6adc:	4611      	mov	r1, r2
   b6ade:	f7ff bf0b 	b.w	b68f8 <network_ready>

000b6ae2 <_ZN5spark13CellularClass9listeningEv>:
        return network_listening(*this, 0, NULL);
   b6ae2:	2200      	movs	r2, #0
   b6ae4:	6840      	ldr	r0, [r0, #4]
   b6ae6:	4611      	mov	r1, r2
   b6ae8:	f7ff bf26 	b.w	b6938 <network_listening>

000b6aec <_ZN5spark13CellularClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
   b6aec:	2200      	movs	r2, #0
   b6aee:	6840      	ldr	r0, [r0, #4]
   b6af0:	4611      	mov	r1, r2
   b6af2:	f7ff bf31 	b.w	b6958 <network_get_listen_timeout>

000b6af6 <_ZN5spark13CellularClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
   b6af6:	6840      	ldr	r0, [r0, #4]
   b6af8:	2200      	movs	r2, #0
   b6afa:	f7ff bf25 	b.w	b6948 <network_set_listen_timeout>

000b6afe <_ZN5spark13CellularClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
   b6afe:	6840      	ldr	r0, [r0, #4]
   b6b00:	2200      	movs	r2, #0
   b6b02:	f081 0101 	eor.w	r1, r1, #1
   b6b06:	f7ff bf0f 	b.w	b6928 <network_listen>

000b6b0a <_ZN5spark13CellularClass3offEv>:
        network_off(*this, 0, 0, NULL);
   b6b0a:	2300      	movs	r3, #0
   b6b0c:	6840      	ldr	r0, [r0, #4]
   b6b0e:	461a      	mov	r2, r3
   b6b10:	4619      	mov	r1, r3
   b6b12:	f7ff bf01 	b.w	b6918 <network_off>

000b6b16 <_ZN5spark13CellularClass2onEv>:
        network_on(*this, 0, 0, NULL);
   b6b16:	2300      	movs	r3, #0
   b6b18:	6840      	ldr	r0, [r0, #4]
   b6b1a:	461a      	mov	r2, r3
   b6b1c:	4619      	mov	r1, r3
   b6b1e:	f7ff bef3 	b.w	b6908 <network_on>

000b6b22 <_ZN5spark13CellularClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
   b6b22:	2200      	movs	r2, #0
   b6b24:	6840      	ldr	r0, [r0, #4]
   b6b26:	4611      	mov	r1, r2
   b6b28:	f7ff bed6 	b.w	b68d8 <network_connecting>

000b6b2c <_ZN5spark13CellularClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   b6b2c:	6840      	ldr	r0, [r0, #4]
   b6b2e:	2200      	movs	r2, #0
   b6b30:	2102      	movs	r1, #2
   b6b32:	f7ff bed9 	b.w	b68e8 <network_disconnect>

000b6b36 <_ZN5spark13CellularClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
   b6b36:	2300      	movs	r3, #0
   b6b38:	6840      	ldr	r0, [r0, #4]
   b6b3a:	461a      	mov	r2, r3
   b6b3c:	f7ff bec4 	b.w	b68c8 <network_connect>

000b6b40 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv>:
    int tx_total;
    int rx_total;

    CellularDataHal()
    {
        memset(this, 0, sizeof(*this));
   b6b40:	4b08      	ldr	r3, [pc, #32]	; (b6b64 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x24>)
        return (band_get.ok = true);
    }

    CellularClass Cellular;
    // NetworkClass& Network = Cellular;
}
   b6b42:	b510      	push	{r4, lr}
   b6b44:	2428      	movs	r4, #40	; 0x28
   b6b46:	4622      	mov	r2, r4
   b6b48:	4618      	mov	r0, r3
   b6b4a:	2100      	movs	r1, #0
   b6b4c:	f001 fb77 	bl	b823e <memset>
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
   b6b50:	4b05      	ldr	r3, [pc, #20]	; (b6b68 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x28>)
        cid = -1;
        size = sizeof(*this);
   b6b52:	8004      	strh	r4, [r0, #0]
        cid = -1;
   b6b54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   b6b58:	6042      	str	r2, [r0, #4]
   b6b5a:	2204      	movs	r2, #4
   b6b5c:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_CELLULAR) {
   b6b5e:	4a03      	ldr	r2, [pc, #12]	; (b6b6c <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x2c>)
   b6b60:	601a      	str	r2, [r3, #0]
   b6b62:	bd10      	pop	{r4, pc}
   b6b64:	2003e668 	.word	0x2003e668
   b6b68:	2003e660 	.word	0x2003e660
   b6b6c:	000bbdb8 	.word	0x000bbdb8

000b6b70 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   b6b70:	4770      	bx	lr

000b6b72 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      { return nullptr; }
   b6b72:	2000      	movs	r0, #0
   b6b74:	4770      	bx	lr

000b6b76 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   b6b76:	b510      	push	{r4, lr}
   b6b78:	2110      	movs	r1, #16
   b6b7a:	4604      	mov	r4, r0
   b6b7c:	f7fd feeb 	bl	b4956 <_ZdlPvj>
   b6b80:	4620      	mov	r0, r4
   b6b82:	bd10      	pop	{r4, pc}

000b6b84 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
   b6b84:	b508      	push	{r3, lr}
      { delete this; }
   b6b86:	f7ff fff6 	bl	b6b76 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
   b6b8a:	bd08      	pop	{r3, pc}

000b6b8c <_ZN8particle5ErrorC1EOS0_>:

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
   b6b8c:	b530      	push	{r4, r5, lr}
        type_(type) {
   b6b8e:	2200      	movs	r2, #0
   b6b90:	f64f 749c 	movw	r4, #65436	; 0xff9c
   b6b94:	6002      	str	r2, [r0, #0]
   b6b96:	8084      	strh	r4, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
   b6b98:	888d      	ldrh	r5, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
   b6b9a:	808c      	strh	r4, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
   b6b9c:	680c      	ldr	r4, [r1, #0]
   b6b9e:	8085      	strh	r5, [r0, #4]
   b6ba0:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
   b6ba2:	600a      	str	r2, [r1, #0]
        Error() {
    swap(*this, error);
}
   b6ba4:	bd30      	pop	{r4, r5, pc}

000b6ba6 <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
   b6ba6:	b510      	push	{r4, lr}
   b6ba8:	4604      	mov	r4, r0
    free((void*)msg_);
   b6baa:	6800      	ldr	r0, [r0, #0]
   b6bac:	f7ff fef4 	bl	b6998 <free>
}
   b6bb0:	4620      	mov	r0, r4
   b6bb2:	bd10      	pop	{r4, pc}

000b6bb4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
   b6bb4:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
   b6bb6:	68c4      	ldr	r4, [r0, #12]
   b6bb8:	b1f4      	cbz	r4, b6bf8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>
      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
	_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
	__atomic_load(std::__addressof(_M_i), __ptr, int(__m));
   b6bba:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
   b6bbc:	2b02      	cmp	r3, #2
   b6bbe:	d103      	bne.n	b6bc8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
   b6bc0:	f104 000c 	add.w	r0, r4, #12
   b6bc4:	f7ff ffef 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, int(__m));
   b6bc8:	6865      	ldr	r5, [r4, #4]
        delete onSuccess_.load(std::memory_order_relaxed);
   b6bca:	b135      	cbz	r5, b6bda <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
    class function<_Res(_ArgTypes...)>
   b6bcc:	4628      	mov	r0, r5
   b6bce:	f7ff ff60 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
   b6bd2:	2110      	movs	r1, #16
   b6bd4:	4628      	mov	r0, r5
   b6bd6:	f7fd febe 	bl	b4956 <_ZdlPvj>
   b6bda:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
   b6bdc:	b135      	cbz	r5, b6bec <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
   b6bde:	4628      	mov	r0, r5
   b6be0:	f7ff ff57 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
   b6be4:	2110      	movs	r1, #16
   b6be6:	4628      	mov	r0, r5
   b6be8:	f7fd feb5 	bl	b4956 <_ZdlPvj>
   b6bec:	4620      	mov	r0, r4
   b6bee:	2114      	movs	r1, #20
   b6bf0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   b6bf4:	f7fd beaf 	b.w	b4956 <_ZdlPvj>
   b6bf8:	bd38      	pop	{r3, r4, r5, pc}

000b6bfa <_ZN10CloudClass10disconnectERK22CloudDisconnectOptions>:

int CloudClass::publishVitals(system_tick_t period_s_) {
    return spark_publish_vitals(period_s_, nullptr);
}

void CloudClass::disconnect(const CloudDisconnectOptions& options) {
   b6bfa:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    opts.size = sizeof(opts);
   b6bfc:	230c      	movs	r3, #12
   b6bfe:	f8ad 3004 	strh.w	r3, [sp, #4]
    opts.flags = flags_;
   b6c02:	6803      	ldr	r3, [r0, #0]
   b6c04:	f88d 3006 	strb.w	r3, [sp, #6]
    opts.graceful = graceful_;
   b6c08:	7a03      	ldrb	r3, [r0, #8]
   b6c0a:	f88d 3007 	strb.w	r3, [sp, #7]
    opts.timeout = timeout_;
   b6c0e:	6843      	ldr	r3, [r0, #4]
   b6c10:	9302      	str	r3, [sp, #8]
    spark_cloud_disconnect_options opts = {};
   b6c12:	2100      	movs	r1, #0
    opts.clear_session = clearSession_;
   b6c14:	7a43      	ldrb	r3, [r0, #9]
    spark_cloud_disconnect_options opts = {};
   b6c16:	f8ad 100d 	strh.w	r1, [sp, #13]
    const auto opts = options.toSystemOptions();
    spark_cloud_disconnect(&opts, nullptr /* reserved */);
   b6c1a:	a801      	add	r0, sp, #4
    spark_cloud_disconnect_options opts = {};
   b6c1c:	f88d 100f 	strb.w	r1, [sp, #15]
    opts.clear_session = clearSession_;
   b6c20:	f88d 300c 	strb.w	r3, [sp, #12]
    spark_cloud_disconnect(&opts, nullptr /* reserved */);
   b6c24:	f7ff fe48 	bl	b68b8 <spark_cloud_disconnect>
}
   b6c28:	b005      	add	sp, #20
   b6c2a:	f85d fb04 	ldr.w	pc, [sp], #4

000b6c2e <_ZN10CloudClass20setDisconnectOptionsERK22CloudDisconnectOptions>:

void CloudClass::setDisconnectOptions(const CloudDisconnectOptions& options) {
   b6c2e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    opts.size = sizeof(opts);
   b6c30:	220c      	movs	r2, #12
   b6c32:	f8ad 2004 	strh.w	r2, [sp, #4]
    opts.flags = flags_;
   b6c36:	6802      	ldr	r2, [r0, #0]
   b6c38:	f88d 2006 	strb.w	r2, [sp, #6]
    opts.graceful = graceful_;
   b6c3c:	7a02      	ldrb	r2, [r0, #8]
   b6c3e:	f88d 2007 	strb.w	r2, [sp, #7]
    opts.timeout = timeout_;
   b6c42:	6842      	ldr	r2, [r0, #4]
   b6c44:	9202      	str	r2, [sp, #8]
    spark_cloud_disconnect_options opts = {};
   b6c46:	2300      	movs	r3, #0
    opts.clear_session = clearSession_;
   b6c48:	7a42      	ldrb	r2, [r0, #9]
   b6c4a:	f88d 200c 	strb.w	r2, [sp, #12]
    const auto opts = options.toSystemOptions();
    spark_set_connection_property(SPARK_CLOUD_DISCONNECT_OPTIONS, 0 /* value */, &opts, nullptr /* reserved */);
   b6c4e:	4619      	mov	r1, r3
   b6c50:	aa01      	add	r2, sp, #4
   b6c52:	2002      	movs	r0, #2
    spark_cloud_disconnect_options opts = {};
   b6c54:	f8ad 300d 	strh.w	r3, [sp, #13]
   b6c58:	f88d 300f 	strb.w	r3, [sp, #15]
    spark_set_connection_property(SPARK_CLOUD_DISCONNECT_OPTIONS, 0 /* value */, &opts, nullptr /* reserved */);
   b6c5c:	f7ff fe1c 	bl	b6898 <spark_set_connection_property>
}
   b6c60:	b005      	add	sp, #20
   b6c62:	f85d fb04 	ldr.w	pc, [sp], #4

000b6c66 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>:
	{
	  _M_refcount._M_swap(__r._M_refcount);
	  __r._M_ptr = 0;
	}

      __shared_ptr(const __shared_ptr&) noexcept = default;
   b6c66:	680b      	ldr	r3, [r1, #0]
   b6c68:	6003      	str	r3, [r0, #0]
      : _M_pi(__r._M_pi)
   b6c6a:	684b      	ldr	r3, [r1, #4]
   b6c6c:	6043      	str	r3, [r0, #4]
	if (_M_pi != 0)
   b6c6e:	b113      	cbz	r3, b6c76 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_+0x10>
    { ++_M_use_count; }
   b6c70:	685a      	ldr	r2, [r3, #4]
   b6c72:	3201      	adds	r2, #1
   b6c74:	605a      	str	r2, [r3, #4]
      __shared_ptr(const __shared_ptr&) noexcept = default;
   b6c76:	4770      	bx	lr

000b6c78 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
   b6c78:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b6c7a:	4604      	mov	r4, r0
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default; ///< Copy constructor
   b6c7c:	4668      	mov	r0, sp
   b6c7e:	460d      	mov	r5, r1
   b6c80:	f7ff fff1 	bl	b6c66 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
   b6c84:	9b00      	ldr	r3, [sp, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   b6c86:	9a01      	ldr	r2, [sp, #4]
      : _M_ptr(__r._M_ptr), _M_refcount()
   b6c88:	6023      	str	r3, [r4, #0]
	_M_pi = __tmp;
   b6c8a:	6062      	str	r2, [r4, #4]
	__r._M_pi = _M_pi;
   b6c8c:	2300      	movs	r3, #0
      ~__shared_ptr() = default;
   b6c8e:	a801      	add	r0, sp, #4
	__r._M_pi = _M_pi;
   b6c90:	9301      	str	r3, [sp, #4]
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
   b6c92:	9300      	str	r3, [sp, #0]
      ~__shared_ptr() = default;
   b6c94:	f7ff fed3 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
        delete d;
   b6c98:	b135      	cbz	r5, b6ca8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv+0x30>
   b6c9a:	1d28      	adds	r0, r5, #4
   b6c9c:	f7ff fecf 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   b6ca0:	2108      	movs	r1, #8
   b6ca2:	4628      	mov	r0, r5
   b6ca4:	f7fd fe57 	bl	b4956 <_ZdlPvj>
        return p;
    }
   b6ca8:	4620      	mov	r0, r4
   b6caa:	b003      	add	sp, #12
   b6cac:	bd30      	pop	{r4, r5, pc}

000b6cae <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
      if (_M_empty())
   b6cae:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
   b6cb0:	b510      	push	{r4, lr}
      if (_M_empty())
   b6cb2:	b90a      	cbnz	r2, b6cb8 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
   b6cb4:	f001 faa8 	bl	b8208 <_ZSt25__throw_bad_function_callv>
    }
   b6cb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   b6cbc:	68c3      	ldr	r3, [r0, #12]
   b6cbe:	4718      	bx	r3

000b6cc0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   b6cc0:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
   b6cc2:	6800      	ldr	r0, [r0, #0]
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
   b6cc4:	f100 0110 	add.w	r1, r0, #16
   b6cc8:	f7ff fff1 	bl	b6cae <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
      }
   b6ccc:	bd08      	pop	{r3, pc}

000b6cce <_ZNKSt8functionIFvRKbEEclES1_>:
      if (_M_empty())
   b6cce:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
   b6cd0:	b510      	push	{r4, lr}
      if (_M_empty())
   b6cd2:	b90a      	cbnz	r2, b6cd8 <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
   b6cd4:	f001 fa98 	bl	b8208 <_ZSt25__throw_bad_function_callv>
    }
   b6cd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   b6cdc:	68c3      	ldr	r3, [r0, #12]
   b6cde:	4718      	bx	r3

000b6ce0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   b6ce0:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
   b6ce2:	6800      	ldr	r0, [r0, #0]
   b6ce4:	f100 0110 	add.w	r1, r0, #16
   b6ce8:	f7ff fff1 	bl	b6cce <_ZNKSt8functionIFvRKbEEclES1_>
      }
   b6cec:	bd08      	pop	{r3, pc}
	...

000b6cf0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
	__shared_count(_Ptr __p) : _M_pi(0)
   b6cf0:	b538      	push	{r3, r4, r5, lr}
   b6cf2:	2300      	movs	r3, #0
   b6cf4:	4604      	mov	r4, r0
   b6cf6:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   b6cf8:	2010      	movs	r0, #16
	__shared_count(_Ptr __p) : _M_pi(0)
   b6cfa:	460d      	mov	r5, r1
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   b6cfc:	f7fd fe27 	bl	b494e <_Znwj>
   b6d00:	b128      	cbz	r0, b6d0e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
      : _M_use_count(1), _M_weak_count(1) { }
   b6d02:	2301      	movs	r3, #1
   b6d04:	e9c0 3301 	strd	r3, r3, [r0, #4]
      : _M_ptr(__p) { }
   b6d08:	4b02      	ldr	r3, [pc, #8]	; (b6d14 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
   b6d0a:	6003      	str	r3, [r0, #0]
   b6d0c:	60c5      	str	r5, [r0, #12]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   b6d0e:	6020      	str	r0, [r4, #0]
	}
   b6d10:	4620      	mov	r0, r4
   b6d12:	bd38      	pop	{r3, r4, r5, pc}
   b6d14:	000bbdf4 	.word	0x000bbdf4

000b6d18 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
    function<_Res(_ArgTypes...)>::
   b6d18:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
   b6d1a:	2300      	movs	r3, #0
   b6d1c:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
   b6d1e:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
   b6d20:	4604      	mov	r4, r0
   b6d22:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
   b6d24:	b12b      	cbz	r3, b6d32 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   b6d26:	2202      	movs	r2, #2
   b6d28:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   b6d2a:	68eb      	ldr	r3, [r5, #12]
   b6d2c:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   b6d2e:	68ab      	ldr	r3, [r5, #8]
   b6d30:	60a3      	str	r3, [r4, #8]
    }
   b6d32:	4620      	mov	r0, r4
   b6d34:	bd38      	pop	{r3, r4, r5, pc}
	...

000b6d38 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:
    void setError(Error error) {
   b6d38:	b5f0      	push	{r4, r5, r6, r7, lr}
   b6d3a:	b089      	sub	sp, #36	; 0x24
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      /// Return the stored pointer.
      element_type*
      get() const noexcept
      { return _M_ptr; }
   b6d3c:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
   b6d3e:	4668      	mov	r0, sp
   b6d40:	f7ff ff24 	bl	b6b8c <_ZN8particle5ErrorC1EOS0_>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(std::__addressof(_M_i),
   b6d44:	f04f 0302 	mov.w	r3, #2
   b6d48:	e8d4 2f4f 	ldrexb	r2, [r4]
   b6d4c:	2a00      	cmp	r2, #0
   b6d4e:	d103      	bne.n	b6d58 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
   b6d50:	e8c4 3f41 	strexb	r1, r3, [r4]
   b6d54:	2900      	cmp	r1, #0
   b6d56:	d1f7      	bne.n	b6d48 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x10>
        if (this->changeState(State::FAILED)) {
   b6d58:	d125      	bne.n	b6da6 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
            new(&error_) Error(std::move(error));
   b6d5a:	f104 050c 	add.w	r5, r4, #12
   b6d5e:	4669      	mov	r1, sp
   b6d60:	4628      	mov	r0, r5
   b6d62:	f7ff ff13 	bl	b6b8c <_ZN8particle5ErrorC1EOS0_>
	__atomic_store_n(&_M_i, __i, int(__m));
   b6d66:	f3bf 8f5b 	dmb	ish
   b6d6a:	2301      	movs	r3, #1
   b6d6c:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, int(__m));
   b6d6e:	2000      	movs	r0, #0
   b6d70:	f104 0308 	add.w	r3, r4, #8
   b6d74:	f3bf 8f5b 	dmb	ish
   b6d78:	e853 6f00 	ldrex	r6, [r3]
   b6d7c:	e843 0200 	strex	r2, r0, [r3]
   b6d80:	2a00      	cmp	r2, #0
   b6d82:	d1f9      	bne.n	b6d78 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x40>
   b6d84:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
   b6d88:	b16e      	cbz	r6, b6da6 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
        return (application_thread_current(nullptr) != 0);
   b6d8a:	f7ff fd29 	bl	b67e0 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
   b6d8e:	b178      	cbz	r0, b6db0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x78>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   b6d90:	4629      	mov	r1, r5
   b6d92:	4630      	mov	r0, r6
   b6d94:	f7ff ff8b 	bl	b6cae <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
    class function<_Res(_ArgTypes...)>
   b6d98:	4630      	mov	r0, r6
   b6d9a:	f7ff fe7a 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
   b6d9e:	2110      	movs	r1, #16
   b6da0:	4630      	mov	r0, r6
   b6da2:	f7fd fdd8 	bl	b4956 <_ZdlPvj>
        p_->setError(std::move(error));
   b6da6:	4668      	mov	r0, sp
   b6da8:	f7ff fefd 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
    }
   b6dac:	b009      	add	sp, #36	; 0x24
   b6dae:	bdf0      	pop	{r4, r5, r6, r7, pc}

     public:
      template<typename... _Args>
	explicit _GLIBCXX20_CONSTEXPR
	_Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   b6db0:	4631      	mov	r1, r6
   b6db2:	a802      	add	r0, sp, #8
   b6db4:	f7ff ffb0 	bl	b6d18 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
   b6db8:	68e0      	ldr	r0, [r4, #12]
   b6dba:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   b6dbe:	b108      	cbz	r0, b6dc4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x8c>
   b6dc0:	f001 fa7c 	bl	b82bc <strdup>
        type_(type) {
   b6dc4:	9006      	str	r0, [sp, #24]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   b6dc6:	2010      	movs	r0, #16
   b6dc8:	f8ad 501c 	strh.w	r5, [sp, #28]
   b6dcc:	f7fd fdbf 	bl	b494e <_Znwj>
   b6dd0:	4605      	mov	r5, r0
   b6dd2:	b1e8      	cbz	r0, b6e10 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd8>
    _Function_base() : _M_manager(nullptr) { }
   b6dd4:	2700      	movs	r7, #0
   b6dd6:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   b6dd8:	2018      	movs	r0, #24
   b6dda:	f7fd fdb8 	bl	b494e <_Znwj>
   b6dde:	4604      	mov	r4, r0
   b6de0:	b188      	cbz	r0, b6e06 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xce>
	std::swap(_M_functor, __x._M_functor);
   b6de2:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
   b6de4:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
   b6de6:	a802      	add	r0, sp, #8
   b6de8:	f7ff fe5c 	bl	b6aa4 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b6dec:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
   b6dee:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   b6df0:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b6df2:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
   b6df4:	9204      	str	r2, [sp, #16]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   b6df6:	a906      	add	r1, sp, #24
   b6df8:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   b6dfa:	60e3      	str	r3, [r4, #12]
   b6dfc:	f104 0010 	add.w	r0, r4, #16
      __a = _GLIBCXX_MOVE(__b);
   b6e00:	9205      	str	r2, [sp, #20]
   b6e02:	f7ff fec3 	bl	b6b8c <_ZN8particle5ErrorC1EOS0_>
	    _M_invoker = &_My_handler::_M_invoke;
   b6e06:	4b08      	ldr	r3, [pc, #32]	; (b6e28 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf0>)
   b6e08:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   b6e0a:	4b08      	ldr	r3, [pc, #32]	; (b6e2c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf4>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   b6e0c:	602c      	str	r4, [r5, #0]
	    _M_manager = &_My_handler::_M_manager;
   b6e0e:	60ab      	str	r3, [r5, #8]
    struct _Head_base<_Idx, _Head, false>
   b6e10:	a806      	add	r0, sp, #24
   b6e12:	f7ff fec8 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
   b6e16:	a802      	add	r0, sp, #8
   b6e18:	f7ff fe3b 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
   b6e1c:	2200      	movs	r2, #0
   b6e1e:	4629      	mov	r1, r5
   b6e20:	4803      	ldr	r0, [pc, #12]	; (b6e30 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf8>)
   b6e22:	f7ff fce5 	bl	b67f0 <application_thread_invoke>
   b6e26:	e7b7      	b.n	b6d98 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x60>
   b6e28:	000b6cc1 	.word	0x000b6cc1
   b6e2c:	000b6f45 	.word	0x000b6f45
   b6e30:	000b6a6b 	.word	0x000b6a6b

000b6e34 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
   b6e34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b6e38:	b08b      	sub	sp, #44	; 0x2c
   b6e3a:	4605      	mov	r5, r0
   b6e3c:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
   b6e40:	460f      	mov	r7, r1
   b6e42:	4690      	mov	r8, r2
   b6e44:	4699      	mov	r9, r3
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   b6e46:	f7ff fd07 	bl	b6858 <spark_cloud_flag_connected>
   b6e4a:	ae07      	add	r6, sp, #28
    if (!connected()) {
   b6e4c:	4683      	mov	fp, r0
   b6e4e:	bb38      	cbnz	r0, b6ea0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6c>
        type_(type) {
   b6e50:	f64f 732e 	movw	r3, #65326	; 0xff2e
   b6e54:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   b6e56:	a905      	add	r1, sp, #20
   b6e58:	4630      	mov	r0, r6
   b6e5a:	f8ad 3018 	strh.w	r3, [sp, #24]
   b6e5e:	f7ff fe95 	bl	b6b8c <_ZN8particle5ErrorC1EOS0_>
   b6e62:	2014      	movs	r0, #20
   b6e64:	f7fd fd73 	bl	b494e <_Znwj>
   b6e68:	4604      	mov	r4, r0
   b6e6a:	b148      	cbz	r0, b6e80 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x4c>
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
   b6e6c:	2302      	movs	r3, #2
   b6e6e:	7003      	strb	r3, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   b6e70:	2301      	movs	r3, #1
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   b6e72:	e9c0 bb01 	strd	fp, fp, [r0, #4]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   b6e76:	7043      	strb	r3, [r0, #1]
            error_(std::move(error)) {
   b6e78:	4631      	mov	r1, r6
   b6e7a:	300c      	adds	r0, #12
   b6e7c:	f7ff fe86 	bl	b6b8c <_ZN8particle5ErrorC1EOS0_>
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   b6e80:	4628      	mov	r0, r5
	: __shared_count(__p)
   b6e82:	4621      	mov	r1, r4
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   b6e84:	f840 4b04 	str.w	r4, [r0], #4
	: __shared_count(__p)
   b6e88:	f7ff ff32 	bl	b6cf0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   b6e8c:	4630      	mov	r0, r6
   b6e8e:	f7ff fe8a 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
   b6e92:	a805      	add	r0, sp, #20
   b6e94:	f7ff fe87 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
}
   b6e98:	4628      	mov	r0, r5
   b6e9a:	b00b      	add	sp, #44	; 0x2c
   b6e9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d.size = sizeof(spark_send_event_data);
   b6ea0:	230c      	movs	r3, #12
    spark_send_event_data d = {};
   b6ea2:	2400      	movs	r4, #0
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
   b6ea4:	2014      	movs	r0, #20
   b6ea6:	e9cd 4408 	strd	r4, r4, [sp, #32]
    d.size = sizeof(spark_send_event_data);
   b6eaa:	9307      	str	r3, [sp, #28]
   b6eac:	f7fd fd4f 	bl	b494e <_Znwj>
   b6eb0:	4601      	mov	r1, r0
   b6eb2:	b118      	cbz	r0, b6ebc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x88>
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   b6eb4:	e9c0 4401 	strd	r4, r4, [r0, #4]
   b6eb8:	7004      	strb	r4, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   b6eba:	7044      	strb	r4, [r0, #1]
   b6ebc:	a804      	add	r0, sp, #16
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   b6ebe:	9103      	str	r1, [sp, #12]
	: __shared_count(__p)
   b6ec0:	f7ff ff16 	bl	b6cf0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    d.handler_callback = publishCompletionCallback;
   b6ec4:	4b1e      	ldr	r3, [pc, #120]	; (b6f40 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x10c>)
   b6ec6:	9308      	str	r3, [sp, #32]
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
   b6ec8:	2008      	movs	r0, #8
   b6eca:	f7fd fd40 	bl	b494e <_Znwj>
   b6ece:	4604      	mov	r4, r0
   b6ed0:	b110      	cbz	r0, b6ed8 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xa4>
   b6ed2:	a903      	add	r1, sp, #12
   b6ed4:	f7ff fec7 	bl	b6c66 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   b6ed8:	9600      	str	r6, [sp, #0]
   b6eda:	fa5f f38a 	uxtb.w	r3, sl
   b6ede:	464a      	mov	r2, r9
   b6ee0:	4641      	mov	r1, r8
   b6ee2:	4638      	mov	r0, r7
    d.handler_data = p.dataPtr();
   b6ee4:	9409      	str	r4, [sp, #36]	; 0x24
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   b6ee6:	f7ff fcbf 	bl	b6868 <spark_send_event>
   b6eea:	b9b8      	cbnz	r0, b6f1c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe8>
	return __atomic_load_n(&_M_i, int(__m));
   b6eec:	9b03      	ldr	r3, [sp, #12]
   b6eee:	785b      	ldrb	r3, [r3, #1]
   b6ef0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   b6ef4:	b993      	cbnz	r3, b6f1c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe8>
   b6ef6:	f64f 739c 	movw	r3, #65436	; 0xff9c
        p.setError(Error::UNKNOWN);
   b6efa:	a905      	add	r1, sp, #20
   b6efc:	a803      	add	r0, sp, #12
   b6efe:	9205      	str	r2, [sp, #20]
   b6f00:	f8ad 3018 	strh.w	r3, [sp, #24]
   b6f04:	f7ff ff18 	bl	b6d38 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   b6f08:	a805      	add	r0, sp, #20
   b6f0a:	f7ff fe4c 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
   b6f0e:	a805      	add	r0, sp, #20
   b6f10:	9909      	ldr	r1, [sp, #36]	; 0x24
   b6f12:	f7ff feb1 	bl	b6c78 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      ~__shared_ptr() = default;
   b6f16:	a806      	add	r0, sp, #24
   b6f18:	f7ff fd91 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   b6f1c:	a903      	add	r1, sp, #12
   b6f1e:	a805      	add	r0, sp, #20
   b6f20:	f7ff fea1 	bl	b6c66 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
      : _M_ptr(__r._M_ptr), _M_refcount()
   b6f24:	9b05      	ldr	r3, [sp, #20]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   b6f26:	9a06      	ldr	r2, [sp, #24]
      : _M_ptr(__r._M_ptr), _M_refcount()
   b6f28:	602b      	str	r3, [r5, #0]
	_M_pi = __tmp;
   b6f2a:	606a      	str	r2, [r5, #4]
	__r._M_pi = _M_pi;
   b6f2c:	2300      	movs	r3, #0
      ~__shared_ptr() = default;
   b6f2e:	a806      	add	r0, sp, #24
	__r._M_pi = _M_pi;
   b6f30:	9306      	str	r3, [sp, #24]
	__r._M_ptr = 0;
   b6f32:	9305      	str	r3, [sp, #20]
      ~__shared_ptr() = default;
   b6f34:	f7ff fd83 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   b6f38:	a804      	add	r0, sp, #16
   b6f3a:	f7ff fd80 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
class Promise: public PromiseBase<ResultT, ContextT> {
   b6f3e:	e7ab      	b.n	b6e98 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x64>
   b6f40:	000b6fc1 	.word	0x000b6fc1

000b6f44 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
	switch (__op)
   b6f44:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   b6f46:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b6f48:	4605      	mov	r5, r0
	switch (__op)
   b6f4a:	d103      	bne.n	b6f54 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
   b6f4c:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
   b6f4e:	6003      	str	r3, [r0, #0]
      }
   b6f50:	2000      	movs	r0, #0
   b6f52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  switch (__op)
   b6f54:	2a02      	cmp	r2, #2
   b6f56:	d010      	beq.n	b6f7a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x36>
   b6f58:	2a03      	cmp	r2, #3
   b6f5a:	d1f9      	bne.n	b6f50 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
   b6f5c:	6804      	ldr	r4, [r0, #0]
   b6f5e:	2c00      	cmp	r4, #0
   b6f60:	d0f6      	beq.n	b6f50 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
   b6f62:	f104 0010 	add.w	r0, r4, #16
   b6f66:	f7ff fe1e 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
   b6f6a:	4620      	mov	r0, r4
   b6f6c:	f7ff fd91 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
   b6f70:	2118      	movs	r1, #24
   b6f72:	4620      	mov	r0, r4
   b6f74:	f7fd fcef 	bl	b4956 <_ZdlPvj>
   b6f78:	e7ea      	b.n	b6f50 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
   b6f7a:	2018      	movs	r0, #24
	  __dest._M_access<_Functor*>() =
   b6f7c:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
   b6f7e:	f7fd fce6 	bl	b494e <_Znwj>
   b6f82:	4604      	mov	r4, r0
   b6f84:	b150      	cbz	r0, b6f9c <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x58>
	explicit _GLIBCXX20_CONSTEXPR
	_Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
   b6f86:	4631      	mov	r1, r6
   b6f88:	f7ff fec6 	bl	b6d18 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
   b6f8c:	6930      	ldr	r0, [r6, #16]
   b6f8e:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   b6f92:	b108      	cbz	r0, b6f98 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x54>
   b6f94:	f001 f992 	bl	b82bc <strdup>
        type_(type) {
   b6f98:	6120      	str	r0, [r4, #16]
   b6f9a:	82a7      	strh	r7, [r4, #20]
	  __dest._M_access<_Functor*>() =
   b6f9c:	602c      	str	r4, [r5, #0]
	}
   b6f9e:	e7d7      	b.n	b6f50 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>

000b6fa0 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
    function<_Res(_ArgTypes...)>::
   b6fa0:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
   b6fa2:	2300      	movs	r3, #0
   b6fa4:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
   b6fa6:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
   b6fa8:	4604      	mov	r4, r0
   b6faa:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
   b6fac:	b12b      	cbz	r3, b6fba <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   b6fae:	2202      	movs	r2, #2
   b6fb0:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   b6fb2:	68eb      	ldr	r3, [r5, #12]
   b6fb4:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   b6fb6:	68ab      	ldr	r3, [r5, #8]
   b6fb8:	60a3      	str	r3, [r4, #8]
    }
   b6fba:	4620      	mov	r0, r4
   b6fbc:	bd38      	pop	{r3, r4, r5, pc}
	...

000b6fc0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
   b6fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
   b6fc2:	b089      	sub	sp, #36	; 0x24
   b6fc4:	4604      	mov	r4, r0
   b6fc6:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
   b6fc8:	a801      	add	r0, sp, #4
   b6fca:	4611      	mov	r1, r2
   b6fcc:	f7ff fe54 	bl	b6c78 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
   b6fd0:	b1a4      	cbz	r4, b6ffc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
        p.setError(Error((Error::Type)error, (const char*)data));
   b6fd2:	b224      	sxth	r4, r4
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   b6fd4:	b11d      	cbz	r5, b6fde <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1e>
   b6fd6:	4628      	mov	r0, r5
   b6fd8:	f001 f970 	bl	b82bc <strdup>
   b6fdc:	4605      	mov	r5, r0
   b6fde:	a801      	add	r0, sp, #4
   b6fe0:	a903      	add	r1, sp, #12
        type_(type) {
   b6fe2:	9503      	str	r5, [sp, #12]
   b6fe4:	f8ad 4010 	strh.w	r4, [sp, #16]
   b6fe8:	f7ff fea6 	bl	b6d38 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   b6fec:	a803      	add	r0, sp, #12
   b6fee:	f7ff fdda 	bl	b6ba6 <_ZN8particle5ErrorD1Ev>
   b6ff2:	a802      	add	r0, sp, #8
   b6ff4:	f7ff fd23 	bl	b6a3e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   b6ff8:	b009      	add	sp, #36	; 0x24
   b6ffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      { return _M_ptr; }
   b6ffc:	9d01      	ldr	r5, [sp, #4]
	return __atomic_compare_exchange(std::__addressof(_M_i),
   b6ffe:	2301      	movs	r3, #1
   b7000:	e8d5 2f4f 	ldrexb	r2, [r5]
   b7004:	2a00      	cmp	r2, #0
   b7006:	d103      	bne.n	b7010 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x50>
   b7008:	e8c5 3f41 	strexb	r1, r3, [r5]
   b700c:	2900      	cmp	r1, #0
   b700e:	d1f7      	bne.n	b7000 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x40>
        if (this->changeState(State::SUCCEEDED)) {
   b7010:	d1ef      	bne.n	b6ff2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
            new(&result_) ResultT(std::move(result));
   b7012:	732b      	strb	r3, [r5, #12]
	__atomic_store_n(&_M_i, __i, int(__m));
   b7014:	f3bf 8f5b 	dmb	ish
   b7018:	706b      	strb	r3, [r5, #1]
	return __atomic_exchange_n(&_M_p, __p, int(__m));
   b701a:	1d2b      	adds	r3, r5, #4
   b701c:	f3bf 8f5b 	dmb	ish
   b7020:	e853 6f00 	ldrex	r6, [r3]
   b7024:	e843 4200 	strex	r2, r4, [r3]
   b7028:	2a00      	cmp	r2, #0
   b702a:	d1f9      	bne.n	b7020 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x60>
   b702c:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
   b7030:	2e00      	cmp	r6, #0
   b7032:	d0de      	beq.n	b6ff2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        return (application_thread_current(nullptr) != 0);
   b7034:	4620      	mov	r0, r4
   b7036:	f7ff fbd3 	bl	b67e0 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
   b703a:	4607      	mov	r7, r0
   b703c:	b160      	cbz	r0, b7058 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x98>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   b703e:	f105 010c 	add.w	r1, r5, #12
   b7042:	4630      	mov	r0, r6
   b7044:	f7ff fe43 	bl	b6cce <_ZNKSt8functionIFvRKbEEclES1_>
    class function<_Res(_ArgTypes...)>
   b7048:	4630      	mov	r0, r6
   b704a:	f7ff fd22 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
   b704e:	2110      	movs	r1, #16
   b7050:	4630      	mov	r0, r6
   b7052:	f7fd fc80 	bl	b4956 <_ZdlPvj>
   b7056:	e7cc      	b.n	b6ff2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   b7058:	4631      	mov	r1, r6
   b705a:	a803      	add	r0, sp, #12
   b705c:	f7ff ffa0 	bl	b6fa0 <_ZNSt8functionIFvRKbEEC1ERKS3_>
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   b7060:	7b2b      	ldrb	r3, [r5, #12]
   b7062:	f88d 301c 	strb.w	r3, [sp, #28]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   b7066:	2010      	movs	r0, #16
   b7068:	f7fd fc71 	bl	b494e <_Znwj>
   b706c:	4605      	mov	r5, r0
   b706e:	b1d0      	cbz	r0, b70a6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xe6>
    _Function_base() : _M_manager(nullptr) { }
   b7070:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   b7072:	2014      	movs	r0, #20
   b7074:	f7fd fc6b 	bl	b494e <_Znwj>
   b7078:	4604      	mov	r4, r0
   b707a:	b178      	cbz	r0, b709c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xdc>
    _Function_base() : _M_manager(nullptr) { }
   b707c:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
   b707e:	4601      	mov	r1, r0
   b7080:	a803      	add	r0, sp, #12
   b7082:	f7ff fd0f 	bl	b6aa4 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b7086:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
   b7088:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   b708a:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b708c:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
   b708e:	9205      	str	r2, [sp, #20]
   b7090:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   b7092:	60e3      	str	r3, [r4, #12]
   b7094:	f89d 301c 	ldrb.w	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
   b7098:	9206      	str	r2, [sp, #24]
   b709a:	7423      	strb	r3, [r4, #16]
	    _M_invoker = &_My_handler::_M_invoke;
   b709c:	4b06      	ldr	r3, [pc, #24]	; (b70b8 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xf8>)
   b709e:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   b70a0:	4b06      	ldr	r3, [pc, #24]	; (b70bc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xfc>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   b70a2:	602c      	str	r4, [r5, #0]
	    _M_manager = &_My_handler::_M_manager;
   b70a4:	60ab      	str	r3, [r5, #8]
    class function<_Res(_ArgTypes...)>
   b70a6:	a803      	add	r0, sp, #12
   b70a8:	f7ff fcf3 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
   b70ac:	2200      	movs	r2, #0
   b70ae:	4629      	mov	r1, r5
   b70b0:	4803      	ldr	r0, [pc, #12]	; (b70c0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x100>)
   b70b2:	f7ff fb9d 	bl	b67f0 <application_thread_invoke>
   b70b6:	e7c7      	b.n	b7048 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x88>
   b70b8:	000b6ce1 	.word	0x000b6ce1
   b70bc:	000b70c5 	.word	0x000b70c5
   b70c0:	000b6a6b 	.word	0x000b6a6b

000b70c4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
	switch (__op)
   b70c4:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   b70c6:	b570      	push	{r4, r5, r6, lr}
   b70c8:	4604      	mov	r4, r0
	switch (__op)
   b70ca:	d103      	bne.n	b70d4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
   b70cc:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
   b70ce:	6003      	str	r3, [r0, #0]
      }
   b70d0:	2000      	movs	r0, #0
   b70d2:	bd70      	pop	{r4, r5, r6, pc}
	  switch (__op)
   b70d4:	2a02      	cmp	r2, #2
   b70d6:	d00c      	beq.n	b70f2 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2e>
   b70d8:	2a03      	cmp	r2, #3
   b70da:	d1f9      	bne.n	b70d0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
   b70dc:	6804      	ldr	r4, [r0, #0]
   b70de:	2c00      	cmp	r4, #0
   b70e0:	d0f6      	beq.n	b70d0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
    class function<_Res(_ArgTypes...)>
   b70e2:	4620      	mov	r0, r4
   b70e4:	f7ff fcd5 	bl	b6a92 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
   b70e8:	2114      	movs	r1, #20
   b70ea:	4620      	mov	r0, r4
   b70ec:	f7fd fc33 	bl	b4956 <_ZdlPvj>
   b70f0:	e7ee      	b.n	b70d0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
   b70f2:	2014      	movs	r0, #20
	  __dest._M_access<_Functor*>() =
   b70f4:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
   b70f6:	f7fd fc2a 	bl	b494e <_Znwj>
   b70fa:	4605      	mov	r5, r0
   b70fc:	b120      	cbz	r0, b7108 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x44>
      _Bind(const _Bind&) = default;
   b70fe:	4631      	mov	r1, r6
   b7100:	f7ff ff4e 	bl	b6fa0 <_ZNSt8functionIFvRKbEEC1ERKS3_>
   b7104:	7c33      	ldrb	r3, [r6, #16]
   b7106:	742b      	strb	r3, [r5, #16]
	  __dest._M_access<_Functor*>() =
   b7108:	6025      	str	r5, [r4, #0]
	}
   b710a:	e7e1      	b.n	b70d0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>

000b710c <_ZN5spark13EthernetClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   b710c:	2200      	movs	r2, #0
   b710e:	6840      	ldr	r0, [r0, #4]
   b7110:	4611      	mov	r1, r2
   b7112:	f7ff bc11 	b.w	b6938 <network_listening>

000b7116 <_ZN5spark13EthernetClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
   b7116:	2200      	movs	r2, #0
   b7118:	6840      	ldr	r0, [r0, #4]
   b711a:	4611      	mov	r1, r2
   b711c:	f7ff bc1c 	b.w	b6958 <network_get_listen_timeout>

000b7120 <_ZN5spark13EthernetClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
   b7120:	6840      	ldr	r0, [r0, #4]
   b7122:	2200      	movs	r2, #0
   b7124:	f7ff bc10 	b.w	b6948 <network_set_listen_timeout>

000b7128 <_ZN5spark13EthernetClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
   b7128:	6840      	ldr	r0, [r0, #4]
   b712a:	2200      	movs	r2, #0
   b712c:	f081 0101 	eor.w	r1, r1, #1
   b7130:	f7ff bbfa 	b.w	b6928 <network_listen>

000b7134 <_ZN5spark13EthernetClass3offEv>:
        network_off(*this, 0, 0, NULL);
   b7134:	2300      	movs	r3, #0
   b7136:	6840      	ldr	r0, [r0, #4]
   b7138:	461a      	mov	r2, r3
   b713a:	4619      	mov	r1, r3
   b713c:	f7ff bbec 	b.w	b6918 <network_off>

000b7140 <_ZN5spark13EthernetClass2onEv>:
        network_on(*this, 0, 0, NULL);
   b7140:	2300      	movs	r3, #0
   b7142:	6840      	ldr	r0, [r0, #4]
   b7144:	461a      	mov	r2, r3
   b7146:	4619      	mov	r1, r3
   b7148:	f7ff bbde 	b.w	b6908 <network_on>

000b714c <_ZN5spark13EthernetClass5readyEv>:
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   b714c:	2200      	movs	r2, #0
   b714e:	6840      	ldr	r0, [r0, #4]
   b7150:	4611      	mov	r1, r2
   b7152:	f7ff bbd1 	b.w	b68f8 <network_ready>

000b7156 <_ZN5spark13EthernetClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
   b7156:	2200      	movs	r2, #0
   b7158:	6840      	ldr	r0, [r0, #4]
   b715a:	4611      	mov	r1, r2
   b715c:	f7ff bbbc 	b.w	b68d8 <network_connecting>

000b7160 <_ZN5spark13EthernetClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   b7160:	6840      	ldr	r0, [r0, #4]
   b7162:	2200      	movs	r2, #0
   b7164:	2102      	movs	r1, #2
   b7166:	f7ff bbbf 	b.w	b68e8 <network_disconnect>

000b716a <_ZN5spark13EthernetClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
   b716a:	2300      	movs	r3, #0
   b716c:	6840      	ldr	r0, [r0, #4]
   b716e:	461a      	mov	r2, r3
   b7170:	f7ff bbaa 	b.w	b68c8 <network_connect>

000b7174 <_GLOBAL__sub_I__ZN5spark8EthernetE>:
   b7174:	4b02      	ldr	r3, [pc, #8]	; (b7180 <_GLOBAL__sub_I__ZN5spark8EthernetE+0xc>)
   b7176:	2203      	movs	r2, #3
   b7178:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
   b717a:	4a02      	ldr	r2, [pc, #8]	; (b7184 <_GLOBAL__sub_I__ZN5spark8EthernetE+0x10>)
   b717c:	601a      	str	r2, [r3, #0]

namespace spark {

EthernetClass Ethernet;

} // spark
   b717e:	4770      	bx	lr
   b7180:	2003e690 	.word	0x2003e690
   b7184:	000bbe10 	.word	0x000bbe10

000b7188 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
   b7188:	4770      	bx	lr

000b718a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
   b718a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b718c:	4606      	mov	r6, r0
   b718e:	4615      	mov	r5, r2
   b7190:	460c      	mov	r4, r1
   b7192:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   b7194:	42bc      	cmp	r4, r7
   b7196:	d006      	beq.n	b71a6 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
   b7198:	6833      	ldr	r3, [r6, #0]
   b719a:	f814 1b01 	ldrb.w	r1, [r4], #1
   b719e:	689b      	ldr	r3, [r3, #8]
   b71a0:	4630      	mov	r0, r6
   b71a2:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
   b71a4:	e7f6      	b.n	b7194 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
   b71a6:	4628      	mov	r0, r5
   b71a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b71aa <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
   b71aa:	7c00      	ldrb	r0, [r0, #16]
   b71ac:	2200      	movs	r2, #0
   b71ae:	f7ff b9ef 	b.w	b6590 <hal_i2c_write>

000b71b2 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
   b71b2:	7c00      	ldrb	r0, [r0, #16]
   b71b4:	2100      	movs	r1, #0
   b71b6:	f7ff b9f3 	b.w	b65a0 <hal_i2c_available>

000b71ba <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
   b71ba:	7c00      	ldrb	r0, [r0, #16]
   b71bc:	2100      	movs	r1, #0
   b71be:	f7ff b9f7 	b.w	b65b0 <hal_i2c_read>

000b71c2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
   b71c2:	7c00      	ldrb	r0, [r0, #16]
   b71c4:	2100      	movs	r1, #0
   b71c6:	f7ff b9fb 	b.w	b65c0 <hal_i2c_peek>

000b71ca <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
   b71ca:	7c00      	ldrb	r0, [r0, #16]
   b71cc:	2100      	movs	r1, #0
   b71ce:	f7ff b9ff 	b.w	b65d0 <hal_i2c_flush>

000b71d2 <_ZN7TwoWireD0Ev>:
   b71d2:	b510      	push	{r4, lr}
   b71d4:	2114      	movs	r1, #20
   b71d6:	4604      	mov	r4, r0
   b71d8:	f7fd fbbd 	bl	b4956 <_ZdlPvj>
   b71dc:	4620      	mov	r0, r4
   b71de:	bd10      	pop	{r4, pc}

000b71e0 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
   b71e0:	b538      	push	{r3, r4, r5, lr}
   b71e2:	4604      	mov	r4, r0
   b71e4:	4615      	mov	r5, r2
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   b71e6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   b71ea:	2200      	movs	r2, #0
   b71ec:	e9c4 2301 	strd	r2, r3, [r4, #4]
   b71f0:	4b09      	ldr	r3, [pc, #36]	; (b7218 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x38>)
  _i2c = i2c;
   b71f2:	7421      	strb	r1, [r4, #16]
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
   b71f4:	4608      	mov	r0, r1
   b71f6:	6023      	str	r3, [r4, #0]
  int result = hal_i2c_init(_i2c, &conf);
   b71f8:	4629      	mov	r1, r5
   b71fa:	f7ff f9f9 	bl	b65f0 <hal_i2c_init>
  if (result == SYSTEM_ERROR_NOT_ENOUGH_DATA && 
   b71fe:	30bf      	adds	r0, #191	; 0xbf
   b7200:	d108      	bne.n	b7214 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x34>
      (conf.flags & HAL_I2C_CONFIG_FLAG_FREEABLE)) {
   b7202:	696b      	ldr	r3, [r5, #20]
  if (result == SYSTEM_ERROR_NOT_ENOUGH_DATA && 
   b7204:	07db      	lsls	r3, r3, #31
   b7206:	d505      	bpl.n	b7214 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x34>
    free(conf.rx_buffer);
   b7208:	6868      	ldr	r0, [r5, #4]
   b720a:	f7ff fbc5 	bl	b6998 <free>
    free(conf.tx_buffer);
   b720e:	68e8      	ldr	r0, [r5, #12]
   b7210:	f7ff fbc2 	bl	b6998 <free>
}
   b7214:	4620      	mov	r0, r4
   b7216:	bd38      	pop	{r3, r4, r5, pc}
   b7218:	000bbe4c 	.word	0x000bbe4c

000b721c <_ZN7TwoWire5beginEv>:
	hal_i2c_begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
   b721c:	2300      	movs	r3, #0
   b721e:	7c00      	ldrb	r0, [r0, #16]
   b7220:	461a      	mov	r2, r3
   b7222:	4619      	mov	r1, r3
   b7224:	f7ff b99c 	b.w	b6560 <hal_i2c_begin>

000b7228 <_ZN7TwoWire11requestFromERK16WireTransmission>:
size_t TwoWire::requestFrom(const WireTransmission& transfer) {
   b7228:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    hal_i2c_transmission_config_t conf = {
   b722a:	2200      	movs	r2, #0
   b722c:	2314      	movs	r3, #20
   b722e:	e9cd 2201 	strd	r2, r2, [sp, #4]
   b7232:	f8ad 3004 	strh.w	r3, [sp, #4]
    };
   b7236:	780b      	ldrb	r3, [r1, #0]
   b7238:	f88d 3008 	strb.w	r3, [sp, #8]
   b723c:	684b      	ldr	r3, [r1, #4]
   b723e:	9303      	str	r3, [sp, #12]
   b7240:	68cb      	ldr	r3, [r1, #12]
   b7242:	9304      	str	r3, [sp, #16]
  return hal_i2c_request_ex(_i2c, &conf, nullptr);
   b7244:	7c00      	ldrb	r0, [r0, #16]
      .flags = (uint32_t)(stop_ ? HAL_I2C_TRANSMISSION_FLAG_STOP : 0)
   b7246:	7a0b      	ldrb	r3, [r1, #8]
   b7248:	9305      	str	r3, [sp, #20]
   b724a:	a901      	add	r1, sp, #4
   b724c:	f7ff f9d8 	bl	b6600 <hal_i2c_request_ex>
}
   b7250:	b007      	add	sp, #28
   b7252:	f85d fb04 	ldr.w	pc, [sp], #4

000b7256 <_ZN7TwoWire11requestFromEhjh>:
{
   b7256:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  return requestFrom(WireTransmission(address).quantity(quantity).stop(sendStop));
   b7258:	3b00      	subs	r3, #0
        timeout_{HAL_I2C_DEFAULT_TIMEOUT_MS} {
   b725a:	f88d 1000 	strb.w	r1, [sp]
   b725e:	f04f 0164 	mov.w	r1, #100	; 0x64
   b7262:	9103      	str	r1, [sp, #12]
   b7264:	bf18      	it	ne
   b7266:	2301      	movne	r3, #1
   b7268:	4669      	mov	r1, sp
    size_ = size;
   b726a:	9201      	str	r2, [sp, #4]
   b726c:	f88d 3008 	strb.w	r3, [sp, #8]
   b7270:	f7ff ffda 	bl	b7228 <_ZN7TwoWire11requestFromERK16WireTransmission>
}
   b7274:	b005      	add	sp, #20
   b7276:	f85d fb04 	ldr.w	pc, [sp], #4

000b727a <_ZN7TwoWire11requestFromEhj>:
  return requestFrom(address, quantity, (uint8_t)true);
   b727a:	2301      	movs	r3, #1
   b727c:	f7ff bfeb 	b.w	b7256 <_ZN7TwoWire11requestFromEhjh>

000b7280 <_ZN7TwoWire17beginTransmissionEh>:
	hal_i2c_begin_transmission(_i2c, address, NULL);
   b7280:	7c00      	ldrb	r0, [r0, #16]
   b7282:	2200      	movs	r2, #0
   b7284:	f7ff b974 	b.w	b6570 <hal_i2c_begin_transmission>

000b7288 <_ZN7TwoWire17beginTransmissionEi>:
  beginTransmission((uint8_t)address);
   b7288:	b2c9      	uxtb	r1, r1
   b728a:	f7ff bff9 	b.w	b7280 <_ZN7TwoWire17beginTransmissionEh>

000b728e <_ZN7TwoWire15endTransmissionEh>:
	return hal_i2c_end_transmission(_i2c, sendStop, NULL);
   b728e:	7c00      	ldrb	r0, [r0, #16]
   b7290:	2200      	movs	r2, #0
   b7292:	f7ff b975 	b.w	b6580 <hal_i2c_end_transmission>

000b7296 <_ZN7TwoWire15endTransmissionEv>:
  return endTransmission(true);
   b7296:	2101      	movs	r1, #1
   b7298:	f7ff bff9 	b.w	b728e <_ZN7TwoWire15endTransmissionEh>

000b729c <_ZN9IPAddressD1Ev>:
    IPAddress(uint32_t address);
    // 4 bytes defining the IP address in network order
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
   b729c:	4770      	bx	lr

000b729e <_ZN9IPAddressD0Ev>:
   b729e:	b510      	push	{r4, lr}
   b72a0:	2118      	movs	r1, #24
   b72a2:	4604      	mov	r4, r0
   b72a4:	f7fd fb57 	bl	b4956 <_ZdlPvj>
   b72a8:	4620      	mov	r0, r4
   b72aa:	bd10      	pop	{r4, pc}

000b72ac <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   b72ac:	b5f0      	push	{r4, r5, r6, r7, lr}
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   b72ae:	7d03      	ldrb	r3, [r0, #20]
   b72b0:	2b06      	cmp	r3, #6
{
   b72b2:	b08d      	sub	sp, #52	; 0x34
   b72b4:	460e      	mov	r6, r1
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   b72b6:	f100 0704 	add.w	r7, r0, #4
   b72ba:	f04f 0400 	mov.w	r4, #0
	if (address.v==6) {
   b72be:	d012      	beq.n	b72e6 <_ZNK9IPAddress7printToER5Print+0x3a>
   b72c0:	f100 0508 	add.w	r5, r0, #8
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
   b72c4:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
   b72c8:	220a      	movs	r2, #10
   b72ca:	4630      	mov	r0, r6
   b72cc:	f000 f95d 	bl	b758a <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   b72d0:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   b72d2:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
   b72d4:	d019      	beq.n	b730a <_ZNK9IPAddress7printToER5Print+0x5e>
        if (n)
   b72d6:	2c00      	cmp	r4, #0
   b72d8:	d0f4      	beq.n	b72c4 <_ZNK9IPAddress7printToER5Print+0x18>
            n += p.print('.');
   b72da:	212e      	movs	r1, #46	; 0x2e
   b72dc:	4630      	mov	r0, r6
   b72de:	f000 f93b 	bl	b7558 <_ZN5Print5printEc>
   b72e2:	4404      	add	r4, r0
   b72e4:	e7ee      	b.n	b72c4 <_ZNK9IPAddress7printToER5Print+0x18>
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   b72e6:	232f      	movs	r3, #47	; 0x2f
   b72e8:	466a      	mov	r2, sp
   b72ea:	4639      	mov	r1, r7
   b72ec:	200a      	movs	r0, #10
		buf[0] = 0;
   b72ee:	f88d 4000 	strb.w	r4, [sp]
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   b72f2:	f7ff f98d 	bl	b6610 <inet_inet_ntop>
      return write((const uint8_t *)str, strlen(str));
   b72f6:	4668      	mov	r0, sp
   b72f8:	f7fd fae6 	bl	b48c8 <strlen>
   b72fc:	6833      	ldr	r3, [r6, #0]
   b72fe:	4602      	mov	r2, r0
   b7300:	68db      	ldr	r3, [r3, #12]
   b7302:	4669      	mov	r1, sp
   b7304:	4630      	mov	r0, r6
   b7306:	4798      	blx	r3
   b7308:	4604      	mov	r4, r0
    }
    return n;
}
   b730a:	4620      	mov	r0, r4
   b730c:	b00d      	add	sp, #52	; 0x34
   b730e:	bdf0      	pop	{r4, r5, r6, r7, pc}

000b7310 <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
   b7310:	b510      	push	{r4, lr}
   b7312:	4b05      	ldr	r3, [pc, #20]	; (b7328 <_ZN9IPAddressC1Ev+0x18>)
   b7314:	4604      	mov	r4, r0
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   b7316:	2211      	movs	r2, #17
   b7318:	f840 3b04 	str.w	r3, [r0], #4
   b731c:	2100      	movs	r1, #0
   b731e:	f000 ff8e 	bl	b823e <memset>
}
   b7322:	4620      	mov	r0, r4
   b7324:	bd10      	pop	{r4, pc}
   b7326:	bf00      	nop
   b7328:	000bbe74 	.word	0x000bbe74

000b732c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
   b732c:	4603      	mov	r3, r0
   b732e:	4a07      	ldr	r2, [pc, #28]	; (b734c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
   b7330:	b510      	push	{r4, lr}
   b7332:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
   b7336:	f101 0210 	add.w	r2, r1, #16
   b733a:	f851 4b04 	ldr.w	r4, [r1], #4
   b733e:	f843 4b04 	str.w	r4, [r3], #4
   b7342:	4291      	cmp	r1, r2
   b7344:	d1f9      	bne.n	b733a <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
   b7346:	780a      	ldrb	r2, [r1, #0]
   b7348:	701a      	strb	r2, [r3, #0]
}
   b734a:	bd10      	pop	{r4, pc}
   b734c:	000bbe74 	.word	0x000bbe74

000b7350 <_ZN9IPAddress8set_ipv4Ehhhh>:
{
   b7350:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
   b7352:	f89d 4008 	ldrb.w	r4, [sp, #8]
   b7356:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
   b735a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   b735e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        address.v = version;
   b7362:	2304      	movs	r3, #4
   b7364:	6041      	str	r1, [r0, #4]
   b7366:	7503      	strb	r3, [r0, #20]
}
   b7368:	bd10      	pop	{r4, pc}
	...

000b736c <_ZN9IPAddressC1EPKh>:
IPAddress::IPAddress(const uint8_t* addr)
   b736c:	b507      	push	{r0, r1, r2, lr}
   b736e:	4b06      	ldr	r3, [pc, #24]	; (b7388 <_ZN9IPAddressC1EPKh+0x1c>)
   b7370:	6003      	str	r3, [r0, #0]
    set_ipv4(addr[0], addr[1], addr[2], addr[3]);
   b7372:	78cb      	ldrb	r3, [r1, #3]
   b7374:	9300      	str	r3, [sp, #0]
   b7376:	788b      	ldrb	r3, [r1, #2]
   b7378:	784a      	ldrb	r2, [r1, #1]
   b737a:	7809      	ldrb	r1, [r1, #0]
   b737c:	f7ff ffe8 	bl	b7350 <_ZN9IPAddress8set_ipv4Ehhhh>
}
   b7380:	b003      	add	sp, #12
   b7382:	f85d fb04 	ldr.w	pc, [sp], #4
   b7386:	bf00      	nop
   b7388:	000bbe74 	.word	0x000bbe74

000b738c <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
   b738c:	4b01      	ldr	r3, [pc, #4]	; (b7394 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
   b738e:	4a02      	ldr	r2, [pc, #8]	; (b7398 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
   b7390:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
   b7392:	4770      	bx	lr
   b7394:	2003e698 	.word	0x2003e698
   b7398:	000bbe80 	.word	0x000bbe80

000b739c <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
   b739c:	2300      	movs	r3, #0
   b739e:	6840      	ldr	r0, [r0, #4]
   b73a0:	461a      	mov	r2, r3
   b73a2:	f7ff ba91 	b.w	b68c8 <network_connect>

000b73a6 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
   b73a6:	6840      	ldr	r0, [r0, #4]
   b73a8:	2200      	movs	r2, #0
   b73aa:	2102      	movs	r1, #2
   b73ac:	f7ff ba9c 	b.w	b68e8 <network_disconnect>

000b73b0 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
   b73b0:	2200      	movs	r2, #0
   b73b2:	6840      	ldr	r0, [r0, #4]
   b73b4:	4611      	mov	r1, r2
   b73b6:	f7ff ba8f 	b.w	b68d8 <network_connecting>

000b73ba <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
   b73ba:	2200      	movs	r2, #0
   b73bc:	6840      	ldr	r0, [r0, #4]
   b73be:	4611      	mov	r1, r2
   b73c0:	f7ff ba9a 	b.w	b68f8 <network_ready>

000b73c4 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
   b73c4:	2300      	movs	r3, #0
   b73c6:	6840      	ldr	r0, [r0, #4]
   b73c8:	461a      	mov	r2, r3
   b73ca:	4619      	mov	r1, r3
   b73cc:	f7ff ba9c 	b.w	b6908 <network_on>

000b73d0 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
   b73d0:	2300      	movs	r3, #0
   b73d2:	6840      	ldr	r0, [r0, #4]
   b73d4:	461a      	mov	r2, r3
   b73d6:	4619      	mov	r1, r3
   b73d8:	f7ff ba9e 	b.w	b6918 <network_off>

000b73dc <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
   b73dc:	6840      	ldr	r0, [r0, #4]
   b73de:	2100      	movs	r1, #0
   b73e0:	f7ff bac2 	b.w	b6968 <network_is_on>

000b73e4 <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
   b73e4:	6840      	ldr	r0, [r0, #4]
   b73e6:	2100      	movs	r1, #0
   b73e8:	f7ff bac6 	b.w	b6978 <network_is_off>

000b73ec <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
   b73ec:	6840      	ldr	r0, [r0, #4]
   b73ee:	2200      	movs	r2, #0
   b73f0:	f081 0101 	eor.w	r1, r1, #1
   b73f4:	f7ff ba98 	b.w	b6928 <network_listen>

000b73f8 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
   b73f8:	6840      	ldr	r0, [r0, #4]
   b73fa:	2200      	movs	r2, #0
   b73fc:	f7ff baa4 	b.w	b6948 <network_set_listen_timeout>

000b7400 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
   b7400:	2200      	movs	r2, #0
   b7402:	6840      	ldr	r0, [r0, #4]
   b7404:	4611      	mov	r1, r2
   b7406:	f7ff baa7 	b.w	b6958 <network_get_listen_timeout>

000b740a <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
   b740a:	2200      	movs	r2, #0
   b740c:	6840      	ldr	r0, [r0, #4]
   b740e:	4611      	mov	r1, r2
   b7410:	f7ff ba92 	b.w	b6938 <network_listening>

000b7414 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
   b7414:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   b7418:	b095      	sub	sp, #84	; 0x54
   b741a:	4614      	mov	r4, r2
   b741c:	460d      	mov	r5, r1
   b741e:	4607      	mov	r7, r0
    IPAddress addr;
   b7420:	f7ff ff76 	bl	b7310 <_ZN9IPAddressC1Ev>
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   b7424:	2100      	movs	r1, #0
    struct addrinfo hints = {};
   b7426:	221c      	movs	r2, #28
   b7428:	a80d      	add	r0, sp, #52	; 0x34
    struct addrinfo *ai = nullptr;
   b742a:	9100      	str	r1, [sp, #0]
    struct addrinfo hints = {};
   b742c:	f000 ff07 	bl	b823e <memset>
    hints.ai_flags = AI_ADDRCONFIG;
   b7430:	2340      	movs	r3, #64	; 0x40
   b7432:	930c      	str	r3, [sp, #48]	; 0x30
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
   b7434:	4620      	mov	r0, r4
   b7436:	466b      	mov	r3, sp
   b7438:	aa0c      	add	r2, sp, #48	; 0x30
   b743a:	2100      	movs	r1, #0
   b743c:	f7ff f8f8 	bl	b6630 <netdb_getaddrinfo>
    if (!r) {
   b7440:	4604      	mov	r4, r0
   b7442:	2800      	cmp	r0, #0
   b7444:	d14b      	bne.n	b74de <_ZN5spark12NetworkClass7resolveEPKc+0xca>
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   b7446:	4602      	mov	r2, r0
   b7448:	2101      	movs	r1, #1
   b744a:	6868      	ldr	r0, [r5, #4]
   b744c:	f7ff fa54 	bl	b68f8 <network_ready>
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   b7450:	2102      	movs	r1, #2
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   b7452:	4680      	mov	r8, r0
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   b7454:	4622      	mov	r2, r4
   b7456:	6868      	ldr	r0, [r5, #4]
   b7458:	f7ff fa4e 	bl	b68f8 <network_ready>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   b745c:	9e00      	ldr	r6, [sp, #0]
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   b745e:	4681      	mov	r9, r0
        bool ok = false;
   b7460:	4621      	mov	r1, r4
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   b7462:	2e00      	cmp	r6, #0
   b7464:	d03b      	beq.n	b74de <_ZN5spark12NetworkClass7resolveEPKc+0xca>
   b7466:	2900      	cmp	r1, #0
   b7468:	d139      	bne.n	b74de <_ZN5spark12NetworkClass7resolveEPKc+0xca>
            // NOTE: using only the first entry that matches the current state of IPv4/IPv6 connectivity
            switch (cur->ai_family) {
   b746a:	6873      	ldr	r3, [r6, #4]
   b746c:	2b02      	cmp	r3, #2
   b746e:	d003      	beq.n	b7478 <_ZN5spark12NetworkClass7resolveEPKc+0x64>
   b7470:	2b0a      	cmp	r3, #10
   b7472:	d011      	beq.n	b7498 <_ZN5spark12NetworkClass7resolveEPKc+0x84>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   b7474:	69f6      	ldr	r6, [r6, #28]
   b7476:	e7f4      	b.n	b7462 <_ZN5spark12NetworkClass7resolveEPKc+0x4e>
                case AF_INET: {
                    if (!ipv4) {
   b7478:	f1b8 0f00 	cmp.w	r8, #0
   b747c:	d0fa      	beq.n	b7474 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                        continue;
                    }
                    // NOTE: HAL_IPAddress is little-endian
                    auto in = (struct sockaddr_in*)cur->ai_addr;
                    addr = (const uint8_t*)(&in->sin_addr.s_addr);
   b747e:	6971      	ldr	r1, [r6, #20]
        return *this = IPAddress(address);
   b7480:	a806      	add	r0, sp, #24
   b7482:	3104      	adds	r1, #4
class IPAddress : public Printable {
   b7484:	ad07      	add	r5, sp, #28
        return *this = IPAddress(address);
   b7486:	f7ff ff71 	bl	b736c <_ZN9IPAddressC1EPKh>
class IPAddress : public Printable {
   b748a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   b748c:	1d3c      	adds	r4, r7, #4
   b748e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   b7490:	682b      	ldr	r3, [r5, #0]
   b7492:	7023      	strb	r3, [r4, #0]
                    ok = true;
   b7494:	4641      	mov	r1, r8
        return *this = IPAddress(address);
   b7496:	e7ed      	b.n	b7474 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                    break;
                }
                case AF_INET6: {
                    if (!ipv6) {
   b7498:	f1b9 0f00 	cmp.w	r9, #0
   b749c:	d0ea      	beq.n	b7474 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                        continue;
                    }
                    auto in6 = (struct sockaddr_in6*)cur->ai_addr;
   b749e:	6974      	ldr	r4, [r6, #20]
                    HAL_IPAddress a = {};
   b74a0:	2210      	movs	r2, #16
   b74a2:	a801      	add	r0, sp, #4
   b74a4:	f000 fecb 	bl	b823e <memset>
                    a.v = 6;
   b74a8:	2306      	movs	r3, #6
   b74aa:	f88d 3014 	strb.w	r3, [sp, #20]
                    memcpy(a.ipv6, in6->sin6_addr.s6_addr, sizeof(a.ipv6));
   b74ae:	ad01      	add	r5, sp, #4
   b74b0:	f104 0308 	add.w	r3, r4, #8
   b74b4:	3418      	adds	r4, #24
   b74b6:	6818      	ldr	r0, [r3, #0]
   b74b8:	6859      	ldr	r1, [r3, #4]
   b74ba:	462a      	mov	r2, r5
   b74bc:	c203      	stmia	r2!, {r0, r1}
   b74be:	3308      	adds	r3, #8
   b74c0:	42a3      	cmp	r3, r4
   b74c2:	4615      	mov	r5, r2
   b74c4:	d1f7      	bne.n	b74b6 <_ZN5spark12NetworkClass7resolveEPKc+0xa2>
                    addr = IPAddress(a);
   b74c6:	a901      	add	r1, sp, #4
   b74c8:	a806      	add	r0, sp, #24
class IPAddress : public Printable {
   b74ca:	ad07      	add	r5, sp, #28
   b74cc:	f7ff ff2e 	bl	b732c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   b74d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   b74d2:	1d3c      	adds	r4, r7, #4
   b74d4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   b74d6:	682b      	ldr	r3, [r5, #0]
   b74d8:	7023      	strb	r3, [r4, #0]
                    ok = true;
   b74da:	4649      	mov	r1, r9
   b74dc:	e7ca      	b.n	b7474 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                    break;
                }
            }
        }
    }
    freeaddrinfo(ai);
   b74de:	9800      	ldr	r0, [sp, #0]
   b74e0:	f7ff f89e 	bl	b6620 <netdb_freeaddrinfo>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
   b74e4:	4638      	mov	r0, r7
   b74e6:	b015      	add	sp, #84	; 0x54
   b74e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000b74ec <_GLOBAL__sub_I__ZN5spark7NetworkE>:
   b74ec:	4b02      	ldr	r3, [pc, #8]	; (b74f8 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
   b74ee:	4a03      	ldr	r2, [pc, #12]	; (b74fc <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
   b74f0:	601a      	str	r2, [r3, #0]
   b74f2:	2200      	movs	r2, #0
   b74f4:	605a      	str	r2, [r3, #4]
    network_free_configuration(c, count, nullptr);
    return res;
}
#endif // HAL_USE_SOCKET_HAL_POSIX

} // spark
   b74f6:	4770      	bx	lr
   b74f8:	2003e69c 	.word	0x2003e69c
   b74fc:	000bbe8c 	.word	0x000bbe8c

000b7500 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
   b7500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b7502:	4606      	mov	r6, r0
   b7504:	460d      	mov	r5, r1
  size_t n = 0;
   b7506:	188f      	adds	r7, r1, r2
   b7508:	2400      	movs	r4, #0
  while (size--) {
   b750a:	42bd      	cmp	r5, r7
   b750c:	d00c      	beq.n	b7528 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
   b750e:	6833      	ldr	r3, [r6, #0]
   b7510:	f815 1b01 	ldrb.w	r1, [r5], #1
   b7514:	689b      	ldr	r3, [r3, #8]
   b7516:	4630      	mov	r0, r6
   b7518:	4798      	blx	r3
     if (chunk>=0)
   b751a:	1e03      	subs	r3, r0, #0
   b751c:	db01      	blt.n	b7522 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
   b751e:	441c      	add	r4, r3
  while (size--) {
   b7520:	e7f3      	b.n	b750a <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
   b7522:	2c00      	cmp	r4, #0
   b7524:	bf08      	it	eq
   b7526:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
   b7528:	4620      	mov	r0, r4
   b752a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b752c <_ZN5Print5writeEPKc>:
    size_t write(const char *str) {
   b752c:	b513      	push	{r0, r1, r4, lr}
   b752e:	4604      	mov	r4, r0
    }
   b7530:	4608      	mov	r0, r1
      if (str == NULL) return 0;
   b7532:	b159      	cbz	r1, b754c <_ZN5Print5writeEPKc+0x20>
      return write((const uint8_t *)str, strlen(str));
   b7534:	9101      	str	r1, [sp, #4]
   b7536:	f7fd f9c7 	bl	b48c8 <strlen>
   b753a:	6823      	ldr	r3, [r4, #0]
   b753c:	9901      	ldr	r1, [sp, #4]
   b753e:	68db      	ldr	r3, [r3, #12]
   b7540:	4602      	mov	r2, r0
   b7542:	4620      	mov	r0, r4
    }
   b7544:	b002      	add	sp, #8
   b7546:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return write((const uint8_t *)str, strlen(str));
   b754a:	4718      	bx	r3
    }
   b754c:	b002      	add	sp, #8
   b754e:	bd10      	pop	{r4, pc}

000b7550 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
   b7550:	b508      	push	{r3, lr}
  return write(str);
   b7552:	f7ff ffeb 	bl	b752c <_ZN5Print5writeEPKc>
}
   b7556:	bd08      	pop	{r3, pc}

000b7558 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
   b7558:	6803      	ldr	r3, [r0, #0]
   b755a:	689b      	ldr	r3, [r3, #8]
   b755c:	4718      	bx	r3

000b755e <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
   b755e:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
   b7560:	210d      	movs	r1, #13
{
   b7562:	4605      	mov	r5, r0
  size_t n = print('\r');
   b7564:	f7ff fff8 	bl	b7558 <_ZN5Print5printEc>
  n += print('\n');
   b7568:	210a      	movs	r1, #10
  size_t n = print('\r');
   b756a:	4604      	mov	r4, r0
  n += print('\n');
   b756c:	4628      	mov	r0, r5
   b756e:	f7ff fff3 	bl	b7558 <_ZN5Print5printEc>
  return n;
}
   b7572:	4420      	add	r0, r4
   b7574:	bd38      	pop	{r3, r4, r5, pc}

000b7576 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
   b7576:	b538      	push	{r3, r4, r5, lr}
   b7578:	4605      	mov	r5, r0
  return write(str);
   b757a:	f7ff ffd7 	bl	b752c <_ZN5Print5writeEPKc>
   b757e:	4604      	mov	r4, r0
  size_t n = print(c);
  n += println();
   b7580:	4628      	mov	r0, r5
   b7582:	f7ff ffec 	bl	b755e <_ZN5Print7printlnEv>
  return n;
}
   b7586:	4420      	add	r0, r4
   b7588:	bd38      	pop	{r3, r4, r5, pc}

000b758a <_ZN5Print11printNumberEmh>:
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
   b758a:	b530      	push	{r4, r5, lr}
   b758c:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
   b758e:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
   b7590:	2a01      	cmp	r2, #1
  *str = '\0';
   b7592:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
   b7596:	bf98      	it	ls
   b7598:	220a      	movls	r2, #10
   b759a:	ac09      	add	r4, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
   b759c:	460d      	mov	r5, r1
   b759e:	fbb1 f1f2 	udiv	r1, r1, r2
   char c = m - base * n;
   b75a2:	fb01 5312 	mls	r3, r1, r2, r5
   b75a6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   b75aa:	2b09      	cmp	r3, #9
   b75ac:	bf94      	ite	ls
   b75ae:	3330      	addls	r3, #48	; 0x30
   b75b0:	3337      	addhi	r3, #55	; 0x37
   b75b2:	b2db      	uxtb	r3, r3
  } while(n);
   b75b4:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   b75b6:	f804 3d01 	strb.w	r3, [r4, #-1]!
  } while(n);
   b75ba:	d9ef      	bls.n	b759c <_ZN5Print11printNumberEmh+0x12>

  return write(str);
   b75bc:	4621      	mov	r1, r4
   b75be:	f7ff ffb5 	bl	b752c <_ZN5Print5writeEPKc>
}
   b75c2:	b00b      	add	sp, #44	; 0x2c
   b75c4:	bd30      	pop	{r4, r5, pc}

000b75c6 <_ZN5Print7vprintfEbPKcSt9__va_list>:

  return n;
}

size_t Print::vprintf(bool newline, const char* format, va_list args)
{
   b75c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   b75ca:	b086      	sub	sp, #24
   b75cc:	af00      	add	r7, sp, #0
   b75ce:	4605      	mov	r5, r0
   b75d0:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list args2;
    va_copy(args2, args);
    size_t n = vsnprintf(test, bufsize, format, args);
   b75d2:	1d38      	adds	r0, r7, #4
   b75d4:	2114      	movs	r1, #20
{
   b75d6:	4614      	mov	r4, r2
    va_copy(args2, args);
   b75d8:	603b      	str	r3, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, args);
   b75da:	f7ff f9f5 	bl	b69c8 <vsnprintf>

    if (n<bufsize)
   b75de:	2813      	cmp	r0, #19
   b75e0:	d80e      	bhi.n	b7600 <_ZN5Print7vprintfEbPKcSt9__va_list+0x3a>
  return write(str);
   b75e2:	1d39      	adds	r1, r7, #4
   b75e4:	4628      	mov	r0, r5
   b75e6:	f7ff ffa1 	bl	b752c <_ZN5Print5writeEPKc>
   b75ea:	4604      	mov	r4, r0
    {
        char bigger[n+1];
        n = vsnprintf(bigger, n+1, format, args2);
        n = print(bigger);
    }
    if (newline)
   b75ec:	b11e      	cbz	r6, b75f6 <_ZN5Print7vprintfEbPKcSt9__va_list+0x30>
        n += println();
   b75ee:	4628      	mov	r0, r5
   b75f0:	f7ff ffb5 	bl	b755e <_ZN5Print7printlnEv>
   b75f4:	4404      	add	r4, r0

    va_end(args2);
    return n;
}
   b75f6:	4620      	mov	r0, r4
   b75f8:	3718      	adds	r7, #24
   b75fa:	46bd      	mov	sp, r7
   b75fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        char bigger[n+1];
   b7600:	f100 0308 	add.w	r3, r0, #8
   b7604:	f023 0307 	bic.w	r3, r3, #7
        n = print(bigger);
   b7608:	46e8      	mov	r8, sp
        char bigger[n+1];
   b760a:	ebad 0d03 	sub.w	sp, sp, r3
        n = vsnprintf(bigger, n+1, format, args2);
   b760e:	4622      	mov	r2, r4
   b7610:	1c41      	adds	r1, r0, #1
   b7612:	683b      	ldr	r3, [r7, #0]
   b7614:	4668      	mov	r0, sp
   b7616:	f7ff f9d7 	bl	b69c8 <vsnprintf>
  return write(str);
   b761a:	4669      	mov	r1, sp
   b761c:	4628      	mov	r0, r5
   b761e:	f7ff ff85 	bl	b752c <_ZN5Print5writeEPKc>
   b7622:	4604      	mov	r4, r0
   b7624:	46c5      	mov	sp, r8
   b7626:	e7e1      	b.n	b75ec <_ZN5Print7vprintfEbPKcSt9__va_list+0x26>

000b7628 <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
   b7628:	4b01      	ldr	r3, [pc, #4]	; (b7630 <_GLOBAL__sub_I_RGB+0x8>)
   b762a:	2200      	movs	r2, #0
   b762c:	609a      	str	r2, [r3, #8]
{
    RGBClass* const d = static_cast<RGBClass*>(data);
    if (d->changeHandler_) {
        d->changeHandler_(r, g, b);
    }
}
   b762e:	4770      	bx	lr
   b7630:	2003e6a4 	.word	0x2003e6a4

000b7634 <_ZN8SPIClass6unlockEv.isra.0>:
  }

  void unlock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    hal_spi_release(_spi, nullptr);
   b7634:	2100      	movs	r1, #0
   b7636:	f7ff b83b 	b.w	b66b0 <hal_spi_release>

000b763a <_ZN8SPIClass4lockEv.isra.0>:
    return hal_spi_acquire(_spi, nullptr);
   b763a:	2100      	movs	r1, #0
   b763c:	f7ff b830 	b.w	b66a0 <hal_spi_acquire>

000b7640 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
   b7640:	b510      	push	{r4, lr}
   b7642:	4604      	mov	r4, r0
   b7644:	4608      	mov	r0, r1
{
    _spi = spi;
   b7646:	7021      	strb	r1, [r4, #0]
    hal_spi_init(_spi);
   b7648:	f7ff f80a 	bl	b6660 <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
   b764c:	2300      	movs	r3, #0
   b764e:	6063      	str	r3, [r4, #4]
}
   b7650:	4620      	mov	r0, r4
   b7652:	bd10      	pop	{r4, pc}

000b7654 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
   b7654:	b513      	push	{r0, r1, r4, lr}
   b7656:	4604      	mov	r4, r0
    // TODO: Fetch default pin from HAL
    if (!lock())
   b7658:	7800      	ldrb	r0, [r0, #0]
   b765a:	f7ff ffee 	bl	b763a <_ZN8SPIClass4lockEv.isra.0>
   b765e:	b958      	cbnz	r0, b7678 <_ZN8SPIClass5beginEv+0x24>
   b7660:	7820      	ldrb	r0, [r4, #0]
    {
        hal_spi_begin(_spi, SPI_DEFAULT_SS);
   b7662:	9001      	str	r0, [sp, #4]
   b7664:	f64f 71ff 	movw	r1, #65535	; 0xffff
   b7668:	f7fe ffea 	bl	b6640 <hal_spi_begin>
        unlock();
   b766c:	9801      	ldr	r0, [sp, #4]
    }
}
   b766e:	b002      	add	sp, #8
   b7670:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   b7674:	f7ff bfde 	b.w	b7634 <_ZN8SPIClass6unlockEv.isra.0>
   b7678:	b002      	add	sp, #8
   b767a:	bd10      	pop	{r4, pc}

000b767c <_ZN8SPIClass19computeClockDividerEjjRhRj>:
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
   b767c:	0840      	lsrs	r0, r0, #1
{
   b767e:	b530      	push	{r4, r5, lr}
    clock >>= 1; // div2 is the first
   b7680:	6018      	str	r0, [r3, #0]
   b7682:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale < 7)
   b7684:	6818      	ldr	r0, [r3, #0]
   b7686:	4288      	cmp	r0, r1
   b7688:	b2e5      	uxtb	r5, r4
   b768a:	d906      	bls.n	b769a <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
   b768c:	3401      	adds	r4, #1
   b768e:	2c08      	cmp	r4, #8
   b7690:	d002      	beq.n	b7698 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
   b7692:	0840      	lsrs	r0, r0, #1
   b7694:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
   b7696:	e7f5      	b.n	b7684 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
   b7698:	2507      	movs	r5, #7
        scale++;
    }
    divider = clock_divisors[scale];
   b769a:	4b02      	ldr	r3, [pc, #8]	; (b76a4 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
   b769c:	5d5b      	ldrb	r3, [r3, r5]
   b769e:	7013      	strb	r3, [r2, #0]
}
   b76a0:	bd30      	pop	{r4, r5, pc}
   b76a2:	bf00      	nop
   b76a4:	000bbec0 	.word	0x000bbec0

000b76a8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>:
{
   b76a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   b76ac:	4606      	mov	r6, r0
   b76ae:	b08f      	sub	sp, #60	; 0x3c
    CHECK(lock());
   b76b0:	7800      	ldrb	r0, [r0, #0]
{
   b76b2:	460c      	mov	r4, r1
    CHECK(lock());
   b76b4:	f7ff ffc1 	bl	b763a <_ZN8SPIClass4lockEv.isra.0>
   b76b8:	2800      	cmp	r0, #0
   b76ba:	db1b      	blt.n	b76f4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4c>
    querySpiInfo(_spi, &spi_info);
   b76bc:	7835      	ldrb	r5, [r6, #0]
    memset(info, 0, sizeof(hal_spi_info_t));
   b76be:	2214      	movs	r2, #20
   b76c0:	2100      	movs	r1, #0
   b76c2:	a809      	add	r0, sp, #36	; 0x24
   b76c4:	f000 fdbb 	bl	b823e <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
   b76c8:	230b      	movs	r3, #11
    hal_spi_info(spi, info, nullptr);
   b76ca:	2200      	movs	r2, #0
   b76cc:	a909      	add	r1, sp, #36	; 0x24
   b76ce:	4628      	mov	r0, r5
    info->version = HAL_SPI_INFO_VERSION_1;
   b76d0:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    hal_spi_info(spi, info, nullptr);
   b76d4:	f7fe ffd4 	bl	b6680 <hal_spi_info>
    if (!info || !info->enabled || info->default_settings)
   b76d8:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
   b76dc:	b113      	cbz	r3, b76e4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x3c>
   b76de:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
   b76e2:	b155      	cbz	r5, b76fa <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x52>
  {
   b76e4:	2700      	movs	r7, #0
   b76e6:	46b9      	mov	r9, r7
   b76e8:	46b8      	mov	r8, r7
   b76ea:	2501      	movs	r5, #1
    if (default_ && other.default_)
   b76ec:	7923      	ldrb	r3, [r4, #4]
   b76ee:	b15d      	cbz	r5, b7708 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x60>
   b76f0:	b1c3      	cbz	r3, b7724 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x7c>
    return 0;
   b76f2:	2000      	movs	r0, #0
}
   b76f4:	b00f      	add	sp, #60	; 0x3c
   b76f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
   b76fa:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   b76fe:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
   b7702:	f89d 7035 	ldrb.w	r7, [sp, #53]	; 0x35
  }
   b7706:	e7f1      	b.n	b76ec <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x44>
    if (default_ == other.default_ &&
   b7708:	2b00      	cmp	r3, #0
   b770a:	d135      	bne.n	b7778 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xd0>
   b770c:	68a3      	ldr	r3, [r4, #8]
   b770e:	4543      	cmp	r3, r8
   b7710:	d108      	bne.n	b7724 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x7c>
        bitOrder_ == other.bitOrder_ &&
   b7712:	f88d 9020 	strb.w	r9, [sp, #32]
   b7716:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
   b771a:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   b771e:	89a3      	ldrh	r3, [r4, #12]
   b7720:	429a      	cmp	r2, r3
   b7722:	d0e6      	beq.n	b76f2 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
            uint8_t divisor = 0;
   b7724:	2300      	movs	r3, #0
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
   b7726:	68a1      	ldr	r1, [r4, #8]
            uint8_t divisor = 0;
   b7728:	f88d 300f 	strb.w	r3, [sp, #15]
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
   b772c:	980a      	ldr	r0, [sp, #40]	; 0x28
   b772e:	ab04      	add	r3, sp, #16
   b7730:	f10d 020f 	add.w	r2, sp, #15
   b7734:	f7ff ffa2 	bl	b767c <_ZN8SPIClass19computeClockDividerEjjRhRj>
    if (default_ && other.default_)
   b7738:	7921      	ldrb	r1, [r4, #4]
   b773a:	b985      	cbnz	r5, b775e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
    if (default_ == other.default_ &&
   b773c:	b989      	cbnz	r1, b7762 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
   b773e:	68a3      	ldr	r3, [r4, #8]
   b7740:	4543      	cmp	r3, r8
   b7742:	d30e      	bcc.n	b7762 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
        bitOrder_ == other.bitOrder_ &&
   b7744:	f88d 9020 	strb.w	r9, [sp, #32]
   b7748:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
   b774c:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   b7750:	89a3      	ldrh	r3, [r4, #12]
   b7752:	429a      	cmp	r2, r3
   b7754:	d105      	bne.n	b7762 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
   b7756:	9b04      	ldr	r3, [sp, #16]
   b7758:	4543      	cmp	r3, r8
   b775a:	d102      	bne.n	b7762 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
   b775c:	e7c9      	b.n	b76f2 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
    if (default_ && other.default_)
   b775e:	2900      	cmp	r1, #0
   b7760:	d1f9      	bne.n	b7756 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xae>
                hal_spi_set_settings(_spi, settings.default_, divisor, settings.bitOrder_,
   b7762:	2300      	movs	r3, #0
   b7764:	9301      	str	r3, [sp, #4]
   b7766:	7b63      	ldrb	r3, [r4, #13]
   b7768:	9300      	str	r3, [sp, #0]
   b776a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   b776e:	7b23      	ldrb	r3, [r4, #12]
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
   b7770:	7830      	ldrb	r0, [r6, #0]
   b7772:	f7fe ff8d 	bl	b6690 <hal_spi_set_settings>
   b7776:	e7bc      	b.n	b76f2 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
   b7778:	e9cd 5500 	strd	r5, r5, [sp]
   b777c:	462b      	mov	r3, r5
   b777e:	462a      	mov	r2, r5
   b7780:	2101      	movs	r1, #1
   b7782:	e7f5      	b.n	b7770 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xc8>

000b7784 <_ZN8SPIClass8transferEh>:

    return clock;
}

byte SPIClass::transfer(byte _data)
{
   b7784:	b508      	push	{r3, lr}
    return static_cast<byte>(hal_spi_transfer(_spi, _data));
   b7786:	7800      	ldrb	r0, [r0, #0]
   b7788:	f7fe ff62 	bl	b6650 <hal_spi_transfer>
}
   b778c:	b2c0      	uxtb	r0, r0
   b778e:	bd08      	pop	{r3, pc}

000b7790 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
   b7790:	b510      	push	{r4, lr}
   b7792:	4604      	mov	r4, r0
{
	free(buffer);
   b7794:	6800      	ldr	r0, [r0, #0]
   b7796:	f7ff f8ff 	bl	b6998 <free>
}
   b779a:	4620      	mov	r0, r4
   b779c:	bd10      	pop	{r4, pc}

000b779e <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
   b779e:	b510      	push	{r4, lr}
   b77a0:	4604      	mov	r4, r0
	if (buffer) free(buffer);
   b77a2:	6800      	ldr	r0, [r0, #0]
   b77a4:	b108      	cbz	r0, b77aa <_ZN6String10invalidateEv+0xc>
   b77a6:	f7ff f8f7 	bl	b6998 <free>
	buffer = NULL;
   b77aa:	2300      	movs	r3, #0
	capacity = len = 0;
   b77ac:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
   b77b0:	6023      	str	r3, [r4, #0]
}
   b77b2:	bd10      	pop	{r4, pc}

000b77b4 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
   b77b4:	b538      	push	{r3, r4, r5, lr}
   b77b6:	4604      	mov	r4, r0
   b77b8:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
   b77ba:	6800      	ldr	r0, [r0, #0]
   b77bc:	3101      	adds	r1, #1
   b77be:	f7ff f8f3 	bl	b69a8 <realloc>
	if (newbuffer) {
   b77c2:	b110      	cbz	r0, b77ca <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
   b77c4:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
   b77c8:	2001      	movs	r0, #1
	}
	return 0;
}
   b77ca:	bd38      	pop	{r3, r4, r5, pc}

000b77cc <_ZN6String7reserveEj>:
{
   b77cc:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
   b77ce:	6803      	ldr	r3, [r0, #0]
{
   b77d0:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
   b77d2:	b123      	cbz	r3, b77de <_ZN6String7reserveEj+0x12>
   b77d4:	6843      	ldr	r3, [r0, #4]
   b77d6:	428b      	cmp	r3, r1
   b77d8:	d301      	bcc.n	b77de <_ZN6String7reserveEj+0x12>
   b77da:	2001      	movs	r0, #1
}
   b77dc:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
   b77de:	4620      	mov	r0, r4
   b77e0:	f7ff ffe8 	bl	b77b4 <_ZN6String12changeBufferEj>
   b77e4:	2800      	cmp	r0, #0
   b77e6:	d0f9      	beq.n	b77dc <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
   b77e8:	68a3      	ldr	r3, [r4, #8]
   b77ea:	2b00      	cmp	r3, #0
   b77ec:	d1f5      	bne.n	b77da <_ZN6String7reserveEj+0xe>
   b77ee:	6822      	ldr	r2, [r4, #0]
   b77f0:	7013      	strb	r3, [r2, #0]
   b77f2:	e7f2      	b.n	b77da <_ZN6String7reserveEj+0xe>

000b77f4 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   b77f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b77f6:	460d      	mov	r5, r1
	if (!reserve(length)) {
   b77f8:	4611      	mov	r1, r2
   b77fa:	9201      	str	r2, [sp, #4]
{
   b77fc:	4604      	mov	r4, r0
	if (!reserve(length)) {
   b77fe:	f7ff ffe5 	bl	b77cc <_ZN6String7reserveEj>
   b7802:	9a01      	ldr	r2, [sp, #4]
   b7804:	b928      	cbnz	r0, b7812 <_ZN6String4copyEPKcj+0x1e>
		invalidate();
   b7806:	4620      	mov	r0, r4
   b7808:	f7ff ffc9 	bl	b779e <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
   b780c:	4620      	mov	r0, r4
   b780e:	b003      	add	sp, #12
   b7810:	bd30      	pop	{r4, r5, pc}
	len = length;
   b7812:	60a2      	str	r2, [r4, #8]
	memcpy(buffer, cstr, length);
   b7814:	4629      	mov	r1, r5
   b7816:	6820      	ldr	r0, [r4, #0]
   b7818:	f000 fd03 	bl	b8222 <memcpy>
	buffer[len] = 0;
   b781c:	6822      	ldr	r2, [r4, #0]
   b781e:	68a3      	ldr	r3, [r4, #8]
   b7820:	2100      	movs	r1, #0
   b7822:	54d1      	strb	r1, [r2, r3]
	return *this;
   b7824:	e7f2      	b.n	b780c <_ZN6String4copyEPKcj+0x18>

000b7826 <_ZN6StringC1EPK19__FlashStringHelper>:
	buffer = NULL;
   b7826:	2300      	movs	r3, #0
String::String(const __FlashStringHelper *pstr)
   b7828:	b513      	push	{r0, r1, r4, lr}
	capacity = 0;
   b782a:	e9c0 3300 	strd	r3, r3, [r0]
String::String(const __FlashStringHelper *pstr)
   b782e:	4604      	mov	r4, r0
	len = 0;
   b7830:	6083      	str	r3, [r0, #8]
	flags = 0;
   b7832:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
   b7834:	b141      	cbz	r1, b7848 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
	if (cstr) copy(cstr, strlen(cstr));
   b7836:	4608      	mov	r0, r1
   b7838:	9101      	str	r1, [sp, #4]
   b783a:	f7fd f845 	bl	b48c8 <strlen>
   b783e:	9901      	ldr	r1, [sp, #4]
   b7840:	4602      	mov	r2, r0
   b7842:	4620      	mov	r0, r4
   b7844:	f7ff ffd6 	bl	b77f4 <_ZN6String4copyEPKcj>
}
   b7848:	4620      	mov	r0, r4
   b784a:	b002      	add	sp, #8
   b784c:	bd10      	pop	{r4, pc}

000b784e <_ZN6String4moveERS_>:
    return copy(reinterpret_cast<const char*>(pstr), length);
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
void String::move(String &rhs)
{
   b784e:	b538      	push	{r3, r4, r5, lr}
   b7850:	4605      	mov	r5, r0
	if (buffer) {
   b7852:	6800      	ldr	r0, [r0, #0]
{
   b7854:	460c      	mov	r4, r1
	if (buffer) {
   b7856:	b170      	cbz	r0, b7876 <_ZN6String4moveERS_+0x28>
		if (capacity >= rhs.len && rhs.buffer) {
   b7858:	686a      	ldr	r2, [r5, #4]
   b785a:	688b      	ldr	r3, [r1, #8]
   b785c:	429a      	cmp	r2, r3
   b785e:	d308      	bcc.n	b7872 <_ZN6String4moveERS_+0x24>
   b7860:	6809      	ldr	r1, [r1, #0]
   b7862:	b131      	cbz	r1, b7872 <_ZN6String4moveERS_+0x24>
			strcpy(buffer, rhs.buffer);
   b7864:	f000 fd22 	bl	b82ac <strcpy>
			len = rhs.len;
   b7868:	68a3      	ldr	r3, [r4, #8]
   b786a:	60ab      	str	r3, [r5, #8]
			rhs.len = 0;
   b786c:	2300      	movs	r3, #0
	buffer = rhs.buffer;
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
	rhs.capacity = 0;
	rhs.len = 0;
   b786e:	60a3      	str	r3, [r4, #8]
}
   b7870:	bd38      	pop	{r3, r4, r5, pc}
			free(buffer);
   b7872:	f7ff f891 	bl	b6998 <free>
	buffer = rhs.buffer;
   b7876:	6823      	ldr	r3, [r4, #0]
   b7878:	602b      	str	r3, [r5, #0]
	capacity = rhs.capacity;
   b787a:	6863      	ldr	r3, [r4, #4]
   b787c:	606b      	str	r3, [r5, #4]
	len = rhs.len;
   b787e:	68a3      	ldr	r3, [r4, #8]
   b7880:	60ab      	str	r3, [r5, #8]
	rhs.buffer = NULL;
   b7882:	2300      	movs	r3, #0
	rhs.capacity = 0;
   b7884:	e9c4 3300 	strd	r3, r3, [r4]
   b7888:	e7f1      	b.n	b786e <_ZN6String4moveERS_+0x20>

000b788a <_ZN6StringC1EOS_>:
String::String(String &&rval)
   b788a:	b510      	push	{r4, lr}
	buffer = NULL;
   b788c:	2300      	movs	r3, #0
	capacity = 0;
   b788e:	e9c0 3300 	strd	r3, r3, [r0]
String::String(String &&rval)
   b7892:	4604      	mov	r4, r0
	len = 0;
   b7894:	6083      	str	r3, [r0, #8]
	flags = 0;
   b7896:	7303      	strb	r3, [r0, #12]
	move(rval);
   b7898:	f7ff ffd9 	bl	b784e <_ZN6String4moveERS_>
}
   b789c:	4620      	mov	r0, r4
   b789e:	bd10      	pop	{r4, pc}

000b78a0 <_ZN6StringaSERKS_>:
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
   b78a0:	4288      	cmp	r0, r1
{
   b78a2:	b510      	push	{r4, lr}
   b78a4:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
   b78a6:	d005      	beq.n	b78b4 <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
   b78a8:	680b      	ldr	r3, [r1, #0]
   b78aa:	b12b      	cbz	r3, b78b8 <_ZN6StringaSERKS_+0x18>
   b78ac:	688a      	ldr	r2, [r1, #8]
   b78ae:	4619      	mov	r1, r3
   b78b0:	f7ff ffa0 	bl	b77f4 <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
   b78b4:	4620      	mov	r0, r4
   b78b6:	bd10      	pop	{r4, pc}
	else invalidate();
   b78b8:	f7ff ff71 	bl	b779e <_ZN6String10invalidateEv>
   b78bc:	e7fa      	b.n	b78b4 <_ZN6StringaSERKS_+0x14>

000b78be <_ZN6StringC1ERKS_>:
String::String(const String &value)
   b78be:	b510      	push	{r4, lr}
	buffer = NULL;
   b78c0:	2300      	movs	r3, #0
String::String(const String &value)
   b78c2:	4604      	mov	r4, r0
	capacity = 0;
   b78c4:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
   b78c8:	6083      	str	r3, [r0, #8]
	flags = 0;
   b78ca:	7303      	strb	r3, [r0, #12]
	*this = value;
   b78cc:	f7ff ffe8 	bl	b78a0 <_ZN6StringaSERKS_>
}
   b78d0:	4620      	mov	r0, r4
   b78d2:	bd10      	pop	{r4, pc}

000b78d4 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
   b78d4:	b513      	push	{r0, r1, r4, lr}
   b78d6:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
   b78d8:	b159      	cbz	r1, b78f2 <_ZN6StringaSEPKc+0x1e>
   b78da:	4608      	mov	r0, r1
   b78dc:	9101      	str	r1, [sp, #4]
   b78de:	f7fc fff3 	bl	b48c8 <strlen>
   b78e2:	9901      	ldr	r1, [sp, #4]
   b78e4:	4602      	mov	r2, r0
   b78e6:	4620      	mov	r0, r4
   b78e8:	f7ff ff84 	bl	b77f4 <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
   b78ec:	4620      	mov	r0, r4
   b78ee:	b002      	add	sp, #8
   b78f0:	bd10      	pop	{r4, pc}
	else invalidate();
   b78f2:	f7ff ff54 	bl	b779e <_ZN6String10invalidateEv>
   b78f6:	e7f9      	b.n	b78ec <_ZN6StringaSEPKc+0x18>

000b78f8 <_ZN6StringC1Ehh>:
String::String(unsigned char value, unsigned char base)
   b78f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   b78fa:	4604      	mov	r4, r0
	buffer = NULL;
   b78fc:	2300      	movs	r3, #0
	capacity = 0;
   b78fe:	e9c4 3300 	strd	r3, r3, [r4]
	len = 0;
   b7902:	60a3      	str	r3, [r4, #8]
	flags = 0;
   b7904:	7323      	strb	r3, [r4, #12]
String::String(unsigned char value, unsigned char base)
   b7906:	4608      	mov	r0, r1
	utoa(value, buf, base);
   b7908:	a901      	add	r1, sp, #4
   b790a:	f000 fadf 	bl	b7ecc <utoa>
	*this = buf;
   b790e:	a901      	add	r1, sp, #4
   b7910:	4620      	mov	r0, r4
   b7912:	f7ff ffdf 	bl	b78d4 <_ZN6StringaSEPKc>
}
   b7916:	4620      	mov	r0, r4
   b7918:	b004      	add	sp, #16
   b791a:	bd10      	pop	{r4, pc}

000b791c <_ZN6StringC1Eih>:
String::String(int value, unsigned char base)
   b791c:	b510      	push	{r4, lr}
   b791e:	4604      	mov	r4, r0
   b7920:	b08a      	sub	sp, #40	; 0x28
	buffer = NULL;
   b7922:	2300      	movs	r3, #0
	capacity = 0;
   b7924:	e9c4 3300 	strd	r3, r3, [r4]
	len = 0;
   b7928:	60a3      	str	r3, [r4, #8]
	flags = 0;
   b792a:	7323      	strb	r3, [r4, #12]
String::String(int value, unsigned char base)
   b792c:	4608      	mov	r0, r1
	itoa(value, buf, base);
   b792e:	a901      	add	r1, sp, #4
   b7930:	f000 fab6 	bl	b7ea0 <itoa>
	*this = buf;
   b7934:	a901      	add	r1, sp, #4
   b7936:	4620      	mov	r0, r4
   b7938:	f7ff ffcc 	bl	b78d4 <_ZN6StringaSEPKc>
}
   b793c:	4620      	mov	r0, r4
   b793e:	b00a      	add	sp, #40	; 0x28
   b7940:	bd10      	pop	{r4, pc}

000b7942 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
   b7942:	b570      	push	{r4, r5, r6, lr}
   b7944:	4605      	mov	r5, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
   b7946:	460e      	mov	r6, r1
   b7948:	b909      	cbnz	r1, b794e <_ZN6String6concatEPKcj+0xc>
   b794a:	2000      	movs	r0, #0
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
   b794c:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
   b794e:	b16a      	cbz	r2, b796c <_ZN6String6concatEPKcj+0x2a>
	unsigned int newlen = len + length;
   b7950:	6884      	ldr	r4, [r0, #8]
   b7952:	4414      	add	r4, r2
	if (!reserve(newlen)) return 0;
   b7954:	4621      	mov	r1, r4
   b7956:	f7ff ff39 	bl	b77cc <_ZN6String7reserveEj>
   b795a:	2800      	cmp	r0, #0
   b795c:	d0f5      	beq.n	b794a <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
   b795e:	6828      	ldr	r0, [r5, #0]
   b7960:	68ab      	ldr	r3, [r5, #8]
   b7962:	4631      	mov	r1, r6
   b7964:	4418      	add	r0, r3
   b7966:	f000 fca1 	bl	b82ac <strcpy>
	len = newlen;
   b796a:	60ac      	str	r4, [r5, #8]
	if (length == 0) return 1;
   b796c:	2001      	movs	r0, #1
   b796e:	e7ed      	b.n	b794c <_ZN6String6concatEPKcj+0xa>

000b7970 <_ZN6String6concatERKS_>:
	return concat(s.buffer, s.len);
   b7970:	688a      	ldr	r2, [r1, #8]
   b7972:	6809      	ldr	r1, [r1, #0]
   b7974:	f7ff bfe5 	b.w	b7942 <_ZN6String6concatEPKcj>

000b7978 <_ZN6String6concatEPKc>:

unsigned char String::concat(const char *cstr)
{
   b7978:	b513      	push	{r0, r1, r4, lr}
   b797a:	4604      	mov	r4, r0
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
}
   b797c:	4608      	mov	r0, r1
	if (!cstr) return 0;
   b797e:	b151      	cbz	r1, b7996 <_ZN6String6concatEPKc+0x1e>
	return concat(cstr, strlen(cstr));
   b7980:	9101      	str	r1, [sp, #4]
   b7982:	f7fc ffa1 	bl	b48c8 <strlen>
   b7986:	9901      	ldr	r1, [sp, #4]
   b7988:	4602      	mov	r2, r0
   b798a:	4620      	mov	r0, r4
}
   b798c:	b002      	add	sp, #8
   b798e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return concat(cstr, strlen(cstr));
   b7992:	f7ff bfd6 	b.w	b7942 <_ZN6String6concatEPKcj>
}
   b7996:	b002      	add	sp, #8
   b7998:	bd10      	pop	{r4, pc}

000b799a <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
   b799a:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
   b799c:	688a      	ldr	r2, [r1, #8]
   b799e:	6809      	ldr	r1, [r1, #0]
{
   b79a0:	4604      	mov	r4, r0
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
   b79a2:	f7ff ffce 	bl	b7942 <_ZN6String6concatEPKcj>
   b79a6:	b910      	cbnz	r0, b79ae <_ZplRK15StringSumHelperRK6String+0x14>
   b79a8:	4620      	mov	r0, r4
   b79aa:	f7ff fef8 	bl	b779e <_ZN6String10invalidateEv>
	return a;
}
   b79ae:	4620      	mov	r0, r4
   b79b0:	bd10      	pop	{r4, pc}

000b79b2 <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
   b79b2:	b513      	push	{r0, r1, r4, lr}
   b79b4:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
   b79b6:	b929      	cbnz	r1, b79c4 <_ZplRK15StringSumHelperPKc+0x12>
   b79b8:	4620      	mov	r0, r4
   b79ba:	f7ff fef0 	bl	b779e <_ZN6String10invalidateEv>
	return a;
}
   b79be:	4620      	mov	r0, r4
   b79c0:	b002      	add	sp, #8
   b79c2:	bd10      	pop	{r4, pc}
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
   b79c4:	4608      	mov	r0, r1
   b79c6:	9101      	str	r1, [sp, #4]
   b79c8:	f7fc ff7e 	bl	b48c8 <strlen>
   b79cc:	9901      	ldr	r1, [sp, #4]
   b79ce:	4602      	mov	r2, r0
   b79d0:	4620      	mov	r0, r4
   b79d2:	f7ff ffb6 	bl	b7942 <_ZN6String6concatEPKcj>
   b79d6:	2800      	cmp	r0, #0
   b79d8:	d0ee      	beq.n	b79b8 <_ZplRK15StringSumHelperPKc+0x6>
   b79da:	e7f0      	b.n	b79be <_ZplRK15StringSumHelperPKc+0xc>

000b79dc <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
   b79dc:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
   b79de:	6882      	ldr	r2, [r0, #8]
   b79e0:	b93a      	cbnz	r2, b79f2 <_ZNK6String6equalsEPKc+0x16>
   b79e2:	b121      	cbz	r1, b79ee <_ZNK6String6equalsEPKc+0x12>
   b79e4:	7808      	ldrb	r0, [r1, #0]
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
   b79e6:	fab0 f080 	clz	r0, r0
   b79ea:	0940      	lsrs	r0, r0, #5
   b79ec:	e000      	b.n	b79f0 <_ZNK6String6equalsEPKc+0x14>
	if (len == 0) return (cstr == NULL || *cstr == 0);
   b79ee:	2001      	movs	r0, #1
}
   b79f0:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
   b79f2:	6800      	ldr	r0, [r0, #0]
   b79f4:	b909      	cbnz	r1, b79fa <_ZNK6String6equalsEPKc+0x1e>
   b79f6:	7800      	ldrb	r0, [r0, #0]
   b79f8:	e7f5      	b.n	b79e6 <_ZNK6String6equalsEPKc+0xa>
	return strcmp(buffer, cstr) == 0;
   b79fa:	f7fc ff5b 	bl	b48b4 <strcmp>
   b79fe:	e7f2      	b.n	b79e6 <_ZNK6String6equalsEPKc+0xa>

000b7a00 <_ZN6String6formatEPKcz>:
    StringPrintableHelper help(*this);
    printable.printTo(help);
}

String String::format(const char* fmt, ...)
{
   b7a00:	b40e      	push	{r1, r2, r3}
   b7a02:	b570      	push	{r4, r5, r6, lr}
   b7a04:	b087      	sub	sp, #28
   b7a06:	ad0b      	add	r5, sp, #44	; 0x2c
   b7a08:	4604      	mov	r4, r0
   b7a0a:	f855 2b04 	ldr.w	r2, [r5], #4
    va_list marker;
    va_start(marker, fmt);
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
   b7a0e:	9201      	str	r2, [sp, #4]
   b7a10:	462b      	mov	r3, r5
   b7a12:	2105      	movs	r1, #5
   b7a14:	a804      	add	r0, sp, #16
    va_start(marker, fmt);
   b7a16:	9503      	str	r5, [sp, #12]
    size_t n = vsnprintf(test, bufsize, fmt, marker);
   b7a18:	f7fe ffd6 	bl	b69c8 <vsnprintf>
    va_end(marker);

    String result;
   b7a1c:	490b      	ldr	r1, [pc, #44]	; (b7a4c <_ZN6String6formatEPKcz+0x4c>)
    size_t n = vsnprintf(test, bufsize, fmt, marker);
   b7a1e:	4606      	mov	r6, r0
    String result;
   b7a20:	4620      	mov	r0, r4
   b7a22:	f7ff ff00 	bl	b7826 <_ZN6StringC1EPK19__FlashStringHelper>
    result.reserve(n);  // internally adds +1 for null terminator
   b7a26:	4631      	mov	r1, r6
   b7a28:	4620      	mov	r0, r4
   b7a2a:	f7ff fecf 	bl	b77cc <_ZN6String7reserveEj>
    if (result.buffer) {
   b7a2e:	6820      	ldr	r0, [r4, #0]
   b7a30:	b130      	cbz	r0, b7a40 <_ZN6String6formatEPKcz+0x40>
        va_start(marker, fmt);
        n = vsnprintf(result.buffer, n+1, fmt, marker);
   b7a32:	9a01      	ldr	r2, [sp, #4]
        va_start(marker, fmt);
   b7a34:	9503      	str	r5, [sp, #12]
        n = vsnprintf(result.buffer, n+1, fmt, marker);
   b7a36:	462b      	mov	r3, r5
   b7a38:	1c71      	adds	r1, r6, #1
   b7a3a:	f7fe ffc5 	bl	b69c8 <vsnprintf>
        va_end(marker);
        result.len = n;
   b7a3e:	60a0      	str	r0, [r4, #8]
    }
    return result;
}
   b7a40:	4620      	mov	r0, r4
   b7a42:	b007      	add	sp, #28
   b7a44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   b7a48:	b003      	add	sp, #12
   b7a4a:	4770      	bx	lr
   b7a4c:	000b8734 	.word	0x000b8734

000b7a50 <_ZN11SystemClass10freeMemoryEv>:
    System.systemSleepResult_ = SystemSleepResult(SleepResult(ret, pins, pins_count));
    return System.systemSleepResult_;
}

uint32_t SystemClass::freeMemory()
{
   b7a50:	b510      	push	{r4, lr}
    runtime_info_t info;
    memset(&info, 0, sizeof(info));
   b7a52:	2420      	movs	r4, #32
{
   b7a54:	b088      	sub	sp, #32
    memset(&info, 0, sizeof(info));
   b7a56:	4622      	mov	r2, r4
   b7a58:	2100      	movs	r1, #0
   b7a5a:	4668      	mov	r0, sp
   b7a5c:	f000 fbef 	bl	b823e <memset>
    info.size = sizeof(info);
    HAL_Core_Runtime_Info(&info, NULL);
   b7a60:	2100      	movs	r1, #0
   b7a62:	4668      	mov	r0, sp
    info.size = sizeof(info);
   b7a64:	f8ad 4000 	strh.w	r4, [sp]
    HAL_Core_Runtime_Info(&info, NULL);
   b7a68:	f7fe fd32 	bl	b64d0 <HAL_Core_Runtime_Info>
    return info.freeheap;
}
   b7a6c:	9801      	ldr	r0, [sp, #4]
   b7a6e:	b008      	add	sp, #32
   b7a70:	bd10      	pop	{r4, pc}
	...

000b7a74 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
   b7a74:	4b05      	ldr	r3, [pc, #20]	; (b7a8c <_GLOBAL__sub_I_System+0x18>)
   b7a76:	2202      	movs	r2, #2
   b7a78:	601a      	str	r2, [r3, #0]

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   b7a7a:	4b05      	ldr	r3, [pc, #20]	; (b7a90 <_GLOBAL__sub_I_System+0x1c>)
    SleepResult() {}
   b7a7c:	4a05      	ldr	r2, [pc, #20]	; (b7a94 <_GLOBAL__sub_I_System+0x20>)
   b7a7e:	609a      	str	r2, [r3, #8]
              error_(SYSTEM_ERROR_NONE) {
   b7a80:	2000      	movs	r0, #0
   b7a82:	e9c3 0000 	strd	r0, r0, [r3]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   b7a86:	f7fe be9b 	b.w	b67c0 <set_system_mode>
   b7a8a:	bf00      	nop
   b7a8c:	2003e6c0 	.word	0x2003e6c0
   b7a90:	2003e6b4 	.word	0x2003e6b4
   b7a94:	ffff0000 	.word	0xffff0000

000b7a98 <_ZL22Refresh_UnixTime_Cachex>:
	return calendar_time;
}

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
   b7a98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unix_time += time_zone_cache;
   b7a9c:	4a15      	ldr	r2, [pc, #84]	; (b7af4 <_ZL22Refresh_UnixTime_Cachex+0x5c>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
   b7a9e:	f8df 8060 	ldr.w	r8, [pc, #96]	; b7b00 <_ZL22Refresh_UnixTime_Cachex+0x68>
    unix_time += time_zone_cache;
   b7aa2:	e9d2 6300 	ldrd	r6, r3, [r2]
   b7aa6:	1980      	adds	r0, r0, r6
   b7aa8:	eb43 0101 	adc.w	r1, r3, r1
    unix_time += dst_current_cache;
   b7aac:	4b12      	ldr	r3, [pc, #72]	; (b7af8 <_ZL22Refresh_UnixTime_Cachex+0x60>)
   b7aae:	e9d3 6700 	ldrd	r6, r7, [r3]
    if(unix_time != unix_time_cache)
   b7ab2:	e9d8 2300 	ldrd	r2, r3, [r8]
    unix_time += dst_current_cache;
   b7ab6:	1986      	adds	r6, r0, r6
   b7ab8:	eb41 0707 	adc.w	r7, r1, r7
    if(unix_time != unix_time_cache)
   b7abc:	42bb      	cmp	r3, r7
   b7abe:	bf08      	it	eq
   b7ac0:	42b2      	cmpeq	r2, r6
{
   b7ac2:	b08c      	sub	sp, #48	; 0x30
    if(unix_time != unix_time_cache)
   b7ac4:	d013      	beq.n	b7aee <_ZL22Refresh_UnixTime_Cachex+0x56>
	localtime_r(&unix_time, &calendar_time);
   b7ac6:	a903      	add	r1, sp, #12
   b7ac8:	4668      	mov	r0, sp
   b7aca:	e9cd 6700 	strd	r6, r7, [sp]
   b7ace:	f7fe ffab 	bl	b6a28 <localtime_r>
	calendar_time.tm_year += 1900;
   b7ad2:	9b08      	ldr	r3, [sp, #32]
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   b7ad4:	4d09      	ldr	r5, [pc, #36]	; (b7afc <_ZL22Refresh_UnixTime_Cachex+0x64>)
	calendar_time.tm_year += 1900;
   b7ad6:	f203 736c 	addw	r3, r3, #1900	; 0x76c
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   b7ada:	ac03      	add	r4, sp, #12
	calendar_time.tm_year += 1900;
   b7adc:	9308      	str	r3, [sp, #32]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   b7ade:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   b7ae0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   b7ae2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   b7ae4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
   b7ae6:	e9c8 6700 	strd	r6, r7, [r8]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   b7aea:	6823      	ldr	r3, [r4, #0]
   b7aec:	602b      	str	r3, [r5, #0]
    }
}
   b7aee:	b00c      	add	sp, #48	; 0x30
   b7af0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   b7af4:	2003e6f8 	.word	0x2003e6f8
   b7af8:	2003e6f0 	.word	0x2003e6f0
   b7afc:	2003e6c8 	.word	0x2003e6c8
   b7b00:	2003e700 	.word	0x2003e700

000b7b04 <_ZN10CloudClass12syncTimeDoneEv.isra.0>:
    bool syncTimeDone(void)
   b7b04:	b508      	push	{r3, lr}
        return !spark_sync_time_pending(nullptr) || disconnected();
   b7b06:	2000      	movs	r0, #0
   b7b08:	f7fe febe 	bl	b6888 <spark_sync_time_pending>
   b7b0c:	b128      	cbz	r0, b7b1a <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x16>
    static bool connected(void) { return spark_cloud_flag_connected(); }
   b7b0e:	f7fe fea3 	bl	b6858 <spark_cloud_flag_connected>
        return !spark_sync_time_pending(nullptr) || disconnected();
   b7b12:	f080 0001 	eor.w	r0, r0, #1
   b7b16:	b2c0      	uxtb	r0, r0
    }
   b7b18:	bd08      	pop	{r3, pc}
        return !spark_sync_time_pending(nullptr) || disconnected();
   b7b1a:	2001      	movs	r0, #1
   b7b1c:	e7fc      	b.n	b7b18 <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x14>
	...

000b7b20 <_ZN9TimeClass12hourFormat12Ex>:
	return hourFormat12(now());
}

/* the hour for the given time in 12 hour format */
int TimeClass::hourFormat12(time_t t)
{
   b7b20:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   b7b22:	f7ff ffb9 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
	if(calendar_time_cache.tm_hour == 0)
   b7b26:	4b04      	ldr	r3, [pc, #16]	; (b7b38 <_ZN9TimeClass12hourFormat12Ex+0x18>)
   b7b28:	6898      	ldr	r0, [r3, #8]
   b7b2a:	b118      	cbz	r0, b7b34 <_ZN9TimeClass12hourFormat12Ex+0x14>
		return 12;	//midnight
	else if( calendar_time_cache.tm_hour > 12)
   b7b2c:	280c      	cmp	r0, #12
   b7b2e:	dd00      	ble.n	b7b32 <_ZN9TimeClass12hourFormat12Ex+0x12>
		return calendar_time_cache.tm_hour - 12 ;
   b7b30:	380c      	subs	r0, #12
	else
		return calendar_time_cache.tm_hour ;
}
   b7b32:	bd08      	pop	{r3, pc}
		return 12;	//midnight
   b7b34:	200c      	movs	r0, #12
   b7b36:	e7fc      	b.n	b7b32 <_ZN9TimeClass12hourFormat12Ex+0x12>
   b7b38:	2003e6c8 	.word	0x2003e6c8

000b7b3c <_ZN9TimeClass4isPMEx>:
	return isPM(now());
}

/* returns true the given time is PM */
uint8_t TimeClass::isPM(time_t t)
{
   b7b3c:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   b7b3e:	f7ff ffab 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
	return calendar_time_cache.tm_hour;
   b7b42:	4b03      	ldr	r3, [pc, #12]	; (b7b50 <_ZN9TimeClass4isPMEx+0x14>)
	return (hour(t) >= 12);
   b7b44:	6898      	ldr	r0, [r3, #8]
}
   b7b46:	280b      	cmp	r0, #11
   b7b48:	bfd4      	ite	le
   b7b4a:	2000      	movle	r0, #0
   b7b4c:	2001      	movgt	r0, #1
   b7b4e:	bd08      	pop	{r3, pc}
   b7b50:	2003e6c8 	.word	0x2003e6c8

000b7b54 <_ZN9TimeClass6minuteEx>:
	return minute(now());
}

/* the minute for the given time */
int TimeClass::minute(time_t t)
{
   b7b54:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   b7b56:	f7ff ff9f 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
	return calendar_time_cache.tm_min;
}
   b7b5a:	4b01      	ldr	r3, [pc, #4]	; (b7b60 <_ZN9TimeClass6minuteEx+0xc>)
   b7b5c:	6858      	ldr	r0, [r3, #4]
   b7b5e:	bd08      	pop	{r3, pc}
   b7b60:	2003e6c8 	.word	0x2003e6c8

000b7b64 <_ZN9TimeClass6secondEx>:
	return second(now());
}

/* the second for the given time */
int TimeClass::second(time_t t)
{
   b7b64:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   b7b66:	f7ff ff97 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
	return calendar_time_cache.tm_sec;
}
   b7b6a:	4b01      	ldr	r3, [pc, #4]	; (b7b70 <_ZN9TimeClass6secondEx+0xc>)
   b7b6c:	6818      	ldr	r0, [r3, #0]
   b7b6e:	bd08      	pop	{r3, pc}
   b7b70:	2003e6c8 	.word	0x2003e6c8

000b7b74 <_ZN9TimeClass5monthEx>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
   b7b74:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   b7b76:	f7ff ff8f 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
   b7b7a:	4b02      	ldr	r3, [pc, #8]	; (b7b84 <_ZN9TimeClass5monthEx+0x10>)
   b7b7c:	6918      	ldr	r0, [r3, #16]
}
   b7b7e:	3001      	adds	r0, #1
   b7b80:	bd08      	pop	{r3, pc}
   b7b82:	bf00      	nop
   b7b84:	2003e6c8 	.word	0x2003e6c8

000b7b88 <_ZN9TimeClass4zoneEf>:
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
	if(GMT_Offset < -12 || GMT_Offset > 14)
   b7b88:	eefa 7a08 	vmov.f32	s15, #168	; 0xc1400000 -12.0
   b7b8c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   b7b90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   b7b94:	b508      	push	{r3, lr}
	if(GMT_Offset < -12 || GMT_Offset > 14)
   b7b96:	d411      	bmi.n	b7bbc <_ZN9TimeClass4zoneEf+0x34>
   b7b98:	eef2 7a0c 	vmov.f32	s15, #44	; 0x41600000  14.0
   b7b9c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   b7ba0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   b7ba4:	dc0a      	bgt.n	b7bbc <_ZN9TimeClass4zoneEf+0x34>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
   b7ba6:	eddf 7a06 	vldr	s15, [pc, #24]	; b7bc0 <_ZN9TimeClass4zoneEf+0x38>
   b7baa:	ee60 7a27 	vmul.f32	s15, s0, s15
   b7bae:	ee17 0a90 	vmov	r0, s15
   b7bb2:	f7fc fe4b 	bl	b484c <__aeabi_f2lz>
   b7bb6:	4b03      	ldr	r3, [pc, #12]	; (b7bc4 <_ZN9TimeClass4zoneEf+0x3c>)
   b7bb8:	e9c3 0100 	strd	r0, r1, [r3]
}
   b7bbc:	bd08      	pop	{r3, pc}
   b7bbe:	bf00      	nop
   b7bc0:	45610000 	.word	0x45610000
   b7bc4:	2003e6f8 	.word	0x2003e6f8

000b7bc8 <_ZN9TimeClass7isValidEv>:
    strftime(buf, sizeof(buf), format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
   b7bc8:	b510      	push	{r4, lr}
    bool rtcstate = hal_rtc_time_is_valid(nullptr);
   b7bca:	2000      	movs	r0, #0
   b7bcc:	f7fe fc98 	bl	b6500 <hal_rtc_time_is_valid>
    if (rtcstate)
   b7bd0:	4604      	mov	r4, r0
   b7bd2:	b9a0      	cbnz	r0, b7bfe <_ZN9TimeClass7isValidEv+0x36>
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
   b7bd4:	f7fe fdec 	bl	b67b0 <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
   b7bd8:	2801      	cmp	r0, #1
   b7bda:	d110      	bne.n	b7bfe <_ZN9TimeClass7isValidEv+0x36>
   b7bdc:	4620      	mov	r0, r4
   b7bde:	f7fe fe0f 	bl	b6800 <system_thread_get_state>
   b7be2:	b960      	cbnz	r0, b7bfe <_ZN9TimeClass7isValidEv+0x36>
    {
        waitUntil(Particle.syncTimeDone);
   b7be4:	f7ff ff8e 	bl	b7b04 <_ZN10CloudClass12syncTimeDoneEv.isra.0>

    static uint32_t freeMemory();

    template<typename Condition, typename While>
    static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
   b7be8:	b910      	cbnz	r0, b7bf0 <_ZN9TimeClass7isValidEv+0x28>
            spark_process();
   b7bea:	f7fe fe25 	bl	b6838 <spark_process>
        while (_while() && !_condition()) {
   b7bee:	e7f9      	b.n	b7be4 <_ZN9TimeClass7isValidEv+0x1c>
   b7bf0:	f7ff ff88 	bl	b7b04 <_ZN10CloudClass12syncTimeDoneEv.isra.0>
        return hal_rtc_time_is_valid(nullptr);
    }
    return rtcstate;
}
   b7bf4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return hal_rtc_time_is_valid(nullptr);
   b7bf8:	2000      	movs	r0, #0
   b7bfa:	f7fe bc81 	b.w	b6500 <hal_rtc_time_is_valid>
}
   b7bfe:	4620      	mov	r0, r4
   b7c00:	bd10      	pop	{r4, pc}

000b7c02 <_ZN9TimeClass3nowEv>:
{
   b7c02:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    (void)isValid();
   b7c04:	f7ff ffe0 	bl	b7bc8 <_ZN9TimeClass7isValidEv>
    struct timeval tv = {};
   b7c08:	2210      	movs	r2, #16
   b7c0a:	2100      	movs	r1, #0
   b7c0c:	4668      	mov	r0, sp
   b7c0e:	f000 fb16 	bl	b823e <memset>
    hal_rtc_get_time(&tv, nullptr);
   b7c12:	2100      	movs	r1, #0
   b7c14:	4668      	mov	r0, sp
   b7c16:	f7fe fc7b 	bl	b6510 <hal_rtc_get_time>
}
   b7c1a:	9800      	ldr	r0, [sp, #0]
   b7c1c:	b005      	add	sp, #20
   b7c1e:	f85d fb04 	ldr.w	pc, [sp], #4

000b7c22 <_ZN9TimeClass4isPMEv>:
{
   b7c22:	b508      	push	{r3, lr}
	return isPM(now());
   b7c24:	f7ff ffed 	bl	b7c02 <_ZN9TimeClass3nowEv>
}
   b7c28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return isPM(now());
   b7c2c:	17c1      	asrs	r1, r0, #31
   b7c2e:	f7ff bf85 	b.w	b7b3c <_ZN9TimeClass4isPMEx>
	...

000b7c34 <_ZN9TimeClass3dayEv>:
{
   b7c34:	b508      	push	{r3, lr}
	return day(now());
   b7c36:	f7ff ffe4 	bl	b7c02 <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   b7c3a:	17c1      	asrs	r1, r0, #31
   b7c3c:	f7ff ff2c 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
}
   b7c40:	4b01      	ldr	r3, [pc, #4]	; (b7c48 <_ZN9TimeClass3dayEv+0x14>)
   b7c42:	68d8      	ldr	r0, [r3, #12]
   b7c44:	bd08      	pop	{r3, pc}
   b7c46:	bf00      	nop
   b7c48:	2003e6c8 	.word	0x2003e6c8

000b7c4c <_ZN9TimeClass5monthEv>:
{
   b7c4c:	b508      	push	{r3, lr}
	return month(now());
   b7c4e:	f7ff ffd8 	bl	b7c02 <_ZN9TimeClass3nowEv>
}
   b7c52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return month(now());
   b7c56:	17c1      	asrs	r1, r0, #31
   b7c58:	f7ff bf8c 	b.w	b7b74 <_ZN9TimeClass5monthEx>

000b7c5c <_ZN9TimeClass4yearEv>:
{
   b7c5c:	b508      	push	{r3, lr}
	return year(now());
   b7c5e:	f7ff ffd0 	bl	b7c02 <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   b7c62:	17c1      	asrs	r1, r0, #31
   b7c64:	f7ff ff18 	bl	b7a98 <_ZL22Refresh_UnixTime_Cachex>
}
   b7c68:	4b01      	ldr	r3, [pc, #4]	; (b7c70 <_ZN9TimeClass4yearEv+0x14>)
   b7c6a:	6958      	ldr	r0, [r3, #20]
   b7c6c:	bd08      	pop	{r3, pc}
   b7c6e:	bf00      	nop
   b7c70:	2003e6c8 	.word	0x2003e6c8

000b7c74 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
   b7c74:	4b02      	ldr	r3, [pc, #8]	; (b7c80 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
   b7c76:	681a      	ldr	r2, [r3, #0]
   b7c78:	4b02      	ldr	r3, [pc, #8]	; (b7c84 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
   b7c7a:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
   b7c7c:	4770      	bx	lr
   b7c7e:	bf00      	nop
   b7c80:	2003de0c 	.word	0x2003de0c
   b7c84:	2003e6c4 	.word	0x2003e6c4

000b7c88 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, const hal_usart_buffer_config_t& config);
  virtual ~USARTSerial() {};
   b7c88:	4770      	bx	lr

000b7c8a <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   b7c8a:	7441      	strb	r1, [r0, #17]
}
   b7c8c:	4770      	bx	lr

000b7c8e <_ZN11USARTSerial17availableForWriteEv>:


int USARTSerial::availableForWrite(void)
{
   b7c8e:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
   b7c90:	7c00      	ldrb	r0, [r0, #16]
   b7c92:	f7fe fd45 	bl	b6720 <hal_usart_available_data_for_write>
}
   b7c96:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   b7c9a:	bd08      	pop	{r3, pc}

000b7c9c <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
   b7c9c:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
   b7c9e:	7c00      	ldrb	r0, [r0, #16]
   b7ca0:	f7fe fd16 	bl	b66d0 <hal_usart_available>
}
   b7ca4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   b7ca8:	bd08      	pop	{r3, pc}

000b7caa <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
   b7caa:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
   b7cac:	7c00      	ldrb	r0, [r0, #16]
   b7cae:	f7fe fd1f 	bl	b66f0 <hal_usart_peek>
}
   b7cb2:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   b7cb6:	bd08      	pop	{r3, pc}

000b7cb8 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
   b7cb8:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
   b7cba:	7c00      	ldrb	r0, [r0, #16]
   b7cbc:	f7fe fd10 	bl	b66e0 <hal_usart_read>
}
   b7cc0:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   b7cc4:	bd08      	pop	{r3, pc}

000b7cc6 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  hal_usart_flush(_serial);
   b7cc6:	7c00      	ldrb	r0, [r0, #16]
   b7cc8:	f7fe bd1a 	b.w	b6700 <hal_usart_flush>

000b7ccc <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
   b7ccc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   b7cce:	7c45      	ldrb	r5, [r0, #17]
{
   b7cd0:	4604      	mov	r4, r0
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   b7cd2:	b12d      	cbz	r5, b7ce0 <_ZN11USARTSerial5writeEh+0x14>
    // the HAL always blocks.
	  return hal_usart_write(_serial, c);
   b7cd4:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
   b7cd6:	b003      	add	sp, #12
   b7cd8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	  return hal_usart_write(_serial, c);
   b7cdc:	f7fe bcf0 	b.w	b66c0 <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   b7ce0:	7c00      	ldrb	r0, [r0, #16]
   b7ce2:	9101      	str	r1, [sp, #4]
   b7ce4:	f7fe fd1c 	bl	b6720 <hal_usart_available_data_for_write>
   b7ce8:	2800      	cmp	r0, #0
   b7cea:	9901      	ldr	r1, [sp, #4]
   b7cec:	dcf2      	bgt.n	b7cd4 <_ZN11USARTSerial5writeEh+0x8>
}
   b7cee:	4628      	mov	r0, r5
   b7cf0:	b003      	add	sp, #12
   b7cf2:	bd30      	pop	{r4, r5, pc}

000b7cf4 <_ZN11USARTSerialD0Ev>:
   b7cf4:	b510      	push	{r4, lr}
   b7cf6:	2114      	movs	r1, #20
   b7cf8:	4604      	mov	r4, r0
   b7cfa:	f7fc fe2c 	bl	b4956 <_ZdlPvj>
   b7cfe:	4620      	mov	r0, r4
   b7d00:	bd10      	pop	{r4, pc}
	...

000b7d04 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t>:
USARTSerial::USARTSerial(hal_usart_interface_t serial, const hal_usart_buffer_config_t& config)
   b7d04:	b510      	push	{r4, lr}
   b7d06:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   b7d0a:	4604      	mov	r4, r0
   b7d0c:	4608      	mov	r0, r1
   b7d0e:	4611      	mov	r1, r2
   b7d10:	2200      	movs	r2, #0
   b7d12:	e9c4 2301 	strd	r2, r3, [r4, #4]
   b7d16:	4b04      	ldr	r3, [pc, #16]	; (b7d28 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t+0x24>)
   b7d18:	6023      	str	r3, [r4, #0]
  _blocking = true;
   b7d1a:	2301      	movs	r3, #1
  _serial = serial;
   b7d1c:	7420      	strb	r0, [r4, #16]
  _blocking = true;
   b7d1e:	7463      	strb	r3, [r4, #17]
  hal_usart_init_ex(serial, &config, nullptr);
   b7d20:	f7fe fd06 	bl	b6730 <hal_usart_init_ex>
}
   b7d24:	4620      	mov	r0, r4
   b7d26:	bd10      	pop	{r4, pc}
   b7d28:	000bbeec 	.word	0x000bbeec

000b7d2c <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   b7d2c:	7441      	strb	r1, [r0, #17]
}
   b7d2e:	4770      	bx	lr

000b7d30 <__tcf_0>:
}

USBSerial& _fetch_usbserial()
{
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   b7d30:	4770      	bx	lr

000b7d32 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
   b7d32:	4770      	bx	lr

000b7d34 <_ZN9USBSerial4readEv>:
{
   b7d34:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
   b7d36:	2100      	movs	r1, #0
   b7d38:	7c00      	ldrb	r0, [r0, #16]
   b7d3a:	f7fe fd21 	bl	b6780 <HAL_USB_USART_Receive_Data>
}
   b7d3e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   b7d42:	bd08      	pop	{r3, pc}

000b7d44 <_ZN9USBSerial4peekEv>:
{
   b7d44:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
   b7d46:	2101      	movs	r1, #1
   b7d48:	7c00      	ldrb	r0, [r0, #16]
   b7d4a:	f7fe fd19 	bl	b6780 <HAL_USB_USART_Receive_Data>
}
   b7d4e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   b7d52:	bd08      	pop	{r3, pc}

000b7d54 <_ZN9USBSerial17availableForWriteEv>:
{
   b7d54:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
   b7d56:	7c00      	ldrb	r0, [r0, #16]
   b7d58:	f7fe fd0a 	bl	b6770 <HAL_USB_USART_Available_Data_For_Write>
}
   b7d5c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   b7d60:	bd08      	pop	{r3, pc}

000b7d62 <_ZN9USBSerial9availableEv>:
{
   b7d62:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
   b7d64:	7c00      	ldrb	r0, [r0, #16]
   b7d66:	f7fe fcfb 	bl	b6760 <HAL_USB_USART_Available_Data>
}
   b7d6a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   b7d6e:	bd08      	pop	{r3, pc}

000b7d70 <_ZN9USBSerial5writeEh>:
{
   b7d70:	b513      	push	{r0, r1, r4, lr}
   b7d72:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   b7d74:	7c00      	ldrb	r0, [r0, #16]
{
   b7d76:	9101      	str	r1, [sp, #4]
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   b7d78:	f7fe fcfa 	bl	b6770 <HAL_USB_USART_Available_Data_For_Write>
   b7d7c:	2800      	cmp	r0, #0
   b7d7e:	9901      	ldr	r1, [sp, #4]
   b7d80:	dc01      	bgt.n	b7d86 <_ZN9USBSerial5writeEh+0x16>
   b7d82:	7c60      	ldrb	r0, [r4, #17]
   b7d84:	b120      	cbz	r0, b7d90 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
   b7d86:	7c20      	ldrb	r0, [r4, #16]
   b7d88:	f7fe fd02 	bl	b6790 <HAL_USB_USART_Send_Data>
   b7d8c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
   b7d90:	b002      	add	sp, #8
   b7d92:	bd10      	pop	{r4, pc}

000b7d94 <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
   b7d94:	7c00      	ldrb	r0, [r0, #16]
   b7d96:	f7fe bd03 	b.w	b67a0 <HAL_USB_USART_Flush_Data>

000b7d9a <_ZN9USBSerialD0Ev>:
   b7d9a:	b510      	push	{r4, lr}
   b7d9c:	2114      	movs	r1, #20
   b7d9e:	4604      	mov	r4, r0
   b7da0:	f7fc fdd9 	bl	b4956 <_ZdlPvj>
   b7da4:	4620      	mov	r0, r4
   b7da6:	bd10      	pop	{r4, pc}

000b7da8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   b7da8:	b510      	push	{r4, lr}
   b7daa:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   b7dae:	4604      	mov	r4, r0
   b7db0:	4608      	mov	r0, r1
   b7db2:	2100      	movs	r1, #0
   b7db4:	e9c4 1301 	strd	r1, r3, [r4, #4]
   b7db8:	4b04      	ldr	r3, [pc, #16]	; (b7dcc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
   b7dba:	6023      	str	r3, [r4, #0]
  _blocking = true;
   b7dbc:	2301      	movs	r3, #1
  _serial = serial;
   b7dbe:	7420      	strb	r0, [r4, #16]
  _blocking = true;
   b7dc0:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
   b7dc2:	4611      	mov	r1, r2
   b7dc4:	f7fe fcbc 	bl	b6740 <HAL_USB_USART_Init>
}
   b7dc8:	4620      	mov	r0, r4
   b7dca:	bd10      	pop	{r4, pc}
   b7dcc:	000bbf1c 	.word	0x000bbf1c

000b7dd0 <_ZN9USBSerial5beginEl>:
    HAL_USB_USART_Begin(_serial, speed, NULL);
   b7dd0:	7c00      	ldrb	r0, [r0, #16]
   b7dd2:	2200      	movs	r2, #0
   b7dd4:	f7fe bcbc 	b.w	b6750 <HAL_USB_USART_Begin>

000b7dd8 <_Z19acquireSerialBufferv>:
{
   b7dd8:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = {};
   b7dda:	2214      	movs	r2, #20
{
   b7ddc:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {};
   b7dde:	2100      	movs	r1, #0
   b7de0:	f000 fa2d 	bl	b823e <memset>
}
   b7de4:	4620      	mov	r0, r4
   b7de6:	bd10      	pop	{r4, pc}

000b7de8 <_Z16_fetch_usbserialv>:
{
   b7de8:	b510      	push	{r4, lr}
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   b7dea:	4c0f      	ldr	r4, [pc, #60]	; (b7e28 <_Z16_fetch_usbserialv+0x40>)
{
   b7dec:	b088      	sub	sp, #32
  HAL_USB_USART_Config conf = acquireSerialBuffer();
   b7dee:	a803      	add	r0, sp, #12
   b7df0:	f7ff fff2 	bl	b7dd8 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   b7df4:	7821      	ldrb	r1, [r4, #0]
   b7df6:	f3bf 8f5b 	dmb	ish
   b7dfa:	f011 0101 	ands.w	r1, r1, #1
   b7dfe:	d10f      	bne.n	b7e20 <_Z16_fetch_usbserialv+0x38>
   b7e00:	4620      	mov	r0, r4
   b7e02:	9101      	str	r1, [sp, #4]
   b7e04:	f7fc fda9 	bl	b495a <__cxa_guard_acquire>
   b7e08:	9901      	ldr	r1, [sp, #4]
   b7e0a:	b148      	cbz	r0, b7e20 <_Z16_fetch_usbserialv+0x38>
   b7e0c:	aa03      	add	r2, sp, #12
   b7e0e:	4807      	ldr	r0, [pc, #28]	; (b7e2c <_Z16_fetch_usbserialv+0x44>)
   b7e10:	f7ff ffca 	bl	b7da8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
   b7e14:	4620      	mov	r0, r4
   b7e16:	f7fc fda5 	bl	b4964 <__cxa_guard_release>
   b7e1a:	4805      	ldr	r0, [pc, #20]	; (b7e30 <_Z16_fetch_usbserialv+0x48>)
   b7e1c:	f000 f9f7 	bl	b820e <atexit>
	return _usbserial;
}
   b7e20:	4802      	ldr	r0, [pc, #8]	; (b7e2c <_Z16_fetch_usbserialv+0x44>)
   b7e22:	b008      	add	sp, #32
   b7e24:	bd10      	pop	{r4, pc}
   b7e26:	bf00      	nop
   b7e28:	2003e708 	.word	0x2003e708
   b7e2c:	2003e70c 	.word	0x2003e70c
   b7e30:	000b7d31 	.word	0x000b7d31

000b7e34 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
   b7e34:	b510      	push	{r4, lr}
   b7e36:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
   b7e38:	f7fc fd46 	bl	b48c8 <strlen>
   b7e3c:	3801      	subs	r0, #1
   b7e3e:	1823      	adds	r3, r4, r0
   b7e40:	4620      	mov	r0, r4
	while(i<j){
   b7e42:	4283      	cmp	r3, r0
   b7e44:	d906      	bls.n	b7e54 <_Z11str_reversePc+0x20>
		c = *i;
   b7e46:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
   b7e48:	7819      	ldrb	r1, [r3, #0]
   b7e4a:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
   b7e4e:	f803 2901 	strb.w	r2, [r3], #-1
	while(i<j){
   b7e52:	e7f6      	b.n	b7e42 <_Z11str_reversePc+0xe>
		++i;
		--j;
	}
}
   b7e54:	bd10      	pop	{r4, pc}

000b7e56 <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
   b7e56:	b570      	push	{r4, r5, r6, lr}
   b7e58:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
   b7e5a:	1e91      	subs	r1, r2, #2
   b7e5c:	2922      	cmp	r1, #34	; 0x22
   b7e5e:	d81d      	bhi.n	b7e9c <ultoa+0x46>
		return NULL;
	}
	char* ptr=buffer;
   b7e60:	4625      	mov	r5, r4

	div_t result;
	while(a){
   b7e62:	b930      	cbnz	r0, b7e72 <ultoa+0x1c>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
   b7e64:	4423      	add	r3, r4
            *ptr++ = '0';
   b7e66:	2230      	movs	r2, #48	; 0x30
        while (ptr < buffer+pad)
   b7e68:	429d      	cmp	r5, r3
   b7e6a:	d210      	bcs.n	b7e8e <ultoa+0x38>
            *ptr++ = '0';
   b7e6c:	f805 2b01 	strb.w	r2, [r5], #1
        while (ptr < buffer+pad)
   b7e70:	e7fa      	b.n	b7e68 <ultoa+0x12>
            result.quot = a/radix;
   b7e72:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
   b7e76:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
   b7e7a:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
   b7e7c:	2809      	cmp	r0, #9
                *ptr += '0';
   b7e7e:	bf94      	ite	ls
   b7e80:	3130      	addls	r1, #48	; 0x30
                *ptr += 'a'-10;
   b7e82:	3157      	addhi	r1, #87	; 0x57
   b7e84:	b2c9      	uxtb	r1, r1
   b7e86:	f805 1b01 	strb.w	r1, [r5], #1
            a = result.quot;
   b7e8a:	4630      	mov	r0, r6
	while(a){
   b7e8c:	e7e9      	b.n	b7e62 <ultoa+0xc>

	*ptr = '\0';
   b7e8e:	2300      	movs	r3, #0
	str_reverse(buffer);
   b7e90:	4620      	mov	r0, r4
	*ptr = '\0';
   b7e92:	702b      	strb	r3, [r5, #0]
	str_reverse(buffer);
   b7e94:	f7ff ffce 	bl	b7e34 <_Z11str_reversePc>
	return buffer;
   b7e98:	4620      	mov	r0, r4
}
   b7e9a:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   b7e9c:	2000      	movs	r0, #0
   b7e9e:	e7fc      	b.n	b7e9a <ultoa+0x44>

000b7ea0 <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
   b7ea0:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
   b7ea2:	1e03      	subs	r3, r0, #0
__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
   b7ea4:	460c      	mov	r4, r1
   b7ea6:	4615      	mov	r5, r2
	if(a<0){
   b7ea8:	da0e      	bge.n	b7ec8 <itoa+0x28>
		*buffer = '-';
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
   b7eaa:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
		*buffer = '-';
   b7eae:	f04f 022d 	mov.w	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
   b7eb2:	bf14      	ite	ne
   b7eb4:	4258      	negne	r0, r3
   b7eb6:	4618      	moveq	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
   b7eb8:	2301      	movs	r3, #1
		*buffer = '-';
   b7eba:	700a      	strb	r2, [r1, #0]
		ultoa((unsigned)v, buffer + 1, radix);
   b7ebc:	462a      	mov	r2, r5
   b7ebe:	4419      	add	r1, r3
	}else{
		ultoa(a, buffer, radix);
   b7ec0:	f7ff ffc9 	bl	b7e56 <ultoa>
	}
	return buffer;
}
   b7ec4:	4620      	mov	r0, r4
   b7ec6:	bd38      	pop	{r3, r4, r5, pc}
		ultoa(a, buffer, radix);
   b7ec8:	2301      	movs	r3, #1
   b7eca:	e7f9      	b.n	b7ec0 <itoa+0x20>

000b7ecc <utoa>:

__attribute__((weak)) char* utoa(unsigned a, char* buffer, int radix) {
   b7ecc:	b508      	push	{r3, lr}
    return ultoa(a, buffer, radix);
   b7ece:	2301      	movs	r3, #1
   b7ed0:	f7ff ffc1 	bl	b7e56 <ultoa>
}
   b7ed4:	bd08      	pop	{r3, pc}
	...

000b7ed8 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
   b7ed8:	4b01      	ldr	r3, [pc, #4]	; (b7ee0 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
   b7eda:	6018      	str	r0, [r3, #0]
    }, nullptr);
   b7edc:	4770      	bx	lr
   b7ede:	bf00      	nop
   b7ee0:	2003de10 	.word	0x2003de10

000b7ee4 <serialEventRun>:
{
   b7ee4:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
   b7ee6:	4b0b      	ldr	r3, [pc, #44]	; (b7f14 <serialEventRun+0x30>)
   b7ee8:	b143      	cbz	r3, b7efc <serialEventRun+0x18>
   b7eea:	f7ff ff7d 	bl	b7de8 <_Z16_fetch_usbserialv>
   b7eee:	6803      	ldr	r3, [r0, #0]
   b7ef0:	691b      	ldr	r3, [r3, #16]
   b7ef2:	4798      	blx	r3
   b7ef4:	2800      	cmp	r0, #0
   b7ef6:	dd01      	ble.n	b7efc <serialEventRun+0x18>
        serialEvent();
   b7ef8:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
   b7efc:	4b06      	ldr	r3, [pc, #24]	; (b7f18 <serialEventRun+0x34>)
   b7efe:	b143      	cbz	r3, b7f12 <serialEventRun+0x2e>
   b7f00:	f000 f95c 	bl	b81bc <_Z22__fetch_global_Serial1v>
   b7f04:	6803      	ldr	r3, [r0, #0]
   b7f06:	691b      	ldr	r3, [r3, #16]
   b7f08:	4798      	blx	r3
   b7f0a:	2800      	cmp	r0, #0
   b7f0c:	dd01      	ble.n	b7f12 <serialEventRun+0x2e>
        serialEvent1();
   b7f0e:	f3af 8000 	nop.w
}
   b7f12:	bd08      	pop	{r3, pc}
	...

000b7f1c <_post_loop>:
{
   b7f1c:	b508      	push	{r3, lr}
	serialEventRun();
   b7f1e:	f7ff ffe1 	bl	b7ee4 <serialEventRun>
		return !thread || !thread->isRunning();
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   b7f22:	f7fe fae5 	bl	b64f0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   b7f26:	4b01      	ldr	r3, [pc, #4]	; (b7f2c <_post_loop+0x10>)
   b7f28:	6018      	str	r0, [r3, #0]
}
   b7f2a:	bd08      	pop	{r3, pc}
   b7f2c:	2003e728 	.word	0x2003e728

000b7f30 <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   b7f30:	4805      	ldr	r0, [pc, #20]	; (b7f48 <_Z33system_initialize_user_backup_ramv+0x18>)
   b7f32:	4a06      	ldr	r2, [pc, #24]	; (b7f4c <_Z33system_initialize_user_backup_ramv+0x1c>)
   b7f34:	4906      	ldr	r1, [pc, #24]	; (b7f50 <_Z33system_initialize_user_backup_ramv+0x20>)
{
   b7f36:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   b7f38:	1a12      	subs	r2, r2, r0
   b7f3a:	f000 f972 	bl	b8222 <memcpy>
    __backup_sram_signature = signature;
   b7f3e:	4b05      	ldr	r3, [pc, #20]	; (b7f54 <_Z33system_initialize_user_backup_ramv+0x24>)
   b7f40:	4a05      	ldr	r2, [pc, #20]	; (b7f58 <_Z33system_initialize_user_backup_ramv+0x28>)
   b7f42:	601a      	str	r2, [r3, #0]
}
   b7f44:	bd08      	pop	{r3, pc}
   b7f46:	bf00      	nop
   b7f48:	2003f400 	.word	0x2003f400
   b7f4c:	2003f404 	.word	0x2003f404
   b7f50:	000bc1f4 	.word	0x000bc1f4
   b7f54:	2003f400 	.word	0x2003f400
   b7f58:	9a271c1e 	.word	0x9a271c1e

000b7f5c <_Z27ctrl_request_custom_handlerP12ctrl_request>:
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
   b7f5c:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   b7f5e:	2300      	movs	r3, #0
   b7f60:	9300      	str	r3, [sp, #0]
   b7f62:	461a      	mov	r2, r3
   b7f64:	f06f 0177 	mvn.w	r1, #119	; 0x77
   b7f68:	f7fe fc5c 	bl	b6824 <system_ctrl_set_result>
}
   b7f6c:	b003      	add	sp, #12
   b7f6e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000b7f74 <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
   b7f74:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
   b7f76:	8843      	ldrh	r3, [r0, #2]
   b7f78:	2b0a      	cmp	r3, #10
   b7f7a:	d008      	beq.n	b7f8e <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
   b7f7c:	2b50      	cmp	r3, #80	; 0x50
   b7f7e:	d10b      	bne.n	b7f98 <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
   b7f80:	4b09      	ldr	r3, [pc, #36]	; (b7fa8 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
   b7f82:	681b      	ldr	r3, [r3, #0]
   b7f84:	b14b      	cbz	r3, b7f9a <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
   b7f86:	b003      	add	sp, #12
   b7f88:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
   b7f8c:	4718      	bx	r3
        ctrl_request_custom_handler(req);
   b7f8e:	f7ff ffe5 	bl	b7f5c <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
   b7f92:	b003      	add	sp, #12
   b7f94:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   b7f98:	2300      	movs	r3, #0
   b7f9a:	9300      	str	r3, [sp, #0]
   b7f9c:	461a      	mov	r2, r3
   b7f9e:	f06f 0177 	mvn.w	r1, #119	; 0x77
   b7fa2:	f7fe fc3f 	bl	b6824 <system_ctrl_set_result>
}
   b7fa6:	e7f4      	b.n	b7f92 <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
   b7fa8:	2003e724 	.word	0x2003e724

000b7fac <module_user_init_hook>:
{
   b7fac:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
   b7fae:	4812      	ldr	r0, [pc, #72]	; (b7ff8 <module_user_init_hook+0x4c>)
   b7fb0:	2100      	movs	r1, #0
   b7fb2:	f7fe fd31 	bl	b6a18 <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
   b7fb6:	4b11      	ldr	r3, [pc, #68]	; (b7ffc <module_user_init_hook+0x50>)
   b7fb8:	681a      	ldr	r2, [r3, #0]
   b7fba:	4b11      	ldr	r3, [pc, #68]	; (b8000 <module_user_init_hook+0x54>)
   b7fbc:	429a      	cmp	r2, r3
   b7fbe:	4b11      	ldr	r3, [pc, #68]	; (b8004 <module_user_init_hook+0x58>)
   b7fc0:	bf0c      	ite	eq
   b7fc2:	2201      	moveq	r2, #1
   b7fc4:	2200      	movne	r2, #0
   b7fc6:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
   b7fc8:	d001      	beq.n	b7fce <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
   b7fca:	f7ff ffb1 	bl	b7f30 <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
   b7fce:	f7fe fa87 	bl	b64e0 <HAL_RNG_GetRandomNumber>
   b7fd2:	4604      	mov	r4, r0
    srand(seed);
   b7fd4:	f000 f93c 	bl	b8250 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
   b7fd8:	4b0b      	ldr	r3, [pc, #44]	; (b8008 <module_user_init_hook+0x5c>)
   b7fda:	b113      	cbz	r3, b7fe2 <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
   b7fdc:	4620      	mov	r0, r4
   b7fde:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
   b7fe2:	2100      	movs	r1, #0
   b7fe4:	4808      	ldr	r0, [pc, #32]	; (b8008 <module_user_init_hook+0x5c>)
   b7fe6:	f7fe fc5f 	bl	b68a8 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
   b7fea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   b7fee:	4807      	ldr	r0, [pc, #28]	; (b800c <module_user_init_hook+0x60>)
   b7ff0:	2100      	movs	r1, #0
   b7ff2:	f7fe bc0d 	b.w	b6810 <system_ctrl_set_app_request_handler>
   b7ff6:	bf00      	nop
   b7ff8:	000b7ed9 	.word	0x000b7ed9
   b7ffc:	2003f400 	.word	0x2003f400
   b8000:	9a271c1e 	.word	0x9a271c1e
   b8004:	2003e720 	.word	0x2003e720
   b8008:	00000000 	.word	0x00000000
   b800c:	000b7f75 	.word	0x000b7f75

000b8010 <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
   b8010:	2825      	cmp	r0, #37	; 0x25
bool pinAvailable(uint16_t pin) {
   b8012:	b513      	push	{r0, r1, r4, lr}
  if (pin >= TOTAL_PINS) {
   b8014:	d902      	bls.n	b801c <pinAvailable+0xc>
    return false;
   b8016:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
   b8018:	b002      	add	sp, #8
   b801a:	bd10      	pop	{r4, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
   b801c:	f1a0 030b 	sub.w	r3, r0, #11
   b8020:	2b02      	cmp	r3, #2
   b8022:	d81a      	bhi.n	b805a <pinAvailable+0x4a>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   b8024:	4c17      	ldr	r4, [pc, #92]	; (b8084 <pinAvailable+0x74>)
   b8026:	7821      	ldrb	r1, [r4, #0]
   b8028:	f3bf 8f5b 	dmb	ish
   b802c:	f011 0101 	ands.w	r1, r1, #1
   b8030:	d10b      	bne.n	b804a <pinAvailable+0x3a>
   b8032:	4620      	mov	r0, r4
   b8034:	9101      	str	r1, [sp, #4]
   b8036:	f7fc fc90 	bl	b495a <__cxa_guard_acquire>
   b803a:	9901      	ldr	r1, [sp, #4]
   b803c:	b128      	cbz	r0, b804a <pinAvailable+0x3a>
   b803e:	4812      	ldr	r0, [pc, #72]	; (b8088 <pinAvailable+0x78>)
   b8040:	f7ff fafe 	bl	b7640 <_ZN8SPIClassC1E19hal_spi_interface_t>
   b8044:	4620      	mov	r0, r4
   b8046:	f7fc fc8d 	bl	b4964 <__cxa_guard_release>
   b804a:	4b0f      	ldr	r3, [pc, #60]	; (b8088 <pinAvailable+0x78>)
   b804c:	7818      	ldrb	r0, [r3, #0]
   b804e:	f7fe fb0f 	bl	b6670 <hal_spi_is_enabled>
   b8052:	2800      	cmp	r0, #0
   b8054:	d1df      	bne.n	b8016 <pinAvailable+0x6>
  return true; // 'pin' is available
   b8056:	2001      	movs	r0, #1
   b8058:	e7de      	b.n	b8018 <pinAvailable+0x8>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
   b805a:	2801      	cmp	r0, #1
   b805c:	d809      	bhi.n	b8072 <pinAvailable+0x62>
   b805e:	f000 f86d 	bl	b813c <_Z19__fetch_global_Wirev>
   b8062:	2100      	movs	r1, #0
   b8064:	7c00      	ldrb	r0, [r0, #16]
   b8066:	f7fe fabb 	bl	b65e0 <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
   b806a:	f080 0001 	eor.w	r0, r0, #1
   b806e:	b2c0      	uxtb	r0, r0
   b8070:	e7d2      	b.n	b8018 <pinAvailable+0x8>
   b8072:	3809      	subs	r0, #9
   b8074:	2801      	cmp	r0, #1
   b8076:	d8ee      	bhi.n	b8056 <pinAvailable+0x46>
   b8078:	f000 f8a0 	bl	b81bc <_Z22__fetch_global_Serial1v>
   b807c:	7c00      	ldrb	r0, [r0, #16]
   b807e:	f7fe fb47 	bl	b6710 <hal_usart_is_enabled>
   b8082:	e7f2      	b.n	b806a <pinAvailable+0x5a>
   b8084:	2003e650 	.word	0x2003e650
   b8088:	2003e654 	.word	0x2003e654

000b808c <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   b808c:	2825      	cmp	r0, #37	; 0x25
{
   b808e:	b538      	push	{r3, r4, r5, lr}
   b8090:	4604      	mov	r4, r0
   b8092:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   b8094:	d80a      	bhi.n	b80ac <pinMode+0x20>
   b8096:	29ff      	cmp	r1, #255	; 0xff
   b8098:	d008      	beq.n	b80ac <pinMode+0x20>
  if( !pinAvailable(pin) ) {
   b809a:	f7ff ffb9 	bl	b8010 <pinAvailable>
   b809e:	b128      	cbz	r0, b80ac <pinMode+0x20>
  hal_gpio_mode(pin, setMode);
   b80a0:	4629      	mov	r1, r5
   b80a2:	4620      	mov	r0, r4
}
   b80a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  hal_gpio_mode(pin, setMode);
   b80a8:	f7fe ba3a 	b.w	b6520 <hal_gpio_mode>
}
   b80ac:	bd38      	pop	{r3, r4, r5, pc}

000b80ae <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(hal_pin_t pin, uint8_t value)
{
   b80ae:	b538      	push	{r3, r4, r5, lr}
   b80b0:	4604      	mov	r4, r0
   b80b2:	460d      	mov	r5, r1
    PinMode mode = hal_gpio_get_mode(pin);
   b80b4:	f7fe fa3c 	bl	b6530 <hal_gpio_get_mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
   b80b8:	28ff      	cmp	r0, #255	; 0xff
   b80ba:	d010      	beq.n	b80de <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
   b80bc:	2806      	cmp	r0, #6
   b80be:	d804      	bhi.n	b80ca <digitalWrite+0x1c>
   b80c0:	234d      	movs	r3, #77	; 0x4d
   b80c2:	fa23 f000 	lsr.w	r0, r3, r0
   b80c6:	07c3      	lsls	r3, r0, #31
   b80c8:	d409      	bmi.n	b80de <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
   b80ca:	4620      	mov	r0, r4
   b80cc:	f7ff ffa0 	bl	b8010 <pinAvailable>
   b80d0:	b128      	cbz	r0, b80de <digitalWrite+0x30>
    return;
  }

  hal_gpio_write(pin, value);
   b80d2:	4629      	mov	r1, r5
   b80d4:	4620      	mov	r0, r4
}
   b80d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  hal_gpio_write(pin, value);
   b80da:	f7fe ba31 	b.w	b6540 <hal_gpio_write>
}
   b80de:	bd38      	pop	{r3, r4, r5, pc}

000b80e0 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(hal_pin_t pin)
{
   b80e0:	b510      	push	{r4, lr}
   b80e2:	4604      	mov	r4, r0
    PinMode mode = hal_gpio_get_mode(pin);
   b80e4:	f7fe fa24 	bl	b6530 <hal_gpio_get_mode>
    return mode == AF_OUTPUT_PUSHPULL ||
   b80e8:	1f03      	subs	r3, r0, #4
    if (is_af_output_mode(mode))
   b80ea:	b2db      	uxtb	r3, r3
   b80ec:	2b01      	cmp	r3, #1
   b80ee:	d908      	bls.n	b8102 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
   b80f0:	4620      	mov	r0, r4
   b80f2:	f7ff ff8d 	bl	b8010 <pinAvailable>
   b80f6:	b120      	cbz	r0, b8102 <digitalRead+0x22>
      return LOW;
    }

    return hal_gpio_read(pin);
   b80f8:	4620      	mov	r0, r4
}
   b80fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return hal_gpio_read(pin);
   b80fe:	f7fe ba27 	b.w	b6550 <hal_gpio_read>
}
   b8102:	2000      	movs	r0, #0
   b8104:	bd10      	pop	{r4, pc}

000b8106 <__tcf_0>:
}
#endif

TwoWire& __fetch_global_Wire()
{
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   b8106:	4770      	bx	lr

000b8108 <_Z17acquireWireBufferv>:
{
   b8108:	b538      	push	{r3, r4, r5, lr}
	hal_i2c_config_t config = {
   b810a:	4b0a      	ldr	r3, [pc, #40]	; (b8134 <_Z17acquireWireBufferv+0x2c>)
   b810c:	6003      	str	r3, [r0, #0]
   b810e:	2301      	movs	r3, #1
{
   b8110:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
   b8112:	6143      	str	r3, [r0, #20]
		.rx_buffer = new (std::nothrow) uint8_t[i2c_buffer_size],
   b8114:	4908      	ldr	r1, [pc, #32]	; (b8138 <_Z17acquireWireBufferv+0x30>)
   b8116:	2020      	movs	r0, #32
   b8118:	f000 f874 	bl	b8204 <_ZnajRKSt9nothrow_t>
	};
   b811c:	2520      	movs	r5, #32
   b811e:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[i2c_buffer_size],
   b8120:	4905      	ldr	r1, [pc, #20]	; (b8138 <_Z17acquireWireBufferv+0x30>)
	};
   b8122:	60a5      	str	r5, [r4, #8]
		.tx_buffer = new (std::nothrow) uint8_t[i2c_buffer_size],
   b8124:	4628      	mov	r0, r5
   b8126:	f000 f86d 	bl	b8204 <_ZnajRKSt9nothrow_t>
	};
   b812a:	e9c4 0503 	strd	r0, r5, [r4, #12]
}
   b812e:	4620      	mov	r0, r4
   b8130:	bd38      	pop	{r3, r4, r5, pc}
   b8132:	bf00      	nop
   b8134:	00010018 	.word	0x00010018
   b8138:	000bbf44 	.word	0x000bbf44

000b813c <_Z19__fetch_global_Wirev>:
{
   b813c:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   b813e:	4d0e      	ldr	r5, [pc, #56]	; (b8178 <_Z19__fetch_global_Wirev+0x3c>)
   b8140:	7829      	ldrb	r1, [r5, #0]
   b8142:	f3bf 8f5b 	dmb	ish
   b8146:	f011 0401 	ands.w	r4, r1, #1
{
   b814a:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   b814c:	d111      	bne.n	b8172 <_Z19__fetch_global_Wirev+0x36>
   b814e:	4628      	mov	r0, r5
   b8150:	f7fc fc03 	bl	b495a <__cxa_guard_acquire>
   b8154:	b168      	cbz	r0, b8172 <_Z19__fetch_global_Wirev+0x36>
   b8156:	4668      	mov	r0, sp
   b8158:	f7ff ffd6 	bl	b8108 <_Z17acquireWireBufferv>
   b815c:	466a      	mov	r2, sp
   b815e:	4621      	mov	r1, r4
   b8160:	4806      	ldr	r0, [pc, #24]	; (b817c <_Z19__fetch_global_Wirev+0x40>)
   b8162:	f7ff f83d 	bl	b71e0 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
   b8166:	4628      	mov	r0, r5
   b8168:	f7fc fbfc 	bl	b4964 <__cxa_guard_release>
   b816c:	4804      	ldr	r0, [pc, #16]	; (b8180 <_Z19__fetch_global_Wirev+0x44>)
   b816e:	f000 f84e 	bl	b820e <atexit>
	return wire;
}
   b8172:	4802      	ldr	r0, [pc, #8]	; (b817c <_Z19__fetch_global_Wirev+0x40>)
   b8174:	b007      	add	sp, #28
   b8176:	bd30      	pop	{r4, r5, pc}
   b8178:	2003e72c 	.word	0x2003e72c
   b817c:	2003e730 	.word	0x2003e730
   b8180:	000b8107 	.word	0x000b8107

000b8184 <__tcf_0>:
}
#endif

USARTSerial& __fetch_global_Serial1()
{
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   b8184:	4770      	bx	lr
	...

000b8188 <_Z20acquireSerial1Bufferv>:
{
   b8188:	b538      	push	{r3, r4, r5, lr}
   b818a:	4604      	mov	r4, r0
    hal_usart_buffer_config_t config = {
   b818c:	2514      	movs	r5, #20
   b818e:	462a      	mov	r2, r5
   b8190:	2100      	movs	r1, #0
   b8192:	f000 f854 	bl	b823e <memset>
   b8196:	8025      	strh	r5, [r4, #0]
   b8198:	2540      	movs	r5, #64	; 0x40
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   b819a:	4907      	ldr	r1, [pc, #28]	; (b81b8 <_Z20acquireSerial1Bufferv+0x30>)
    hal_usart_buffer_config_t config = {
   b819c:	8125      	strh	r5, [r4, #8]
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   b819e:	4628      	mov	r0, r5
    hal_usart_buffer_config_t config = {
   b81a0:	8225      	strh	r5, [r4, #16]
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   b81a2:	f000 f82f 	bl	b8204 <_ZnajRKSt9nothrow_t>
        .tx_buffer = new (std::nothrow) uint8_t[bufferSize],
   b81a6:	4904      	ldr	r1, [pc, #16]	; (b81b8 <_Z20acquireSerial1Bufferv+0x30>)
    };
   b81a8:	6060      	str	r0, [r4, #4]
        .tx_buffer = new (std::nothrow) uint8_t[bufferSize],
   b81aa:	4628      	mov	r0, r5
   b81ac:	f000 f82a 	bl	b8204 <_ZnajRKSt9nothrow_t>
    };
   b81b0:	60e0      	str	r0, [r4, #12]
}
   b81b2:	4620      	mov	r0, r4
   b81b4:	bd38      	pop	{r3, r4, r5, pc}
   b81b6:	bf00      	nop
   b81b8:	000bbf44 	.word	0x000bbf44

000b81bc <_Z22__fetch_global_Serial1v>:
{
   b81bc:	b530      	push	{r4, r5, lr}
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   b81be:	4d0e      	ldr	r5, [pc, #56]	; (b81f8 <_Z22__fetch_global_Serial1v+0x3c>)
   b81c0:	7829      	ldrb	r1, [r5, #0]
   b81c2:	f3bf 8f5b 	dmb	ish
   b81c6:	f011 0401 	ands.w	r4, r1, #1
{
   b81ca:	b087      	sub	sp, #28
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   b81cc:	d111      	bne.n	b81f2 <_Z22__fetch_global_Serial1v+0x36>
   b81ce:	4628      	mov	r0, r5
   b81d0:	f7fc fbc3 	bl	b495a <__cxa_guard_acquire>
   b81d4:	b168      	cbz	r0, b81f2 <_Z22__fetch_global_Serial1v+0x36>
   b81d6:	a801      	add	r0, sp, #4
   b81d8:	f7ff ffd6 	bl	b8188 <_Z20acquireSerial1Bufferv>
   b81dc:	aa01      	add	r2, sp, #4
   b81de:	4621      	mov	r1, r4
   b81e0:	4806      	ldr	r0, [pc, #24]	; (b81fc <_Z22__fetch_global_Serial1v+0x40>)
   b81e2:	f7ff fd8f 	bl	b7d04 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t>
   b81e6:	4628      	mov	r0, r5
   b81e8:	f7fc fbbc 	bl	b4964 <__cxa_guard_release>
   b81ec:	4804      	ldr	r0, [pc, #16]	; (b8200 <_Z22__fetch_global_Serial1v+0x44>)
   b81ee:	f000 f80e 	bl	b820e <atexit>
    return serial1;
}
   b81f2:	4802      	ldr	r0, [pc, #8]	; (b81fc <_Z22__fetch_global_Serial1v+0x40>)
   b81f4:	b007      	add	sp, #28
   b81f6:	bd30      	pop	{r4, r5, pc}
   b81f8:	2003e744 	.word	0x2003e744
   b81fc:	2003e748 	.word	0x2003e748
   b8200:	000b8185 	.word	0x000b8185

000b8204 <_ZnajRKSt9nothrow_t>:
   b8204:	f7fc bba5 	b.w	b4952 <_Znaj>

000b8208 <_ZSt25__throw_bad_function_callv>:
   b8208:	b508      	push	{r3, lr}
   b820a:	f7fe fbe5 	bl	b69d8 <abort>

000b820e <atexit>:
   b820e:	2300      	movs	r3, #0
   b8210:	4601      	mov	r1, r0
   b8212:	461a      	mov	r2, r3
   b8214:	4618      	mov	r0, r3
   b8216:	f000 b96b 	b.w	b84f0 <__register_exitproc>

000b821a <atoi>:
   b821a:	220a      	movs	r2, #10
   b821c:	2100      	movs	r1, #0
   b821e:	f000 b95d 	b.w	b84dc <strtol>

000b8222 <memcpy>:
   b8222:	440a      	add	r2, r1
   b8224:	4291      	cmp	r1, r2
   b8226:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   b822a:	d100      	bne.n	b822e <memcpy+0xc>
   b822c:	4770      	bx	lr
   b822e:	b510      	push	{r4, lr}
   b8230:	f811 4b01 	ldrb.w	r4, [r1], #1
   b8234:	f803 4f01 	strb.w	r4, [r3, #1]!
   b8238:	4291      	cmp	r1, r2
   b823a:	d1f9      	bne.n	b8230 <memcpy+0xe>
   b823c:	bd10      	pop	{r4, pc}

000b823e <memset>:
   b823e:	4402      	add	r2, r0
   b8240:	4603      	mov	r3, r0
   b8242:	4293      	cmp	r3, r2
   b8244:	d100      	bne.n	b8248 <memset+0xa>
   b8246:	4770      	bx	lr
   b8248:	f803 1b01 	strb.w	r1, [r3], #1
   b824c:	e7f9      	b.n	b8242 <memset+0x4>
	...

000b8250 <srand>:
   b8250:	b538      	push	{r3, r4, r5, lr}
   b8252:	4b10      	ldr	r3, [pc, #64]	; (b8294 <srand+0x44>)
   b8254:	681d      	ldr	r5, [r3, #0]
   b8256:	6bab      	ldr	r3, [r5, #56]	; 0x38
   b8258:	4604      	mov	r4, r0
   b825a:	b9b3      	cbnz	r3, b828a <srand+0x3a>
   b825c:	2018      	movs	r0, #24
   b825e:	f7fe fb93 	bl	b6988 <malloc>
   b8262:	4602      	mov	r2, r0
   b8264:	63a8      	str	r0, [r5, #56]	; 0x38
   b8266:	b920      	cbnz	r0, b8272 <srand+0x22>
   b8268:	4b0b      	ldr	r3, [pc, #44]	; (b8298 <srand+0x48>)
   b826a:	480c      	ldr	r0, [pc, #48]	; (b829c <srand+0x4c>)
   b826c:	2142      	movs	r1, #66	; 0x42
   b826e:	f7fe fbcb 	bl	b6a08 <__assert_func>
   b8272:	490b      	ldr	r1, [pc, #44]	; (b82a0 <srand+0x50>)
   b8274:	4b0b      	ldr	r3, [pc, #44]	; (b82a4 <srand+0x54>)
   b8276:	e9c0 1300 	strd	r1, r3, [r0]
   b827a:	4b0b      	ldr	r3, [pc, #44]	; (b82a8 <srand+0x58>)
   b827c:	6083      	str	r3, [r0, #8]
   b827e:	230b      	movs	r3, #11
   b8280:	8183      	strh	r3, [r0, #12]
   b8282:	2100      	movs	r1, #0
   b8284:	2001      	movs	r0, #1
   b8286:	e9c2 0104 	strd	r0, r1, [r2, #16]
   b828a:	6bab      	ldr	r3, [r5, #56]	; 0x38
   b828c:	2200      	movs	r2, #0
   b828e:	611c      	str	r4, [r3, #16]
   b8290:	615a      	str	r2, [r3, #20]
   b8292:	bd38      	pop	{r3, r4, r5, pc}
   b8294:	2003de10 	.word	0x2003de10
   b8298:	000bbf45 	.word	0x000bbf45
   b829c:	000bbf5c 	.word	0x000bbf5c
   b82a0:	abcd330e 	.word	0xabcd330e
   b82a4:	e66d1234 	.word	0xe66d1234
   b82a8:	0005deec 	.word	0x0005deec

000b82ac <strcpy>:
   b82ac:	4603      	mov	r3, r0
   b82ae:	f811 2b01 	ldrb.w	r2, [r1], #1
   b82b2:	f803 2b01 	strb.w	r2, [r3], #1
   b82b6:	2a00      	cmp	r2, #0
   b82b8:	d1f9      	bne.n	b82ae <strcpy+0x2>
   b82ba:	4770      	bx	lr

000b82bc <strdup>:
   b82bc:	4b02      	ldr	r3, [pc, #8]	; (b82c8 <strdup+0xc>)
   b82be:	4601      	mov	r1, r0
   b82c0:	6818      	ldr	r0, [r3, #0]
   b82c2:	f000 b803 	b.w	b82cc <_strdup_r>
   b82c6:	bf00      	nop
   b82c8:	2003de10 	.word	0x2003de10

000b82cc <_strdup_r>:
   b82cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b82ce:	4604      	mov	r4, r0
   b82d0:	4608      	mov	r0, r1
   b82d2:	460d      	mov	r5, r1
   b82d4:	f7fc faf8 	bl	b48c8 <strlen>
   b82d8:	1c42      	adds	r2, r0, #1
   b82da:	4611      	mov	r1, r2
   b82dc:	4620      	mov	r0, r4
   b82de:	9201      	str	r2, [sp, #4]
   b82e0:	f7fe fb82 	bl	b69e8 <_malloc_r>
   b82e4:	4604      	mov	r4, r0
   b82e6:	b118      	cbz	r0, b82f0 <_strdup_r+0x24>
   b82e8:	9a01      	ldr	r2, [sp, #4]
   b82ea:	4629      	mov	r1, r5
   b82ec:	f7ff ff99 	bl	b8222 <memcpy>
   b82f0:	4620      	mov	r0, r4
   b82f2:	b003      	add	sp, #12
   b82f4:	bd30      	pop	{r4, r5, pc}

000b82f6 <strncmp>:
   b82f6:	b510      	push	{r4, lr}
   b82f8:	b17a      	cbz	r2, b831a <strncmp+0x24>
   b82fa:	4603      	mov	r3, r0
   b82fc:	3901      	subs	r1, #1
   b82fe:	1884      	adds	r4, r0, r2
   b8300:	f813 0b01 	ldrb.w	r0, [r3], #1
   b8304:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   b8308:	4290      	cmp	r0, r2
   b830a:	d101      	bne.n	b8310 <strncmp+0x1a>
   b830c:	42a3      	cmp	r3, r4
   b830e:	d101      	bne.n	b8314 <strncmp+0x1e>
   b8310:	1a80      	subs	r0, r0, r2
   b8312:	bd10      	pop	{r4, pc}
   b8314:	2800      	cmp	r0, #0
   b8316:	d1f3      	bne.n	b8300 <strncmp+0xa>
   b8318:	e7fa      	b.n	b8310 <strncmp+0x1a>
   b831a:	4610      	mov	r0, r2
   b831c:	e7f9      	b.n	b8312 <strncmp+0x1c>
	...

000b8320 <strtok>:
   b8320:	4b16      	ldr	r3, [pc, #88]	; (b837c <strtok+0x5c>)
   b8322:	b573      	push	{r0, r1, r4, r5, r6, lr}
   b8324:	681e      	ldr	r6, [r3, #0]
   b8326:	6db4      	ldr	r4, [r6, #88]	; 0x58
   b8328:	4605      	mov	r5, r0
   b832a:	b9fc      	cbnz	r4, b836c <strtok+0x4c>
   b832c:	2050      	movs	r0, #80	; 0x50
   b832e:	9101      	str	r1, [sp, #4]
   b8330:	f7fe fb2a 	bl	b6988 <malloc>
   b8334:	9901      	ldr	r1, [sp, #4]
   b8336:	65b0      	str	r0, [r6, #88]	; 0x58
   b8338:	4602      	mov	r2, r0
   b833a:	b920      	cbnz	r0, b8346 <strtok+0x26>
   b833c:	4b10      	ldr	r3, [pc, #64]	; (b8380 <strtok+0x60>)
   b833e:	4811      	ldr	r0, [pc, #68]	; (b8384 <strtok+0x64>)
   b8340:	2157      	movs	r1, #87	; 0x57
   b8342:	f7fe fb61 	bl	b6a08 <__assert_func>
   b8346:	e9c0 4400 	strd	r4, r4, [r0]
   b834a:	e9c0 4402 	strd	r4, r4, [r0, #8]
   b834e:	e9c0 4404 	strd	r4, r4, [r0, #16]
   b8352:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
   b8356:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
   b835a:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
   b835e:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
   b8362:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
   b8366:	6184      	str	r4, [r0, #24]
   b8368:	7704      	strb	r4, [r0, #28]
   b836a:	6244      	str	r4, [r0, #36]	; 0x24
   b836c:	6db2      	ldr	r2, [r6, #88]	; 0x58
   b836e:	2301      	movs	r3, #1
   b8370:	4628      	mov	r0, r5
   b8372:	b002      	add	sp, #8
   b8374:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   b8378:	f000 b806 	b.w	b8388 <__strtok_r>
   b837c:	2003de10 	.word	0x2003de10
   b8380:	000bbf45 	.word	0x000bbf45
   b8384:	000bbfb5 	.word	0x000bbfb5

000b8388 <__strtok_r>:
   b8388:	b5f0      	push	{r4, r5, r6, r7, lr}
   b838a:	b908      	cbnz	r0, b8390 <__strtok_r+0x8>
   b838c:	6810      	ldr	r0, [r2, #0]
   b838e:	b188      	cbz	r0, b83b4 <__strtok_r+0x2c>
   b8390:	4604      	mov	r4, r0
   b8392:	4620      	mov	r0, r4
   b8394:	f814 5b01 	ldrb.w	r5, [r4], #1
   b8398:	460f      	mov	r7, r1
   b839a:	f817 6b01 	ldrb.w	r6, [r7], #1
   b839e:	b91e      	cbnz	r6, b83a8 <__strtok_r+0x20>
   b83a0:	b965      	cbnz	r5, b83bc <__strtok_r+0x34>
   b83a2:	6015      	str	r5, [r2, #0]
   b83a4:	4628      	mov	r0, r5
   b83a6:	e005      	b.n	b83b4 <__strtok_r+0x2c>
   b83a8:	42b5      	cmp	r5, r6
   b83aa:	d1f6      	bne.n	b839a <__strtok_r+0x12>
   b83ac:	2b00      	cmp	r3, #0
   b83ae:	d1f0      	bne.n	b8392 <__strtok_r+0xa>
   b83b0:	6014      	str	r4, [r2, #0]
   b83b2:	7003      	strb	r3, [r0, #0]
   b83b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   b83b6:	461c      	mov	r4, r3
   b83b8:	e00c      	b.n	b83d4 <__strtok_r+0x4c>
   b83ba:	b915      	cbnz	r5, b83c2 <__strtok_r+0x3a>
   b83bc:	f814 3b01 	ldrb.w	r3, [r4], #1
   b83c0:	460e      	mov	r6, r1
   b83c2:	f816 5b01 	ldrb.w	r5, [r6], #1
   b83c6:	42ab      	cmp	r3, r5
   b83c8:	d1f7      	bne.n	b83ba <__strtok_r+0x32>
   b83ca:	2b00      	cmp	r3, #0
   b83cc:	d0f3      	beq.n	b83b6 <__strtok_r+0x2e>
   b83ce:	2300      	movs	r3, #0
   b83d0:	f804 3c01 	strb.w	r3, [r4, #-1]
   b83d4:	6014      	str	r4, [r2, #0]
   b83d6:	e7ed      	b.n	b83b4 <__strtok_r+0x2c>

000b83d8 <_strtol_l.constprop.0>:
   b83d8:	2b01      	cmp	r3, #1
   b83da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   b83de:	d001      	beq.n	b83e4 <_strtol_l.constprop.0+0xc>
   b83e0:	2b24      	cmp	r3, #36	; 0x24
   b83e2:	d906      	bls.n	b83f2 <_strtol_l.constprop.0+0x1a>
   b83e4:	f7fe fb08 	bl	b69f8 <__errno>
   b83e8:	2316      	movs	r3, #22
   b83ea:	6003      	str	r3, [r0, #0]
   b83ec:	2000      	movs	r0, #0
   b83ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   b83f2:	f8df c0e4 	ldr.w	ip, [pc, #228]	; b84d8 <_strtol_l.constprop.0+0x100>
   b83f6:	460d      	mov	r5, r1
   b83f8:	462e      	mov	r6, r5
   b83fa:	f815 4b01 	ldrb.w	r4, [r5], #1
   b83fe:	f814 700c 	ldrb.w	r7, [r4, ip]
   b8402:	f017 0708 	ands.w	r7, r7, #8
   b8406:	d1f7      	bne.n	b83f8 <_strtol_l.constprop.0+0x20>
   b8408:	2c2d      	cmp	r4, #45	; 0x2d
   b840a:	d132      	bne.n	b8472 <_strtol_l.constprop.0+0x9a>
   b840c:	782c      	ldrb	r4, [r5, #0]
   b840e:	2701      	movs	r7, #1
   b8410:	1cb5      	adds	r5, r6, #2
   b8412:	2b00      	cmp	r3, #0
   b8414:	d05b      	beq.n	b84ce <_strtol_l.constprop.0+0xf6>
   b8416:	2b10      	cmp	r3, #16
   b8418:	d109      	bne.n	b842e <_strtol_l.constprop.0+0x56>
   b841a:	2c30      	cmp	r4, #48	; 0x30
   b841c:	d107      	bne.n	b842e <_strtol_l.constprop.0+0x56>
   b841e:	782c      	ldrb	r4, [r5, #0]
   b8420:	f004 04df 	and.w	r4, r4, #223	; 0xdf
   b8424:	2c58      	cmp	r4, #88	; 0x58
   b8426:	d14d      	bne.n	b84c4 <_strtol_l.constprop.0+0xec>
   b8428:	786c      	ldrb	r4, [r5, #1]
   b842a:	2310      	movs	r3, #16
   b842c:	3502      	adds	r5, #2
   b842e:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
   b8432:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   b8436:	f04f 0c00 	mov.w	ip, #0
   b843a:	fbb8 f9f3 	udiv	r9, r8, r3
   b843e:	4666      	mov	r6, ip
   b8440:	fb03 8a19 	mls	sl, r3, r9, r8
   b8444:	f1a4 0e30 	sub.w	lr, r4, #48	; 0x30
   b8448:	f1be 0f09 	cmp.w	lr, #9
   b844c:	d816      	bhi.n	b847c <_strtol_l.constprop.0+0xa4>
   b844e:	4674      	mov	r4, lr
   b8450:	42a3      	cmp	r3, r4
   b8452:	dd24      	ble.n	b849e <_strtol_l.constprop.0+0xc6>
   b8454:	f1bc 0f00 	cmp.w	ip, #0
   b8458:	db1e      	blt.n	b8498 <_strtol_l.constprop.0+0xc0>
   b845a:	45b1      	cmp	r9, r6
   b845c:	d31c      	bcc.n	b8498 <_strtol_l.constprop.0+0xc0>
   b845e:	d101      	bne.n	b8464 <_strtol_l.constprop.0+0x8c>
   b8460:	45a2      	cmp	sl, r4
   b8462:	db19      	blt.n	b8498 <_strtol_l.constprop.0+0xc0>
   b8464:	fb06 4603 	mla	r6, r6, r3, r4
   b8468:	f04f 0c01 	mov.w	ip, #1
   b846c:	f815 4b01 	ldrb.w	r4, [r5], #1
   b8470:	e7e8      	b.n	b8444 <_strtol_l.constprop.0+0x6c>
   b8472:	2c2b      	cmp	r4, #43	; 0x2b
   b8474:	bf04      	itt	eq
   b8476:	782c      	ldrbeq	r4, [r5, #0]
   b8478:	1cb5      	addeq	r5, r6, #2
   b847a:	e7ca      	b.n	b8412 <_strtol_l.constprop.0+0x3a>
   b847c:	f1a4 0e41 	sub.w	lr, r4, #65	; 0x41
   b8480:	f1be 0f19 	cmp.w	lr, #25
   b8484:	d801      	bhi.n	b848a <_strtol_l.constprop.0+0xb2>
   b8486:	3c37      	subs	r4, #55	; 0x37
   b8488:	e7e2      	b.n	b8450 <_strtol_l.constprop.0+0x78>
   b848a:	f1a4 0e61 	sub.w	lr, r4, #97	; 0x61
   b848e:	f1be 0f19 	cmp.w	lr, #25
   b8492:	d804      	bhi.n	b849e <_strtol_l.constprop.0+0xc6>
   b8494:	3c57      	subs	r4, #87	; 0x57
   b8496:	e7db      	b.n	b8450 <_strtol_l.constprop.0+0x78>
   b8498:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   b849c:	e7e6      	b.n	b846c <_strtol_l.constprop.0+0x94>
   b849e:	f1bc 0f00 	cmp.w	ip, #0
   b84a2:	da05      	bge.n	b84b0 <_strtol_l.constprop.0+0xd8>
   b84a4:	2322      	movs	r3, #34	; 0x22
   b84a6:	6003      	str	r3, [r0, #0]
   b84a8:	4646      	mov	r6, r8
   b84aa:	b942      	cbnz	r2, b84be <_strtol_l.constprop.0+0xe6>
   b84ac:	4630      	mov	r0, r6
   b84ae:	e79e      	b.n	b83ee <_strtol_l.constprop.0+0x16>
   b84b0:	b107      	cbz	r7, b84b4 <_strtol_l.constprop.0+0xdc>
   b84b2:	4276      	negs	r6, r6
   b84b4:	2a00      	cmp	r2, #0
   b84b6:	d0f9      	beq.n	b84ac <_strtol_l.constprop.0+0xd4>
   b84b8:	f1bc 0f00 	cmp.w	ip, #0
   b84bc:	d000      	beq.n	b84c0 <_strtol_l.constprop.0+0xe8>
   b84be:	1e69      	subs	r1, r5, #1
   b84c0:	6011      	str	r1, [r2, #0]
   b84c2:	e7f3      	b.n	b84ac <_strtol_l.constprop.0+0xd4>
   b84c4:	2430      	movs	r4, #48	; 0x30
   b84c6:	2b00      	cmp	r3, #0
   b84c8:	d1b1      	bne.n	b842e <_strtol_l.constprop.0+0x56>
   b84ca:	2308      	movs	r3, #8
   b84cc:	e7af      	b.n	b842e <_strtol_l.constprop.0+0x56>
   b84ce:	2c30      	cmp	r4, #48	; 0x30
   b84d0:	d0a5      	beq.n	b841e <_strtol_l.constprop.0+0x46>
   b84d2:	230a      	movs	r3, #10
   b84d4:	e7ab      	b.n	b842e <_strtol_l.constprop.0+0x56>
   b84d6:	bf00      	nop
   b84d8:	000bc011 	.word	0x000bc011

000b84dc <strtol>:
   b84dc:	4613      	mov	r3, r2
   b84de:	460a      	mov	r2, r1
   b84e0:	4601      	mov	r1, r0
   b84e2:	4802      	ldr	r0, [pc, #8]	; (b84ec <strtol+0x10>)
   b84e4:	6800      	ldr	r0, [r0, #0]
   b84e6:	f7ff bf77 	b.w	b83d8 <_strtol_l.constprop.0>
   b84ea:	bf00      	nop
   b84ec:	2003de10 	.word	0x2003de10

000b84f0 <__register_exitproc>:
   b84f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   b84f4:	f8df 80b8 	ldr.w	r8, [pc, #184]	; b85b0 <__register_exitproc+0xc0>
   b84f8:	4606      	mov	r6, r0
   b84fa:	f8d8 0000 	ldr.w	r0, [r8]
   b84fe:	461f      	mov	r7, r3
   b8500:	460d      	mov	r5, r1
   b8502:	4691      	mov	r9, r2
   b8504:	f000 f856 	bl	b85b4 <__retarget_lock_acquire_recursive>
   b8508:	4b25      	ldr	r3, [pc, #148]	; (b85a0 <__register_exitproc+0xb0>)
   b850a:	681c      	ldr	r4, [r3, #0]
   b850c:	b934      	cbnz	r4, b851c <__register_exitproc+0x2c>
   b850e:	4c25      	ldr	r4, [pc, #148]	; (b85a4 <__register_exitproc+0xb4>)
   b8510:	601c      	str	r4, [r3, #0]
   b8512:	4b25      	ldr	r3, [pc, #148]	; (b85a8 <__register_exitproc+0xb8>)
   b8514:	b113      	cbz	r3, b851c <__register_exitproc+0x2c>
   b8516:	681b      	ldr	r3, [r3, #0]
   b8518:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
   b851c:	6863      	ldr	r3, [r4, #4]
   b851e:	2b1f      	cmp	r3, #31
   b8520:	dd07      	ble.n	b8532 <__register_exitproc+0x42>
   b8522:	f8d8 0000 	ldr.w	r0, [r8]
   b8526:	f000 f847 	bl	b85b8 <__retarget_lock_release_recursive>
   b852a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   b852e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   b8532:	b34e      	cbz	r6, b8588 <__register_exitproc+0x98>
   b8534:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   b8538:	b988      	cbnz	r0, b855e <__register_exitproc+0x6e>
   b853a:	4b1c      	ldr	r3, [pc, #112]	; (b85ac <__register_exitproc+0xbc>)
   b853c:	b923      	cbnz	r3, b8548 <__register_exitproc+0x58>
   b853e:	f8d8 0000 	ldr.w	r0, [r8]
   b8542:	f000 f838 	bl	b85b6 <__retarget_lock_release>
   b8546:	e7f0      	b.n	b852a <__register_exitproc+0x3a>
   b8548:	f44f 7084 	mov.w	r0, #264	; 0x108
   b854c:	f7fe fa1c 	bl	b6988 <malloc>
   b8550:	2800      	cmp	r0, #0
   b8552:	d0f4      	beq.n	b853e <__register_exitproc+0x4e>
   b8554:	2300      	movs	r3, #0
   b8556:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
   b855a:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
   b855e:	6863      	ldr	r3, [r4, #4]
   b8560:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
   b8564:	2201      	movs	r2, #1
   b8566:	409a      	lsls	r2, r3
   b8568:	eb00 0183 	add.w	r1, r0, r3, lsl #2
   b856c:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
   b8570:	4313      	orrs	r3, r2
   b8572:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
   b8576:	2e02      	cmp	r6, #2
   b8578:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
   b857c:	bf02      	ittt	eq
   b857e:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
   b8582:	4313      	orreq	r3, r2
   b8584:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
   b8588:	6863      	ldr	r3, [r4, #4]
   b858a:	f8d8 0000 	ldr.w	r0, [r8]
   b858e:	1c5a      	adds	r2, r3, #1
   b8590:	3302      	adds	r3, #2
   b8592:	6062      	str	r2, [r4, #4]
   b8594:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
   b8598:	f000 f80e 	bl	b85b8 <__retarget_lock_release_recursive>
   b859c:	2000      	movs	r0, #0
   b859e:	e7c6      	b.n	b852e <__register_exitproc+0x3e>
   b85a0:	2003e7e8 	.word	0x2003e7e8
   b85a4:	2003e75c 	.word	0x2003e75c
   b85a8:	00000000 	.word	0x00000000
   b85ac:	000b6989 	.word	0x000b6989
   b85b0:	2003de74 	.word	0x2003de74

000b85b4 <__retarget_lock_acquire_recursive>:
   b85b4:	4770      	bx	lr

000b85b6 <__retarget_lock_release>:
   b85b6:	4770      	bx	lr

000b85b8 <__retarget_lock_release_recursive>:
   b85b8:	4770      	bx	lr

000b85ba <link_code_end>:
	...

000b85bc <dynalib_user>:
   b85bc:	48d9 000b 4915 000b 493d 000b 4941 000b     .H...I..=I..AI..
   b85cc:	0000 0000 6f68 6b6f 722d 7365 6f70 736e     ....hook-respons
   b85dc:	2f65 6567 5f74 6164 6174 4900 696e 6974     e/get_data.Initi
   b85ec:	6c61 7a69 6e69 2067 4e50 3335 0032 7055     alizing PN532.Up
   b85fc:	6164 6974 676e 4520 502d 7061 7265 4420     dating E-Paper D
   b860c:	7369 6c70 7961 0a0d 0020 6146 6c69 6465     isplay.. .Failed
   b861c:	7420 206f 6e69 7469 6169 696c 657a 6420      to initialize d
   b862c:	7369 6c70 7961 5400 5449 454c 5300 6174     isplay.TITLE.Sta
   b863c:	7472 0020 6954 656d 4500 646e 2020 0020     rt .Time.End   .
   b864c:	4142 5454 5245 2059 0025 6954 656d 5a20     BATTERY %.Time Z
   b865c:	6e6f 0065 4e49 5453 5552 5443 524f 003a     one.INSTRUCTOR:.
   b866c:	7453 7261 6873 7069 4920 5446 2033 202d     Starship IFT3 - 
   b867c:	5700 6168 2074 6f74 6520 7078 6365 2074     .What to expect 
   b868c:	6600 6f72 206d 6874 2065 656e 7478 0020     .from the next .
   b869c:	6c66 6769 7468 7420 7365 0074 3025 6932     flight test.%02i
   b86ac:	4100 004d 4d50 2d00 5400 7c00 4600 4941     .AM.PM.-.T.|.FAI
   b86bc:	454c 2044 202d 4c50 4145 4553 5320 4143     LED - PLEASE SCA
   b86cc:	204e 4741 4941 214e 4500 4a4e 594f 5420     N AGAIN!.ENJOY T
   b86dc:	4548 4520 4556 544e 0021 4955 3a44 0020     HE EVENT!.UID: .
   b86ec:	6f43 736e 7274 6375 6974 676e 6d20 7365     Constructing mes
   b86fc:	6173 6567 2e2e 002e 2e25 6632 4320 2c0a     sage....%.2f C.,
   b870c:	2520 322e 2066 566d 2c0a 2520 322e 2066      %.2f mV., %.2f 
   b871c:	416d 2c0a 2520 322e 2066 416d 2c0a 2520     mA., %.2f mA., %
   b872c:	322e 2066 2525 0a0d 4300 6c61 696c 676e     .2f %%...Calling
   b873c:	4520 646e 5020 696f 746e 6620 6e75 7463      End Point funct
   b874c:	6f69 2e6e 2e2e 6600 6572 2065 656d 6f6d     ion....free memo
   b875c:	7972 203a 4900 2046 7453 7461 6d65 6e65     ry: .IF Statemen
   b876c:	2074 7865 6365 7475 6e69 0067 444c 204f     t executing.LDO 
   b877c:	6944 6373 6e6f 656e 7463 6465 6400 6665     Disconnected.def
   b878c:	7561 746c 0020 534d 0042 534c 0042 533c     ault .MSB.LSB.<S
   b879c:	4950 6553 7474 6e69 7367 6420 6665 7561     PISettings defau
   b87ac:	746c 003e 533c 4950 6553 7474 6e69 7367     lt>.<SPISettings
   b87bc:	2520 2573 2075 7325 4d20 444f 2545 3e75      %s%u %s MODE%u>
   b87cc:	0000 0000                                   ....

000b87d0 <_ZTVN8particle11SPISettingsE>:
	...
   b87d8:	58fd 000b 58cf 000b 58d1 000b               .X...X...X..

000b87e4 <_ZL12Font16_Table>:
	...
   b8804:	0000 000c 000c 000c 000c 000c 000c 000c     ................
   b8814:	000c 0000 000c 0000 0000 0000 0000 0000     ................
   b8824:	0000 0000 c01d c01d 8008 8008 8008 0000     ................
	...
   b8844:	0000 800d 800d 800d 800d c03f 001b c03f     ..........?...?.
   b8854:	001b 001b 001b 001b 0000 0000 0000 0000     ................
   b8864:	0004 801f 8031 8031 0038 001e 000f 8003     ....1.1.8.......
   b8874:	8031 8031 003f 0004 0004 0000 0000 0000     1.1.?...........
   b8884:	0000 0018 0024 0024 c018 8007 001e 8031     ....$.$.......1.
   b8894:	4002 4002 8001 0000 0000 0000 0000 0000     .@.@............
   b88a4:	0000 0000 000f 0018 0018 0018 000c 801d     ................
   b88b4:	0037 0033 801d 0000 0000 0000 0000 0000     7.3.............
   b88c4:	0000 0000 0007 0007 0002 0002 0002 0000     ................
	...
   b88e4:	0000 0003 0003 0006 000e 000c 000c 000c     ................
   b88f4:	000c 000e 0006 0003 0003 0000 0000 0000     ................
   b8904:	0000 0018 0018 000c 0006 0006 0006 0006     ................
   b8914:	0006 0006 000c 001c 0018 0000 0000 0000     ................
   b8924:	0000 0006 0006 c03f c03f 000f 801f 8019     ......?.?.......
	...
   b8948:	0000 0004 0004 0004 803f 0004 0004 0004     ........?.......
	...
   b8974:	0000 0006 0004 000c 0008 0008 0000 0000     ................
	...
   b8990:	803f 0000 0000 0000 0000 0000 0000 0000     ?...............
	...
   b89b4:	0000 000c 000c 0000 0000 0000 0000 0000     ................
   b89c4:	c000 c000 8001 8001 0003 0003 0006 000c     ................
   b89d4:	000c 0018 0018 0030 0030 0000 0000 0000     ......0.0.......
   b89e4:	0000 000e 001b 8031 8031 8031 8031 8031     ......1.1.1.1.1.
   b89f4:	8031 001b 000e 0000 0000 0000 0000 0000     1...............
   b8a04:	0000 0006 003e 0006 0006 0006 0006 0006     ....>...........
   b8a14:	0006 0006 c03f 0000 0000 0000 0000 0000     ....?...........
   b8a24:	0000 000f 8019 8031 8031 0003 0006 000c     ......1.1.......
   b8a34:	0018 0030 803f 0000 0000 0000 0000 0000     ..0.?...........
   b8a44:	0000 003f 8061 8001 0003 001f 8003 8001     ..?.a...........
   b8a54:	8001 8061 003f 0000 0000 0000 0000 0000     ..a.?...........
   b8a64:	0000 0007 0007 000f 000b 001b 0013 0033     ..............3.
   b8a74:	803f 0003 800f 0000 0000 0000 0000 0000     ?...............
   b8a84:	0000 801f 0018 0018 0018 001f 8011 8001     ................
   b8a94:	8001 8021 001f 0000 0000 0000 0000 0000     ..!.............
   b8aa4:	0000 8007 001c 0018 0030 0037 8039 8031     ........0.7.9.1.
   b8ab4:	8031 8019 000f 0000 0000 0000 0000 0000     1...............
   b8ac4:	0000 007f 0043 0003 0006 0006 0006 0006     ....C...........
   b8ad4:	000c 000c 000c 0000 0000 0000 0000 0000     ................
   b8ae4:	0000 001f 8031 8031 8031 001f 8031 8031     ....1.1.1...1.1.
   b8af4:	8031 8031 001f 0000 0000 0000 0000 0000     1.1.............
   b8b04:	0000 001e 0033 8031 8031 8033 801d 8001     ....3.1.1.3.....
   b8b14:	0003 0007 003c 0000 0000 0000 0000 0000     ....<...........
	...
   b8b2c:	000c 000c 0000 0000 0000 000c 000c 0000     ................
	...
   b8b4c:	0003 0003 0000 0000 0000 0006 0004 0008     ................
   b8b5c:	0008 0000 0000 0000 0000 0000 c000 0003     ................
   b8b6c:	0004 0018 0060 0018 0004 0003 c000 0000     ....`...........
	...
   b8b8c:	0000 c07f 0000 c07f 0000 0000 0000 0000     ................
	...
   b8ba8:	0060 0018 0004 0003 c000 0003 0004 0018     `...............
   b8bb8:	0060 0000 0000 0000 0000 0000 0000 0000     `...............
   b8bc8:	001f 8031 8031 8001 0007 000c 000c 0000     ..1.1...........
   b8bd8:	000c 0000 0000 0000 0000 0000 0000 000e     ................
   b8be8:	0011 0021 0021 0027 0029 0029 0027 0020     ..!.!.'.).).'. .
   b8bf8:	0011 000e 0000 0000 0000 0000 0000 0000     ................
   b8c08:	003f 000f 0009 8019 8019 801f c030 c030     ?...........0.0.
   b8c18:	e079 0000 0000 0000 0000 0000 0000 0000     y...............
   b8c28:	007f 8031 8031 8031 003f 8031 8031 8031     ..1.1.1.?.1.1.1.
   b8c38:	007f 0000 0000 0000 0000 0000 0000 0000     ................
   b8c48:	401f c030 4060 0060 0060 0060 4060 8030     .@0.`@`.`.`.`@0.
   b8c58:	001f 0000 0000 0000 0000 0000 0000 0000     ................
   b8c68:	007f 8031 c030 c030 c030 c030 c030 8031     ..1.0.0.0.0.0.1.
   b8c78:	007f 0000 0000 0000 0000 0000 0000 0000     ................
   b8c88:	807f 8030 8030 0032 003e 0032 8030 8030     ..0.0.2.>.2.0.0.
   b8c98:	807f 0000 0000 0000 0000 0000 0000 0000     ................
   b8ca8:	c07f 4030 4030 0032 003e 0032 0030 0030     ..0@0@2.>.2.0.0.
   b8cb8:	007c 0000 0000 0000 0000 0000 0000 0000     |...............
   b8cc8:	801e 8031 8060 0060 0060 c067 8061 8031     ..1.`.`.`.g.a.1.
   b8cd8:	001f 0000 0000 0000 0000 0000 0000 0000     ................
   b8ce8:	c07b 8031 8031 8031 803f 8031 8031 8031     {.1.1.1.?.1.1.1.
   b8cf8:	c07b 0000 0000 0000 0000 0000 0000 0000     {...............
   b8d08:	c03f 0006 0006 0006 0006 0006 0006 0006     ?...............
   b8d18:	c03f 0000 0000 0000 0000 0000 0000 0000     ?...............
   b8d28:	c01f 0003 0003 0003 0003 0063 0063 0063     ..........c.c.c.
   b8d38:	003e 0000 0000 0000 0000 0000 0000 0000     >...............
   b8d48:	c07b 8031 0033 0036 003c 003e 0033 8031     {.1.3.6.<.>.3.1.
   b8d58:	c079 0000 0000 0000 0000 0000 0000 0000     y...............
   b8d68:	007e 0018 0018 0018 0018 4018 4018 4018     ~..........@.@.@
   b8d78:	c07f 0000 0000 0000 0000 0000 0000 0000     ................
   b8d88:	e0e0 c060 c071 c07b c06a c06e c064 c060     ..`.q.{.j.n.d.`.
   b8d98:	e0fb 0000 0000 0000 0000 0000 0000 0000     ................
   b8da8:	c073 8031 8039 803d 8035 8037 8033 8031     s.1.9.=.5.7.3.1.
   b8db8:	8079 0000 0000 0000 0000 0000 0000 0000     y...............
   b8dc8:	001f 8031 c060 c060 c060 c060 c060 8031     ..1.`.`.`.`.`.1.
   b8dd8:	001f 0000 0000 0000 0000 0000 0000 0000     ................
   b8de8:	007f 8031 8031 8031 8031 003f 0030 0030     ..1.1.1.1.?.0.0.
   b8df8:	007e 0000 0000 0000 0000 0000 0000 0000     ~...............
   b8e08:	001f 8031 c060 c060 c060 c060 c060 8031     ..1.`.`.`.`.`.1.
   b8e18:	001f c00c 801f 0000 0000 0000 0000 0000     ................
   b8e28:	007f 8031 8031 8031 003e 0033 8031 8031     ..1.1.1.>.3.1.1.
   b8e38:	e07c 0000 0000 0000 0000 0000 0000 0000     |...............
   b8e48:	801f 8031 8031 0038 001f 8003 8031 8031     ..1.1.8.....1.1.
   b8e58:	003f 0000 0000 0000 0000 0000 0000 0000     ?...............
   b8e68:	807f 804c 804c 804c 000c 000c 000c 000c     ..L.L.L.........
   b8e78:	003f 0000 0000 0000 0000 0000 0000 0000     ?...............
   b8e88:	c07b 8031 8031 8031 8031 8031 8031 8031     {.1.1.1.1.1.1.1.
   b8e98:	001f 0000 0000 0000 0000 0000 0000 0000     ................
   b8ea8:	c07b 8031 8031 001b 001b 001b 000a 000e     {.1.1...........
   b8eb8:	000e 0000 0000 0000 0000 0000 0000 0000     ................
   b8ec8:	e0fb c060 c064 c06e c06e 802a 803b 803b     ..`.d.n.n.*.;.;.
   b8ed8:	8031 0000 0000 0000 0000 0000 0000 0000     1...............
   b8ee8:	c07b 8031 001b 000e 000e 000e 001b 8031     {.1...........1.
   b8ef8:	c07b 0000 0000 0000 0000 0000 0000 0000     {...............
   b8f08:	e079 c030 8019 000f 0006 0006 0006 0006     y.0.............
   b8f18:	801f 0000 0000 0000 0000 0000 0000 0000     ................
   b8f28:	803f 8021 0023 0006 0004 000c 8018 8030     ?.!.#.........0.
   b8f38:	803f 0000 0000 0000 0000 0000 0000 8007     ?...............
   b8f48:	0006 0006 0006 0006 0006 0006 0006 0006     ................
   b8f58:	0006 0006 8007 0000 0000 0000 0030 0030     ............0.0.
   b8f68:	0018 0018 000c 000c 0006 0003 0003 8001     ................
   b8f78:	8001 c000 c000 0000 0000 0000 0000 001e     ................
   b8f88:	0006 0006 0006 0006 0006 0006 0006 0006     ................
   b8f98:	0006 0006 001e 0000 0000 0000 0004 000a     ................
   b8fa8:	000a 0011 8020 8020 0000 0000 0000 0000     .... . .........
	...
   b8fe0:	0000 e0ff 0008 0004 0002 0000 0000 0000     ................
	...
   b900c:	001f 8001 8001 801f 8031 8033 c01d 0000     ........1.3.....
	...
   b9024:	0000 0070 0030 0030 0037 8039 c030 c030     ..p.0.0.7.9.0.0.
   b9034:	c030 8039 0077 0000 0000 0000 0000 0000     0.9.w...........
	...
   b904c:	801e 8031 8060 0060 8060 8031 001f 0000     ..1.`.`.`.1.....
	...
   b9064:	0000 8003 8001 8001 801d 8033 8061 8061     ..........3.a.a.
   b9074:	8061 8033 c01d 0000 0000 0000 0000 0000     a.3.............
	...
   b908c:	001f 8031 c060 c07f 0060 c030 801f 0000     ..1.`...`.0.....
	...
   b90a4:	0000 e007 000c 000c 803f 000c 000c 000c     ........?.......
   b90b4:	000c 000c 803f 0000 0000 0000 0000 0000     ....?...........
	...
   b90cc:	c01d 8033 8061 8061 8061 8033 801d 8001     ..3.a.a.a.3.....
   b90dc:	8001 001f 0000 0000 0000 0070 0030 0030     ..........p.0.0.
   b90ec:	0037 8039 8031 8031 8031 8031 c07b 0000     7.9.1.1.1.1.{...
	...
   b9104:	0000 0006 0006 0000 001e 0006 0006 0006     ................
   b9114:	0006 0006 c03f 0000 0000 0000 0000 0000     ....?...........
   b9124:	0000 0006 0006 0000 003f 0003 0003 0003     ........?.......
   b9134:	0003 0003 0003 0003 0003 003e 0000 0000     ..........>.....
   b9144:	0000 0070 0030 0030 8037 0036 003c 003c     ..p.0.0.7.6.<.<.
   b9154:	0036 0033 c077 0000 0000 0000 0000 0000     6.3.w...........
   b9164:	0000 001e 0006 0006 0006 0006 0006 0006     ................
   b9174:	0006 0006 c03f 0000 0000 0000 0000 0000     ....?...........
	...
   b918c:	807f c036 c036 c036 c036 c036 e076 0000     ..6.6.6.6.6.v...
	...
   b91ac:	0077 8039 8031 8031 8031 8031 c07b 0000     w.9.1.1.1.1.{...
	...
   b91cc:	001f 8031 c060 c060 c060 8031 001f 0000     ..1.`.`.`.1.....
	...
   b91ec:	0077 8039 c030 c030 c030 8039 0037 0030     w.9.0.0.0.9.7.0.
   b91fc:	0030 007c 0000 0000 0000 0000 0000 0000     0.|.............
   b920c:	c01d 8033 8061 8061 8061 8033 801d 8001     ..3.a.a.a.3.....
   b921c:	8001 c007 0000 0000 0000 0000 0000 0000     ................
   b922c:	807b c01c 0018 0018 0018 0018 007f 0000     {...............
	...
   b924c:	801f 8031 003c 001f 8003 8031 003f 0000     ..1.<.....1.?...
	...
   b9264:	0000 0018 0018 0018 007f 0018 0018 0018     ................
   b9274:	0018 8018 000f 0000 0000 0000 0000 0000     ................
	...
   b928c:	8073 8031 8031 8031 8031 8033 c01d 0000     s.1.1.1.1.3.....
	...
   b92ac:	c07b 8031 8031 001b 001b 000e 000e 0000     {.1.1...........
	...
   b92cc:	e0f1 c060 c064 c06e 803b 803b 8031 0000     ..`.d.n.;.;.1...
	...
   b92ec:	c07b 001b 000e 000e 000e 001b c07b 0000     {...........{...
	...
   b930c:	e079 c030 8019 8019 000b 000f 0006 0006     y.0.............
   b931c:	000c 003e 0000 0000 0000 0000 0000 0000     ..>.............
   b932c:	803f 8021 0003 000e 0018 8030 803f 0000     ?.!.......0.?...
	...
   b9344:	0000 0006 000c 000c 000c 000c 000c 0018     ................
   b9354:	000c 000c 000c 000c 0006 0000 0000 0000     ................
   b9364:	0000 0006 0006 0006 0006 0006 0006 0006     ................
   b9374:	0006 0006 0006 0006 0006 0000 0000 0000     ................
   b9384:	0000 000c 0006 0006 0006 0006 0006 0003     ................
   b9394:	0006 0006 0006 0006 000c 0000 0000 0000     ................
	...
   b93ac:	0000 0018 8024 0003 0000 0000 0000 0000     ....$...........
	...

000b93c4 <_ZL12Font20_Table>:
	...
   b93ec:	0000 0007 0007 0007 0007 0007 0007 0007     ................
   b93fc:	0002 0002 0000 0000 0007 0007 0000 0000     ................
	...
   b9418:	e01c e01c e01c 4008 4008 4008 0000 0000     .......@.@.@....
	...
   b943c:	c00c c00c c00c c00c c00c f03f f03f c00c     ..........?.?...
   b944c:	c00c f03f f03f c00c c00c c00c c00c c00c     ..?.?...........
	...
   b9464:	0003 0003 e007 e00f 6018 0018 001f c00f     .........`......
   b9474:	e000 6018 6018 c01f 801f 0003 0003 0003     ...`.`..........
	...
   b948c:	0000 001c 0022 0022 0022 601c e001 800f     ...."."."..`....
   b949c:	003c c031 2002 2002 2002 c001 0000 0000     <.1.. . . ......
	...
   b94b8:	0000 e003 e00f 000c 000c 0006 300f f01f     .............0..
   b94c8:	e019 c018 f01f b007 0000 0000 0000 0000     ................
	...
   b94e0:	8003 8003 8003 0001 0001 0001 0000 0000     ................
	...
   b9504:	0000 c000 c000 8001 8001 8001 0003 0003     ................
   b9514:	0003 0003 0003 0003 8001 8001 8001 c000     ................
   b9524:	c000 0000 0000 0000 0000 000c 000c 0006     ................
   b9534:	0006 0006 0003 0003 0003 0003 0003 0003     ................
   b9544:	0006 0006 0006 000c 000c 0000 0000 0000     ................
   b9554:	0000 0003 0003 0003 601b e01f 8007 8007     .........`......
   b9564:	c00f c00c 0000 0000 0000 0000 0000 0000     ................
	...
   b9580:	0000 0003 0003 0003 0003 f03f f03f 0003     ..........?.?...
   b9590:	0003 0003 0003 0000 0000 0000 0000 0000     ................
	...
   b95b8:	0000 8003 0003 0003 0006 0006 0004 0000     ................
	...
   b95d8:	0000 e03f e03f 0000 0000 0000 0000 0000     ..?.?...........
	...
   b9608:	0000 8003 8003 8003 0000 0000 0000 0000     ................
   b9618:	0000 0000 6000 6000 c000 c000 c000 8001     .....`.`........
   b9628:	8001 0003 0003 0006 0006 000c 000c 000c     ................
   b9638:	0018 0018 0000 0000 0000 0000 0000 800f     ................
   b9648:	c01f c018 6030 6030 6030 6030 6030 6030     ....0`0`0`0`0`0`
   b9658:	6030 c018 c01f 800f 0000 0000 0000 0000     0`..............
   b9668:	0000 0000 0000 0003 001f 001f 0003 0003     ................
   b9678:	0003 0003 0003 0003 0003 0003 e01f e01f     ................
	...
   b9694:	0000 800f c01f e038 6030 6000 c000 8001     ......8.0`.`....
   b96a4:	0003 0006 000c 0018 e03f e03f 0000 0000     ........?.?.....
	...
   b96bc:	0000 800f c03f e030 6000 e000 c007 c007     ....?.0..`......
   b96cc:	e000 6000 6000 e060 c07f 803f 0000 0000     ...`.``...?.....
	...
   b96e4:	0000 c001 c003 c003 c006 c00c c00c c018     ................
   b96f4:	c030 e03f e03f c000 e003 e003 0000 0000     0.?.?...........
	...
   b970c:	0000 c01f c01f 0018 0018 801f c01f e018     ................
   b971c:	6000 6000 6000 e030 c03f 801f 0000 0000     .`.`.`0.?.......
	...
   b9734:	0000 e003 e00f 001e 0018 0038 8037 c03f     ..........8.7.?.
   b9744:	e038 6030 6030 e018 c01f 8007 0000 0000     8.0`0`..........
	...
   b975c:	0000 e03f e03f 6030 6000 c000 c000 c000     ..?.?.0`.`......
   b976c:	8001 8001 8001 0003 0003 0003 0000 0000     ................
	...
   b9784:	0000 800f c01f e038 6030 e038 c01f c01f     ......8.0`8.....
   b9794:	e038 6030 6030 e038 c01f 800f 0000 0000     8.0`0`8.........
	...
   b97ac:	0000 000f c01f c038 6030 6030 e038 e01f     ......8.0`0`8...
   b97bc:	600f e000 c000 c003 803f 003e 0000 0000     .`......?.>.....
	...
   b97dc:	0000 8003 8003 8003 0000 0000 0000 8003     ................
   b97ec:	8003 8003 0000 0000 0000 0000 0000 0000     ................
	...
   b9804:	0000 c001 c001 c001 0000 0000 0000 8003     ................
   b9814:	0003 0006 0006 0004 0000 0000 0000 0000     ................
   b9824:	0000 0000 0000 3000 f000 c003 0007 001c     .......0........
   b9834:	0078 001c 0007 c003 f000 3000 0000 0000     x..........0....
	...
   b9854:	0000 f07f f07f 0000 0000 f07f f07f 0000     ................
	...
   b9878:	0000 0030 003c 000f 8003 e000 7800 e000     ..0.<........x..
   b9888:	8003 000f 003c 0030 0000 0000 0000 0000     ....<.0.........
	...
   b98a0:	800f c01f 6018 6018 6000 c001 8003 0003     .....`.`.`......
   b98b0:	0000 0000 0007 0007 0000 0000 0000 0000     ................
   b98c0:	0000 0000 0000 8003 800c 4008 4010 4010     ...........@.@.@
   b98d0:	c011 4012 4012 4012 c011 0010 0008 4008     ...@.@.@.......@
   b98e0:	8007 0000 0000 0000 0000 0000 0000 0000     ................
   b98f0:	801f 801f 8003 c006 c006 c00c 600c e01f     .............`..
   b9900:	e01f 3030 7878 7878 0000 0000 0000 0000     ..00xxxx........
	...
   b9918:	803f c03f 6018 6018 e018 c01f e01f 7018     ?.?..`.`.......p
   b9928:	3018 3018 f03f e03f 0000 0000 0000 0000     .0.0?.?.........
	...
   b9940:	b007 f00f 701c 3038 0030 0030 0030 0030     .....p800.0.0.0.
   b9950:	3038 701c e00f c007 0000 0000 0000 0000     80.p............
	...
   b9968:	807f c07f e030 7030 3030 3030 3030 3030     ....0.0p00000000
   b9978:	7030 e030 c07f 807f 0000 0000 0000 0000     0p0.............
	...
   b9990:	f03f f03f 3018 3018 8019 801f 801f 8019     ?.?..0.0........
   b99a0:	3018 3018 f03f f03f 0000 0000 0000 0000     .0.0?.?.........
	...
   b99b8:	f03f f03f 3018 3018 8019 801f 801f 8019     ?.?..0.0........
   b99c8:	0018 0018 003f 003f 0000 0000 0000 0000     ....?.?.........
	...
   b99e0:	b007 f01f 7018 3030 0030 0030 f831 f831     .....p000.0.1.1.
   b99f0:	3030 3018 f01f c007 0000 0000 0000 0000     00.0............
	...
   b9a08:	f03c f03c 6018 6018 6018 e01f e01f 6018     <.<..`.`.`.....`
   b9a18:	6018 6018 f03c f03c 0000 0000 0000 0000     .`.`<.<.........
	...
   b9a30:	e01f e01f 0003 0003 0003 0003 0003 0003     ................
   b9a40:	0003 0003 e01f e01f 0000 0000 0000 0000     ................
	...
   b9a58:	f803 f803 6000 6000 6000 6000 6030 6030     .....`.`.`.`0`0`
   b9a68:	6030 e030 c03f 800f 0000 0000 0000 0000     0`0.?...........
	...
   b9a80:	f83e f83e e018 8019 001b 001f 801d c018     >.>.............
   b9a90:	c018 6018 783e 383e 0000 0000 0000 0000     ...`>x>8........
	...
   b9aa8:	003f 003f 000c 000c 000c 000c 000c 300c     ?.?............0
   b9ab8:	300c 300c f03f f03f 0000 0000 0000 0000     .0.0?.?.........
	...
   b9ad0:	7878 7878 7038 f03c b034 b037 b037 3033     xxxx8p<.4.7.7.30
   b9ae0:	3033 3030 f87c f87c 0000 0000 0000 0000     3000|.|.........
	...
   b9af8:	f039 f03d 601c 601e 601e 601b 601b e019     9.=..`.`.`.`.`..
   b9b08:	e019 e018 e03e 603e 0000 0000 0000 0000     ....>.>`........
	...
   b9b20:	8007 c00f e01c 7038 3030 3030 3030 3030     ......8p00000000
   b9b30:	7038 e01c c00f 8007 0000 0000 0000 0000     8p..............
	...
   b9b48:	c03f e03f 7018 3018 3018 7018 e01f c01f     ?.?..p.0.0.p....
   b9b58:	0018 0018 003f 003f 0000 0000 0000 0000     ....?.?.........
	...
   b9b70:	8007 c00f e01c 7038 3030 3030 3030 3030     ......8p00000000
   b9b80:	7038 e01c c00f 8007 b007 f00f e00c 0000     8p..............
	...
   b9b98:	c03f e03f 7018 3018 7018 e01f c01f e018     ?.?..p.0.p......
   b9ba8:	6018 7018 383e 183e 0000 0000 0000 0000     .`.p>8>.........
	...
   b9bc0:	b00f f01f 7038 3030 0038 801f e007 7000     ....8p008......p
   b9bd0:	3030 7038 e03f c037 0000 0000 0000 0000     008p?.7.........
	...
   b9be8:	f03f f03f 3033 3033 3033 0003 0003 0003     ?.?.303030......
   b9bf8:	0003 0003 c00f c00f 0000 0000 0000 0000     ................
	...
   b9c10:	f03c f03c 6018 6018 6018 6018 6018 6018     <.<..`.`.`.`.`.`
   b9c20:	6018 e01c c00f 8007 0000 0000 0000 0000     .`..............
	...
   b9c38:	f078 f078 6030 6030 c018 c018 800d 800d     x.x.0`0`........
   b9c48:	800d 0007 0007 0007 0000 0000 0000 0000     ................
	...
   b9c60:	7c7c 7c7c 1830 9833 9833 9833 d836 d016     ||||0.3.3.3.6...
   b9c70:	701c 701c 701c 3018 0000 0000 0000 0000     .p.p.p.0........
	...
   b9c88:	f078 f078 6030 c018 800d 0007 0007 800d     x.x.0`..........
   b9c98:	c018 6030 f078 f078 0000 0000 0000 0000     ..0`x.x.........
	...
   b9cb0:	f03c f03c 6018 c00c 8007 8007 0003 0003     <.<..`..........
   b9cc0:	0003 0003 c00f c00f 0000 0000 0000 0000     ................
	...
   b9cd8:	e01f e01f 6018 c018 8001 0003 0003 0006     .....`..........
   b9ce8:	600c 6018 e01f e01f 0000 0000 0000 0000     .`.`............
   b9cf8:	0000 0000 0000 c003 c003 0003 0003 0003     ................
   b9d08:	0003 0003 0003 0003 0003 0003 0003 0003     ................
   b9d18:	0003 c003 c003 0000 0000 0000 0018 0018     ................
   b9d28:	000c 000c 000c 0006 0006 0003 0003 8001     ................
   b9d38:	8001 c000 c000 c000 6000 6000 0000 0000     .........`.`....
   b9d48:	0000 0000 0000 000f 000f 0003 0003 0003     ................
   b9d58:	0003 0003 0003 0003 0003 0003 0003 0003     ................
   b9d68:	0003 000f 000f 0000 0000 0000 0000 0002     ................
   b9d78:	0007 800d c018 6030 2020 0000 0000 0000     ......0`  ......
	...
   b9dc0:	fcff fcff 0000 0004 0003 8000 0000 0000     ................
	...
   b9df4:	0000 c00f e01f 6000 e00f e01f 6038 e030     .......`....8`0.
   b9e04:	f03f 701f 0000 0000 0000 0000 0000 0000     ?..p............
   b9e14:	0000 0070 0070 0030 0030 8037 e03f 6038     ..p.p.0.0.7.?.8`
   b9e24:	3030 3030 3030 6038 e07f 8077 0000 0000     0000008`..w.....
	...
   b9e44:	0000 b007 f01f 3018 3030 0030 0030 3038     .......0000.0.80
   b9e54:	f01f c00f 0000 0000 0000 0000 0000 0000     ................
   b9e64:	0000 7000 7000 3000 3000 b007 f01f 7018     ...p.p.0.0.....p
   b9e74:	3030 3030 3030 7038 f81f b807 0000 0000     0000008p........
	...
   b9e94:	0000 8007 e01f 6018 f03f f03f 0030 3018     .......`?.?.0..0
   b9ea4:	f01f c007 0000 0000 0000 0000 0000 0000     ................
   b9eb4:	0000 f003 f007 0006 0006 e01f e01f 0006     ................
   b9ec4:	0006 0006 0006 0006 e01f e01f 0000 0000     ................
	...
   b9ee4:	0000 b807 f81f 7018 3030 3030 3030 7018     .......p000000.p
   b9ef4:	f01f b007 3000 7000 e00f c00f 0000 0000     .....0.p........
   b9f04:	0000 0038 0038 0018 0018 c01b e01f 601c     ..8.8..........`
   b9f14:	6018 6018 6018 6018 f03c f03c 0000 0000     .`.`.`.`<.<.....
	...
   b9f2c:	0000 0003 0003 0000 0000 001f 001f 0003     ................
   b9f3c:	0003 0003 0003 0003 e01f e01f 0000 0000     ................
	...
   b9f54:	0000 0003 0003 0000 0000 c01f c01f c000     ................
   b9f64:	c000 c000 c000 c000 c000 c000 c000 c001     ................
   b9f74:	803f 003f 0000 0000 0000 0038 0038 0018     ?.?.......8.8...
   b9f84:	0018 e01b e01b 001b 001e 001e 001b 8019     ................
   b9f94:	f039 f039 0000 0000 0000 0000 0000 0000     9.9.............
   b9fa4:	0000 001f 001f 0003 0003 0003 0003 0003     ................
   b9fb4:	0003 0003 0003 0003 e01f e01f 0000 0000     ................
	...
   b9fd4:	0000 e07e f07f 3033 3033 3033 3033 3033     ..~...3030303030
   b9fe4:	b87b b87b 0000 0000 0000 0000 0000 0000     {.{.............
	...
   b9ffc:	0000 c03b e03f 601c 6018 6018 6018 6018     ..;.?..`.`.`.`.`
   ba00c:	f03c f03c 0000 0000 0000 0000 0000 0000     <.<.............
	...
   ba024:	0000 8007 e01f 6018 3030 3030 3030 6018     .......`000000.`
   ba034:	e01f 8007 0000 0000 0000 0000 0000 0000     ................
	...
   ba04c:	0000 8077 e07f 6038 3030 3030 3030 6038     ..w...8`0000008`
   ba05c:	e03f 8037 0030 0030 007c 007c 0000 0000     ?.7.0.0.|.|.....
	...
   ba074:	0000 b807 f81f 7018 3030 3030 3030 7018     .......p000000.p
   ba084:	f01f b007 3000 3000 f800 f800 0000 0000     .....0.0........
	...
   ba09c:	0000 e03c f03d 300f 000e 000c 000c 000c     ..<.=..0........
   ba0ac:	c03f c03f 0000 0000 0000 0000 0000 0000     ?.?.............
	...
   ba0c4:	0000 e007 e01f 6018 001e c00f e001 6018     .......`.......`
   ba0d4:	e01f 801f 0000 0000 0000 0000 0000 0000     ................
   ba0e4:	0000 0000 000c 000c 000c e03f e03f 000c     ..........?.?...
   ba0f4:	000c 000c 000c 300c f00f c007 0000 0000     .......0........
	...
   ba114:	0000 e038 e038 6018 6018 6018 6018 e018     ..8.8..`.`.`.`..
   ba124:	f01f 700f 0000 0000 0000 0000 0000 0000     ...p............
	...
   ba13c:	0000 f078 f078 6030 c018 c018 800d 800d     ..x.x.0`........
   ba14c:	0007 0007 0000 0000 0000 0000 0000 0000     ................
	...
   ba164:	0000 f078 f078 6032 6032 e037 c01d c01d     ..x.x.2`2`7.....
   ba174:	c018 c018 0000 0000 0000 0000 0000 0000     ................
	...
   ba18c:	0000 f03c f03c c00c 8007 0003 8007 c00c     ..<.<...........
   ba19c:	f03c f03c 0000 0000 0000 0000 0000 0000     <.<.............
	...
   ba1b4:	0000 f078 f078 6030 c018 c018 800d 800f     ..x.x.0`........
   ba1c4:	0007 0006 0006 000c 007f 007f 0000 0000     ................
	...
   ba1dc:	0000 e01f e01f c018 8001 0003 0006 600c     ...............`
   ba1ec:	e01f e01f 0000 0000 0000 0000 0000 0000     ................
   ba1fc:	0000 c001 c003 0003 0003 0003 0003 0003     ................
   ba20c:	0007 000e 0007 0003 0003 0003 0003 c003     ................
   ba21c:	c001 0000 0000 0000 0000 0003 0003 0003     ................
   ba22c:	0003 0003 0003 0003 0003 0003 0003 0003     ................
   ba23c:	0003 0003 0003 0003 0003 0000 0000 0000     ................
   ba24c:	0000 001c 001e 0006 0006 0006 0006 0006     ................
   ba25c:	0007 8003 0007 0006 0006 0006 0006 001e     ................
   ba26c:	001c 0000 0000 0000 0000 0000 0000 0000     ................
   ba27c:	0000 0000 000e 303f f033 e001 0000 0000     ......?03.......
	...

000ba29c <_ZL12Font24_Table>:
	...
   ba2e8:	0000 8003 0300 0080 8003 0300 0080 8003     ................
   ba2f8:	0300 0080 8003 0300 0080 8003 0100 0000     ................
   ba308:	0001 0000 0000 0000 0300 0080 8003 0000     ................
	...
   ba334:	0e00 0070 700e 0e00 0070 2004 0400 0020     ..p..p..p.. .. .
   ba344:	2004 0400 0020 0000 0000 0000 0000 0000     . .. ...........
	...
   ba378:	0000 6006 0600 0060 6006 0600 0060 6006     ...`..`..`..`..`
   ba388:	3f00 00f8 f83f 0600 0060 c00c 3f00 00f8     .?..?...`....?..
   ba398:	f83f 0c00 00c0 c00c 0c00 00c0 c00c 0c00     ?...............
   ba3a8:	00c0 0000 0000 0000 0000 0000 0000 0000     ................
   ba3b8:	0000 0000 0000 0100 0080 8001 0700 00b0     ................
   ba3c8:	f00f 1800 0070 7018 1c00 0000 800f 0700     ....p..p........
   ba3d8:	00e0 f000 1800 0030 301c 1c00 0070 e01f     ......0..0..p...
   ba3e8:	1b00 00c0 8001 0100 0080 8001 0100 0080     ................
	...
   ba408:	0000 8007 0f00 00c0 e01c 1800 0060 6018     ............`..`
   ba418:	1c00 00e0 f80f 0700 00e0 f01f 0700 0038     ..............8.
   ba428:	1806 0600 0018 3807 0300 00f0 e001 0000     .......8........
	...
   ba458:	f003 0700 00f0 600c 0c00 0000 000c 0600     .......`........
   ba468:	0000 0007 0f00 009c fc1d 1800 00f0 7018     ...............p
   ba478:	0f00 00fc dc07 0000 0000 0000 0000 0000     ................
	...
   ba49c:	0300 0080 8003 0300 0080 0001 0100 0000     ................
   ba4ac:	0001 0100 0000 0000 0000 0000 0000 0000     ................
	...
   ba4e0:	0000 1800 0000 0038 7000 0000 00f0 e000     ......8..p......
   ba4f0:	0000 00e0 c001 0100 00c0 c001 0100 00c0     ................
   ba500:	c001 0100 00c0 e000 0000 00e0 7000 0000     .............p..
   ba510:	0070 3800 0000 0018 0000 0000 0000 0000     p..8............
	...
   ba528:	0000 0018 1c00 0000 000e 0e00 0000 0007     ................
   ba538:	0700 0000 8003 0300 0080 8003 0300 0080     ................
   ba548:	8003 0300 0080 0007 0700 0000 000f 0e00     ................
   ba558:	0000 001c 1800 0000 0000 0000 0000 0000     ................
	...
   ba570:	0000 8001 0100 0080 8001 1d00 00b8 f81f     ................
   ba580:	0700 00e0 c003 0300 00c0 6006 0600 0060     ...........`..`.
	...
   ba5c0:	8001 0100 0080 8001 0100 0080 8001 3f00     ...............?
   ba5d0:	00fc fc3f 0100 0080 8001 0100 0080 8001     ..?.............
   ba5e0:	0100 0080 0000 0000 0000 0000 0000 0000     ................
	...
   ba624:	0000 e000 0000 00c0 c001 0100 0080 8001     ................
   ba634:	0300 0000 0003 0000 0000 0000 0000 0000     ................
	...
   ba65c:	0000 1f00 00f8 f81f 0000 0000 0000 0000     ................
	...
   ba6b4:	0000 c003 0300 00c0 c003 0000 0000 0000     ................
	...
   ba6d4:	1800 0000 0018 3800 0000 0030 7000 0000     .......8..0..p..
   ba6e4:	0060 6000 0000 00c0 c000 0100 0080 8001     `..`............
   ba6f4:	0300 0000 0003 0600 0000 0006 0e00 0000     ................
   ba704:	000c 1c00 0000 0018 1800 0000 0000 0000     ................
	...
   ba720:	0000 c003 0700 00e0 300c 0c00 0030 1818     .........0..0...
   ba730:	1800 0018 1818 1800 0018 1818 1800 0018     ................
   ba740:	1818 0c00 0030 300c 0700 00e0 c003 0000     ....0..0........
	...
   ba768:	0000 8000 0700 0080 801f 1d00 0080 8001     ................
   ba778:	0100 0080 8001 0100 0080 8001 0100 0080     ................
   ba788:	8001 0100 0080 8001 1f00 00f8 f81f 0000     ................
	...
   ba7b0:	0000 c007 1f00 00f0 3038 3000 0018 1830     ........80.0..0.
   ba7c0:	0000 0018 3000 0000 0060 c001 0300 0080     .....0..`.......
   ba7d0:	0006 0c00 0000 0018 3f00 00f8 f83f 0000     .........?..?...
	...
   ba7f8:	0000 c003 0f00 00e0 700c 0000 0030 3000     .........p..0..0
   ba808:	0000 0060 c003 0300 00e0 7000 0000 0018     ..`........p....
   ba818:	1800 0000 0018 3818 1f00 00f0 c00f 0000     .......8........
	...
   ba840:	0000 e000 0100 00e0 e001 0300 0060 6006     ............`..`
   ba850:	0600 0060 600c 0c00 0060 6018 3000 0060     ..`..`..`..`.0`.
   ba860:	f83f 3f00 00f8 6000 0300 00f8 f803 0000     ?..?...`........
	...
   ba888:	0000 f01f 1f00 00f0 0018 1800 0000 0018     ................
   ba898:	1b00 00c0 f01f 1c00 0030 1800 0000 0018     ........0.......
   ba8a8:	1800 0000 0018 3030 3f00 00f0 c00f 0000     ......00.?......
	...
   ba8d0:	0000 f800 0300 00f8 0007 0e00 0000 000c     ................
   ba8e0:	1800 0000 c01b 1f00 00f0 301c 1800 0018     ...........0....
   ba8f0:	1818 1800 0018 380c 0f00 00f0 e003 0000     .......8........
	...
   ba918:	0000 f81f 1f00 00f8 1818 1800 0038 3000     ............8..0
   ba928:	0000 0030 7000 0000 0060 6000 0000 00e0     ..0..p..`..`....
   ba938:	c000 0000 00c0 c001 0100 0080 8001 0000     ................
	...
   ba960:	0000 e007 0f00 00f0 381c 1800 0018 1818     .........8......
   ba970:	0c00 0030 e007 0700 00e0 300c 1800 0018     ..0........0....
   ba980:	1818 1800 0018 381c 0f00 00f0 e007 0000     .......8........
	...
   ba9a8:	0000 c007 0f00 00f0 301c 1800 0018 1818     .........0......
   ba9b8:	1800 0018 380c 0f00 00f8 d803 0000 0018     .....8..........
   ba9c8:	3000 0000 0070 e000 1f00 00c0 001f 0000     .0..p...........
	...
   ba9fc:	0000 c003 0300 00c0 c003 0000 0000 0000     ................
	...
   baa14:	0000 c003 0300 00c0 c003 0000 0000 0000     ................
	...
   baa44:	0000 f000 0000 00f0 f000 0000 0000 0000     ................
	...
   baa5c:	00e0 c001 0100 0080 8001 0300 0000 0002     ................
	...
   baa88:	1c00 0000 003c f000 0300 00c0 000f 3c00     ....<..........<
   baa98:	0000 00f0 3c00 0000 000f 0300 00c0 f000     .....<..........
   baaa8:	0000 003c 1c00 0000 0000 0000 0000 0000     ..<.............
	...
   baad8:	7f00 00fc fc7f 0000 0000 0000 7f00 00fc     ................
   baae8:	fc7f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bab18:	0070 7800 0000 001e 0700 0080 e001 0000     p..x............
   bab28:	0078 1e00 0000 0078 e001 0700 0080 001e     x.....x.........
   bab38:	7800 0000 0070 0000 0000 0000 0000 0000     .x..p...........
	...
   bab5c:	0700 00c0 e00f 1800 0070 3018 1800 0030     ........p..0..0.
   bab6c:	7000 0000 00e0 c003 0300 0080 0003 0000     .p..............
   bab7c:	0000 0000 0700 0000 0007 0000 0000 0000     ................
	...
   baba0:	0000 e003 0700 00f0 380e 0c00 0018 7818     .........8.....x
   babb0:	1800 00f8 d819 1900 0098 9819 1900 0098     ................
   babc0:	f818 1800 0078 0018 0c00 0000 180e 0700     ....x...........
   babd0:	00f8 e003 0000 0000 0000 0000 0000 0000     ................
	...
   babec:	1f00 0080 c01f 0100 00c0 6003 0300 0060     ...........`..`.
   babfc:	3006 0600 0030 300c 0f00 00f8 f81f 1800     .0..0..0........
   bac0c:	000c 0c30 fc00 007f 7ffc 0000 0000 0000     ..0.............
	...
   bac34:	7f00 00e0 f07f 1800 0038 1818 1800 0018     ........8.......
   bac44:	3818 1f00 00f0 f81f 1800 001c 0c18 1800     .8..............
   bac54:	000c 0c18 7f00 00f8 f07f 0000 0000 0000     ................
	...
   bac7c:	0300 00ec fc0f 1c00 001c 0c18 3000 000c     .............0..
   bac8c:	0030 3000 0000 0030 3000 0000 0030 1800     0..0..0..0..0...
   bac9c:	000c 1c1c 0f00 00f8 f003 0000 0000 0000     ................
	...
   bacc4:	7f00 00c0 f07f 1800 0038 1818 1800 000c     ........8.......
   bacd4:	0c18 1800 000c 0c18 1800 000c 0c18 1800     ................
   bace4:	0018 3818 7f00 00f0 e07f 0000 0000 0000     ...8............
	...
   bad0c:	7f00 00f8 f87f 1800 0018 1818 1900 0098     ................
   bad1c:	8019 1f00 0080 801f 1900 0080 9819 1800     ................
   bad2c:	0018 1818 7f00 00f8 f87f 0000 0000 0000     ................
	...
   bad54:	3f00 00fc fc3f 0c00 000c 0c0c 0c00 00cc     .?..?...........
   bad64:	c00c 0f00 00c0 c00f 0c00 00c0 c00c 0c00     ................
   bad74:	0000 000c 3f00 00c0 c03f 0000 0000 0000     .....?..?.......
	...
   bad9c:	0300 00ec fc0f 1c00 001c 0c18 3000 000c     .............0..
   badac:	0030 3000 0000 fe30 3000 00fe 0c30 3800     0..0..0..0..0..8
   badbc:	000c 1c1c 0f00 00fc f003 0000 0000 0000     ................
	...
   bade4:	7e00 007e 7e7e 1800 0018 1818 1800 0018     .~~.~~..........
   badf4:	1818 1f00 00f8 f81f 1800 0018 1818 1800     ................
   bae04:	0018 1818 7e00 007e 7e7e 0000 0000 0000     .....~~.~~......
	...
   bae2c:	1f00 00f8 f81f 0100 0080 8001 0100 0080     ................
   bae3c:	8001 0100 0080 8001 0100 0080 8001 0100     ................
   bae4c:	0080 8001 1f00 00f8 f81f 0000 0000 0000     ................
	...
   bae74:	0700 00fe fe07 0000 0030 3000 0000 0030     ........0..0..0.
   bae84:	3000 0000 0030 3030 3000 0030 3030 3000     .0..0.00.00.00.0
   bae94:	0030 6030 3f00 00e0 800f 0000 0000 0000     0.0`.?..........
	...
   baebc:	7f00 003e 3e7f 1800 0030 6018 1800 00c0     ..>..>..0..`....
   baecc:	8019 1b00 0080 c01f 1c00 00e0 7018 1800     .............p..
   baedc:	0030 3818 7f00 001f 1f7f 0000 0000 0000     0..8............
	...
   baf04:	7f00 0080 807f 0c00 0000 000c 0c00 0000     ................
   baf14:	000c 0c00 0000 000c 0c00 000c 0c0c 0c00     ................
   baf24:	000c 0c0c 7f00 00fc fc7f 0000 0000 0000     ................
	...
   baf4c:	f000 000f 1ff8 3800 001c 3c3c 3c00 003c     .......8..<<.<<.
   baf5c:	6c36 3600 006c cc33 3300 00cc 8c31 3000     6l.6l.3..3..1..0
   baf6c:	000c 0c30 fe00 007f 7ffe 0000 0000 0000     ..0.............
	...
   baf94:	7800 00fe fe78 1c00 0018 181e 1f00 0018     .x..x...........
   bafa4:	181b 1b00 0098 d819 1800 00d8 f818 1800     ................
   bafb4:	0078 3818 7f00 0018 187f 0000 0000 0000     x..8............
	...
   bafdc:	0300 00c0 f00f 1c00 0038 1818 3800 001c     ........8....8..
   bafec:	0c30 3000 000c 0c30 3000 000c 1c38 1800     0..0..0..0..8...
   baffc:	0018 381c 0f00 00f0 c003 0000 0000 0000     ...8............
	...
   bb024:	3f00 00f0 f83f 0c00 001c 0c0c 0c00 000c     .?..?...........
   bb034:	0c0c 0c00 0018 f80f 0f00 00e0 000c 0c00     ................
   bb044:	0000 000c 3f00 00c0 c03f 0000 0000 0000     .....?..?.......
	...
   bb06c:	0300 00c0 f00f 1c00 0038 1818 3800 001c     ........8....8..
   bb07c:	0c30 3000 000c 0c30 3000 000c 1c38 1800     0..0..0..0..8...
   bb08c:	0018 381c 0f00 00f0 c007 0700 00cc fc0f     ...8............
   bb09c:	0c00 0038 0000 0000 0000 0000 0000 0000     ..8.............
	...
   bb0b4:	7f00 00e0 f07f 1800 0038 1818 1800 0018     ........8.......
   bb0c4:	3818 1f00 00f0 c01f 1800 00e0 7018 1800     .8...........p..
   bb0d4:	0030 3818 7f00 001e 0e7f 0000 0000 0000     0..8............
	...
   bb0fc:	0700 00d8 f80f 1c00 0038 1818 1800 0018     ........8.......
   bb10c:	001e 0f00 00c0 f003 0000 0078 1818 1800     ..........x.....
   bb11c:	0018 381c 1f00 00f0 e01b 0000 0000 0000     ...8............
	...
   bb144:	3f00 00fc fc3f 3100 008c 8c31 3100 008c     .?..?..1..1..1..
   bb154:	8c31 0100 0080 8001 0100 0080 8001 0100     1...............
   bb164:	0080 8001 0f00 00f0 f00f 0000 0000 0000     ................
	...
   bb18c:	7e00 007e 7e7e 1800 0018 1818 1800 0018     .~~.~~..........
   bb19c:	1818 1800 0018 1818 1800 0018 1818 1800     ................
   bb1ac:	0018 300c 0f00 00f0 c003 0000 0000 0000     ...0............
	...
   bb1d4:	7f00 007f 7f7f 1800 000c 180c 0c00 0018     ................
   bb1e4:	180c 0600 0030 3006 0300 0060 6003 0300     ....0..0..`..`..
   bb1f4:	0060 c001 0100 00c0 8000 0000 0000 0000     `...............
	...
   bb21c:	fe00 803f 3ffe 3080 0006 0630 3000 0086     ..?..?.0..0..0..
   bb22c:	cc19 1900 00cc 6c1b 1b00 006c 7c1e 0e00     .......l..l..|..
   bb23c:	0038 380e 0c00 0018 180c 0000 0000 0000     8..8............
	...
   bb264:	7e00 007e 7e7e 1800 0018 300c 0600 0060     .~~.~~.....0..`.
   bb274:	c003 0100 0080 8001 0300 00c0 6006 0c00     .............`..
   bb284:	0030 1818 7e00 007e 7e7e 0000 0000 0000     0....~~.~~......
	...
   bb2ac:	7c00 007e 7e7c 1800 0018 300c 0600 0060     .|~.|~.....0..`.
   bb2bc:	6006 0300 00c0 8001 0100 0080 8001 0100     .`..............
   bb2cc:	0080 8001 0f00 00f0 f00f 0000 0000 0000     ................
	...
   bb2f4:	1f00 00f8 f81f 1800 0018 3018 1800 0060     ...........0..`.
   bb304:	c018 0100 0080 0003 0600 0018 180c 1800     ................
   bb314:	0018 1830 3f00 00f8 f83f 0000 0000 0000     ..0..?..?.......
	...
   bb338:	0000 f001 0100 00f0 8001 0100 0080 8001     ................
   bb348:	0100 0080 8001 0100 0080 8001 0100 0080     ................
   bb358:	8001 0100 0080 8001 0100 0080 8001 0100     ................
   bb368:	0080 f001 0100 00f0 0000 0000 0000 0000     ................
   bb378:	0000 0000 0018 1800 0000 001c 0c00 0000     ................
   bb388:	000e 0600 0000 0006 0300 0000 0003 0100     ................
   bb398:	0080 8001 0000 00c0 c000 0000 0060 6000     ............`..`
   bb3a8:	0000 0070 3000 0000 0038 1800 0000 0018     ..p..0..8.......
	...
   bb3c8:	0000 800f 0f00 0080 8001 0100 0080 8001     ................
   bb3d8:	0100 0080 8001 0100 0080 8001 0100 0080     ................
   bb3e8:	8001 0100 0080 8001 0100 0080 8001 0100     ................
   bb3f8:	0080 800f 0f00 0080 0000 0000 0000 0000     ................
	...
   bb410:	0080 c001 0300 00e0 7007 0600 0030 180c     .........p..0...
   bb420:	1800 000c 0410 0000 0000 0000 0000 0000     ................
	...
   bb494:	0000 ffff ff00 00ff 0000 0300 0000 8003     ................
   bb4a4:	0000 00e0 6000 0000 0000 0000 0000 0000     .....`..........
	...
   bb4f4:	0000 c00f 1f00 00e0 3000 0000 0030 f007     .........0..0...
   bb504:	1f00 00f0 3038 3000 0030 7030 1f00 00fc     ....80.00.0p....
   bb514:	bc0f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb530:	0000 0078 7800 0000 0018 1800 0000 e01b     ..x..x..........
   bb540:	1f00 00f8 181c 1800 000c 0c18 1800 000c     ................
   bb550:	0c18 1800 000c 181c 7f00 00f8 e07b 0000     ............{...
	...
   bb584:	0000 ec03 0f00 00fc 1c1c 3800 000c 0c30     ...........8..0.
   bb594:	3000 0000 0030 3800 000c 1c1c 0f00 00f8     .0..0..8........
   bb5a4:	f003 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb5c0:	0000 7800 0000 0078 1800 0000 0018 d807     ...x..x.........
   bb5d0:	1f00 00f8 3818 3000 0018 1830 3000 0018     .....8.0..0..0..
   bb5e0:	1830 3000 0018 3818 1f00 00fe de07 0000     0..0...8........
	...
   bb614:	0000 e007 1f00 00f8 1818 3000 000c fc3f     ...........0..?.
   bb624:	3f00 00fc 0030 3000 0000 0c18 1f00 00fc     .?..0..0........
   bb634:	f007 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb650:	0000 fc01 0300 00fc 0006 0600 0000 f83f     ..............?.
   bb660:	3f00 00f8 0006 0600 0000 0006 0600 0000     .?..............
   bb670:	0006 0600 0000 0006 3f00 00f0 f03f 0000     .........?..?...
	...
   bb6a4:	0000 de07 1f00 00fe 3818 3000 0018 1830     .........8.0..0.
   bb6b4:	3000 0018 1830 3000 0018 3818 1f00 00f8     .0..0..0...8....
   bb6c4:	d807 0000 0018 1800 0000 0038 f00f 0f00     ..........8.....
   bb6d4:	00c0 0000 0000 0000 0000 0000 0000 0078     ..............x.
   bb6e4:	7800 0000 0018 1800 0000 e01b 1f00 00f0     .x..............
   bb6f4:	381c 1800 0018 1818 1800 0018 1818 1800     .8..............
   bb704:	0018 1818 7e00 007e 7e7e 0000 0000 0000     .....~~.~~......
	...
   bb728:	0000 8001 0100 0080 0000 0000 0000 801f     ................
   bb738:	1f00 0080 8001 0100 0080 8001 0100 0080     ................
   bb748:	8001 0100 0080 8001 3f00 00fc fc3f 0000     .........?..?...
	...
   bb770:	0000 c000 0000 00c0 0000 0000 0000 f01f     ................
   bb780:	1f00 00f0 3000 0000 0030 3000 0000 0030     .....0..0..0..0.
   bb790:	3000 0000 0030 3000 0000 0030 3000 0000     .0..0..0..0..0..
   bb7a0:	0030 3000 0000 0070 e01f 1f00 0080 0000     0..0..p.........
	...
   bb7b8:	0000 003c 3c00 0000 000c 0c00 0000 f80c     ..<..<..........
   bb7c8:	0c00 00f8 c00c 0d00 0080 800f 0f00 0000     ................
   bb7d8:	800f 0d00 00c0 e00c 3c00 007c 7c3c 0000     .........<|.<|..
	...
   bb800:	0000 801f 1f00 0080 8001 0100 0080 8001     ................
   bb810:	0100 0080 8001 0100 0080 8001 0100 0080     ................
   bb820:	8001 0100 0080 8001 3f00 00fc fc3f 0000     .........?..?...
	...
   bb854:	0000 78f7 ff00 00fc cc39 3100 008c 8c31     ...x....9..1..1.
   bb864:	3100 008c 8c31 3100 008c 8c31 fd00 00ef     .1..1..1..1.....
   bb874:	effd 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb89c:	0000 e07b 7f00 00f0 381c 1800 0018 1818     ..{......8......
   bb8ac:	1800 0018 1818 1800 0018 1818 7e00 007e     .............~~.
   bb8bc:	7e7e 0000 0000 0000 0000 0000 0000 0000     ~~..............
	...
   bb8e4:	0000 c003 0f00 00f0 381c 3800 001c 0c30     .........8.8..0.
   bb8f4:	3000 000c 0c30 3800 001c 381c 0f00 00f0     .0..0..8...8....
   bb904:	c003 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb92c:	0000 e07b 7f00 00f8 181c 1800 000c 0c18     ..{.............
   bb93c:	1800 000c 0c18 1800 000c 181c 1f00 00f8     ................
   bb94c:	e01b 1800 0000 0018 1800 0000 007f 7f00     ................
	...
   bb974:	0000 de07 1f00 00fe 3818 3000 0018 1830     .........8.0..0.
   bb984:	3000 0018 1830 3000 0018 3818 1f00 00f8     .0..0..0...8....
   bb994:	d807 0000 0018 1800 0000 0018 fe00 0000     ................
   bb9a4:	00fe 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bb9bc:	0000 783e 3e00 00fc cc07 0700 0000 0006     ..>x.>..........
   bb9cc:	0600 0000 0006 0600 0000 0006 3f00 00f0     .............?..
   bb9dc:	f03f 0000 0000 0000 0000 0000 0000 0000     ?...............
	...
   bba04:	0000 f807 0f00 00f8 1818 1800 0018 801f     ................
   bba14:	0f00 00f0 f800 1800 0018 3818 1f00 00f0     ...........8....
   bba24:	e01f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bba40:	0000 000c 0c00 0000 000c 0c00 0000 f03f     ..............?.
   bba50:	3f00 00f0 000c 0c00 0000 000c 0c00 0000     .?..............
   bba60:	000c 0c00 0000 1c0c 0700 00fc f003 0000     ................
	...
   bba94:	0000 7878 7800 0078 1818 1800 0018 1818     ..xx.xx.........
   bbaa4:	1800 0018 1818 1800 0018 3818 0f00 00fe     ...........8....
   bbab4:	de07 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bbadc:	0000 3e7c 7c00 003e 1818 1800 0018 300c     ..|>.|>........0
   bbaec:	0c00 0030 6006 0600 0060 e007 0300 00c0     ..0..`..`.......
   bbafc:	c003 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bbb24:	0000 3c78 7800 003c 1831 3300 0098 9833     ..x<.x<.1..3..3.
   bbb34:	1a00 00b0 f01e 1e00 00f0 601c 0c00 0060     ...........`..`.
   bbb44:	600c 0000 0000 0000 0000 0000 0000 0000     .`..............
	...
   bbb6c:	0000 7c3e 3e00 007c 300c 0600 0060 c003     ..>|.>|..0..`...
   bbb7c:	0100 0080 c003 0600 0060 300c 3e00 007c     ........`..0.>|.
   bbb8c:	7c3e 0000 0000 0000 0000 0000 0000 0000     >|..............
	...
   bbbb4:	0000 1f7e 7e00 001f 0c18 0c00 0018 180c     ..~..~..........
   bbbc4:	0600 0030 3006 0300 0060 e003 0100 00c0     ..0..0..`.......
   bbbd4:	c000 0100 0080 8001 0300 0000 c03f 3f00     ............?..?
   bbbe4:	00c0 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bbbfc:	0000 f81f 1f00 00f8 3018 1800 0060 c000     .........0..`...
   bbc0c:	0100 0080 0003 0600 0018 180c 1f00 00f8     ................
   bbc1c:	f81f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   bbc38:	0000 e000 0100 00e0 8001 0100 0080 8001     ................
   bbc48:	0100 0080 8001 0100 0080 8003 0700 0000     ................
   bbc58:	8003 0100 0080 8001 0100 0080 8001 0100     ................
   bbc68:	0080 e001 0000 00e0 0000 0000 0000 0000     ................
	...
   bbc80:	0000 8001 0100 0080 8001 0100 0080 8001     ................
   bbc90:	0100 0080 8001 0100 0080 8001 0100 0080     ................
   bbca0:	8001 0100 0080 8001 0100 0080 8001 0100     ................
   bbcb0:	0080 8001 0100 0080 0000 0000 0000 0000     ................
	...
   bbcc8:	0000 0007 0700 0080 8001 0100 0080 8001     ................
   bbcd8:	0100 0080 8001 0100 0080 c001 0000 00e0     ................
   bbce8:	c001 0100 0080 8001 0100 0080 8001 0100     ................
   bbcf8:	0080 8007 0700 0000 0000 0000 0000 0000     ................
	...
   bbd24:	000e 1f00 0018 b83b 3100 00f0 e000 0000     ......;..1......
	...
   bbd54:	0030 6177 656b 7520 2070 7265 6f72 2172     0.wake up error!
   bbd64:	6e00 206f 6163 6472 0021 6c66 7361 0065     .no card!.flase.
   bbd74:	6572 6461 6520 7272 726f 0021 6572 6461     read error!.read
   bbd84:	7420 6d69 6f65 7475 0021 6e75 6e6b 776f      timeout!.unknow
   bbd94:	206e 7265 6f72 2172 0000 0000               n error!....

000bbda0 <_ZTV17DFRobot_PN532_IIC>:
	...
   bbda8:	5f85 000b 631b 000b                         ._...c..

000bbdb0 <_ZTVN5spark13CellularClassE>:
	...
   bbdb8:	6b37 000b 6b2d 000b 6b23 000b 6ad9 000b     7k..-k..#k...j..
   bbdc8:	6b17 000b 6b0b 000b 73dd 000b 73e5 000b     .k...k...s...s..
   bbdd8:	6aff 000b 6af7 000b 6aed 000b 6ae3 000b     .j...j...j...j..
   bbde8:	7415 000b                                   .t..

000bbdec <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   bbdf4:	6b71 000b 6b77 000b 6bb5 000b 6b85 000b     qk..wk...k...k..
   bbe04:	6b73 000b                                   sk..

000bbe08 <_ZTVN5spark13EthernetClassE>:
	...
   bbe10:	716b 000b 7161 000b 7157 000b 714d 000b     kq..aq..Wq..Mq..
   bbe20:	7141 000b 7135 000b 73dd 000b 73e5 000b     Aq..5q...s...s..
   bbe30:	7129 000b 7121 000b 7117 000b 710d 000b     )q..!q...q...q..
   bbe40:	7415 000b                                   .t..

000bbe44 <_ZTV7TwoWire>:
	...
   bbe4c:	7189 000b 71d3 000b 71ab 000b 718b 000b     .q...q...q...q..
   bbe5c:	71b3 000b 71bb 000b 71c3 000b 71cb 000b     .q...q...q...q..

000bbe6c <_ZTV9IPAddress>:
	...
   bbe74:	72ad 000b 729d 000b 729f 000b 7061 0070     .r...r...r..app.

000bbe84 <_ZTVN5spark12NetworkClassE>:
	...
   bbe8c:	739d 000b 73a7 000b 73b1 000b 73bb 000b     .s...s...s...s..
   bbe9c:	73c5 000b 73d1 000b 73dd 000b 73e5 000b     .s...s...s...s..
   bbeac:	73ed 000b 73f9 000b 7401 000b 740b 000b     .s...s...t...t..
   bbebc:	7415 000b                                   .t..

000bbec0 <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
   bbec0:	0800 1810 2820 3830 5925 252d 2d6d 6425     .... (08%Y-%m-%d
   bbed0:	2554 3a48 4d25 253a 2553 007a 7361 7463     T%H:%M:%S%z.asct
   bbee0:	6d69 0065                                   ime.

000bbee4 <_ZTV11USARTSerial>:
	...
   bbeec:	7c89 000b 7cf5 000b 7ccd 000b 7501 000b     .|...|...|...u..
   bbefc:	7c9d 000b 7cb9 000b 7cab 000b 7cc7 000b     .|...|...|...|..
   bbf0c:	7c8b 000b 7c8f 000b                         .|...|..

000bbf14 <_ZTV9USBSerial>:
	...
   bbf1c:	7d33 000b 7d9b 000b 7d71 000b 7501 000b     3}...}..q}...u..
   bbf2c:	7d63 000b 7d35 000b 7d45 000b 7d95 000b     c}..5}..E}...}..
   bbf3c:	7d55 000b 7d2d 000b                         U}..-}..

000bbf44 <_ZSt7nothrow>:
   bbf44:	5200 4545 544e 6d20 6c61 6f6c 2063 7573     .REENT malloc su
   bbf54:	6363 6565 6564 0064 742f 706d 6a2f 6e65     cceeded./tmp/jen
   bbf64:	696b 736e 472d 4343 312d 2d30 6970 6570     kins-GCC-10-pipe
   bbf74:	696c 656e 342d 5f38 3032 3032 3131 3432     line-48_20201124
   bbf84:	315f 3036 3136 3038 3336 2f39 7273 2f63     _1606180639/src/
   bbf94:	656e 6c77 6269 6e2f 7765 696c 2f62 696c     newlib/newlib/li
   bbfa4:	6362 732f 6474 696c 2f62 6172 646e 632e     bc/stdlib/rand.c
   bbfb4:	2f00 6d74 2f70 656a 6b6e 6e69 2d73 4347     ./tmp/jenkins-GC
   bbfc4:	2d43 3031 702d 7069 6c65 6e69 2d65 3834     C-10-pipeline-48
   bbfd4:	325f 3230 3130 3231 5f34 3631 3630 3831     _20201124_160618
   bbfe4:	3630 3933 732f 6372 6e2f 7765 696c 2f62     0639/src/newlib/
   bbff4:	656e 6c77 6269 6c2f 6269 2f63 7473 6972     newlib/libc/stri
   bc004:	676e 732f 7274 6f74 2e6b 0063               ng/strtok.c.

000bc010 <_ctype_>:
   bc010:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   bc020:	2020 2020 2020 2020 2020 2020 2020 2020                     
   bc030:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   bc040:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   bc050:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   bc060:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   bc070:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   bc080:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   bc090:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

000bc111 <link_const_data_end>:
   bc111:	00          	.byte	0x00
	...

000bc114 <link_constructors_location>:
   bc114:	000b5311 	.word	0x000b5311
   bc118:	000b6ac9 	.word	0x000b6ac9
   bc11c:	000b6b41 	.word	0x000b6b41
   bc120:	000b7175 	.word	0x000b7175
   bc124:	000b738d 	.word	0x000b738d
   bc128:	000b74ed 	.word	0x000b74ed
   bc12c:	000b7629 	.word	0x000b7629
   bc130:	000b7a75 	.word	0x000b7a75
   bc134:	000b7c75 	.word	0x000b7c75
